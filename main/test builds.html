<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Underground</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <style>
    :root { /* Apply variables to the root element */
      --bg-dark: #1c1c1e;
      --sidebar-dark: #2c2c2e;
      --text-light: #fff;
      --text-muted: #aaa;
      --card-bg: #1a1a1a;
      --accent: #00ff84;
      --transition-speed: 0.3s;
      --border-radius: 8px;
      --icon-size: 1.2rem;
      --search-height: 40px; /* Added for consistent search bar height */
    }


    .reset-button {
        background-color: #ff4444;
        color: white;
        width: 100%;
        margin-top: auto !important;
    }

    .reset-button:hover {
      background-color: #cc0000;
    }


    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      display: flex;
      /* Background color is now primarily handled by Vanta.js */
      /* background-color: var(--bg-dark); */
      color: var(--text-light); /* Use variable */
      height: 100vh;
      overflow: hidden;
      position: relative; /* Needed for z-index stacking */
    }

    /* Ensure Vanta canvas is behind everything else */
    .vanta-canvas {
       z-index: -1 !important; /* Important might be needed depending on Vanta's internal styles */
       position: absolute !important;
       top: 0;
       left: 0;
       width: 100% !important;
       height: 100% !important;
    }


    .sidebar {
      width: 60px;
      position: fixed; /* Use fixed for positioning relative to viewport */
      top: 0;
      left: -60px;
      height: 100%;
      background-color: var(--sidebar-dark); /* Use variable */
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem 0;
      gap: 1.5rem;
      transition: left var(--transition-speed) ease;
      z-index: 10; /* Sidebar needs to be above Vanta */
    }

    .sidebar.open {
      left: 0;
    }

    .icon {
      color: var(--text-muted); /* Use variable */
      font-size: var(--icon-size);
      padding: 10px;
      border-radius: var(--border-radius);
      transition: background 0.2s;
      cursor: pointer;
      position: relative;
    }

    .icon:hover, .icon.active {
      background-color: var(--accent); /* Use variable */
      color: white; /* Or var(--text-light) if you want icon hover color to change */
    }

    .tooltip {
      position: fixed;
      background-color: var(--accent); /* Use variable */
      color: white; /* Or var(--text-light) */
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.8rem;
      pointer-events: none;
      z-index: 9999;
      display: none;
    }

    .content {
      flex: 1;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      /* Removed align-items: center; to allow flexible layout */
      overflow-y: auto;
      margin-left: 0; /* Adjust margin since sidebar is fixed */
      transition: margin-left var(--transition-speed) ease;
      z-index: 5; /* Content above Vanta */
      position: relative; /* Needed for z-index */
      background-color: transparent; /* Let Vanta show through */
      width: 100%; /* Ensure content takes full width */
      box-sizing: border-box;
      color: var(--text-light); /* Ensure text color is set for the content area */
    }

    .sidebar.open ~ .content {
        margin-left: 60px; /* Push content when sidebar is open */
    }


    h1 {
      margin-bottom: 2rem;
    }

    .panel {
        /* Existing styles */
        padding: 1.5rem; /* This is a good starting point, maybe increase slightly if content feels cramped */
        margin: 1rem auto; /* Use auto for left/right margin to center the block if it has a max-width */
        max-width: 800px; /* Example: Give panels a max-width to prevent them from stretching too wide on large screens */
        width: 95%; /* Ensure responsiveness */
        box-shadow: 0 4px 15px rgba(0,0,0,0.2); /* Existing shadow */
        background-color: var(--card-bg); /* Use variable */
        border-radius: var(--border-radius);
        box-sizing: border-box;
        color: var(--text-light); /* Ensure text color is set for the panel */
    }

    .panel-container {
      display: flex;
      flex-direction: column; /* Stack panels vertically */
      gap: 1rem; /* Adjust gap between panels */
      flex-wrap: wrap;
      justify-content: flex-start; /* Align panels to the start */
      opacity: 1;
      transition: opacity var(--transition-speed) ease;
      width: 100%; /* Ensure container takes width */
       align-items: center; /* Center panels horizontally */
    }

    .panel-container.fade-out {
      opacity: 0;
    }

    .panel h2 {
        margin-top: 0; /* Remove top margin from the first element */
        margin-bottom: 1rem; /* Space below the heading */
        color: var(--accent); /* Use accent for headings */
    }

    .panel h3 {
         margin-top: 1.5rem; /* Space above subheadings */
         margin-bottom: 0.8rem; /* Space below subheadings */
         color: var(--text-light); /* Or var(--accent) */
    }

    .panel p {
        margin-bottom: 1em; /* Space below paragraphs */
         color: var(--text-muted); /* Use variable for paragraph text */
    }

    input[type="text"] {
      background: var(--card-bg); /* Use variable */
      border: 1px solid var(--accent); /* Use variable */
      padding: 0.5rem;
      width: 100%; /* Take full width of parent */
      margin-bottom: 0.5rem;
      color: var(--text-light); /* Use variable */
      border-radius: 5px;
      transition: border var(--transition-speed) ease;
      box-sizing: border-box; /* Include padding and border in element's total width */
       height: var(--search-height); /* Use defined height */
       font-size: 1rem; /* Adjust font size */
       padding-left: calc(0.5rem + 24px); /* Space for search icon */
    }

    input[type="text"]:focus {
      outline: none;
      border-color: var(--text-light); /* Use variable */
    }

    button {
      background-color: var(--accent); /* Use variable */
      color: black; /* Changed for better contrast on accent, or use var(--bg-dark) */
      border: none; /* Removed border */
      padding: 0.5rem 1rem;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      transition: all var(--transition-speed) ease;
    }

    button:hover {
      filter: brightness(1.2); /* Brighter accent on hover */
      box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Slight shadow on hover */
    }


    .game-card, .action-card {
      background-color: var(--card-bg); /* Use variable */
      border-radius: 10px;
      padding: 1rem;
      text-align: center;
      cursor: pointer;
      transition: transform 0.2s;
      width: 150px;
      position: relative;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2); /* Add shadow */
    }

    .game-card:hover, .action-card:hover {
      transform: scale(1.05);
    }

    .game-card img {
      width: 100%;
      border-radius: var(--border-radius);
      margin-bottom: 0.5rem;
    }

    .iframe-container {
      position: absolute;
      top: 0;
      left: 0; /* Starts from the very left */
      right: 0;
      bottom: 60px; /* Space for bottom controls */
      display: flex;
      justify-content: center;
      align-items: center;
       width: 100%; /* Take full width */
       height: calc(100% - 60px); /* Adjust height */
       z-index: 20; /* Above sidebar and content when viewing */
       background: var(--bg-dark); /* Background for iframe view */
    }

    .iframe-container iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    .bottom-controls {
      position: fixed; /* Fixed to bottom */
      bottom: 0;
      left: 0; /* Starts from the very left */
      right: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 10px;
      background-color: var(--bg-dark); /* Use variable */
      border-top: 1px solid #444; /* Keep static or make a variable */
      z-index: 25; /* Above iframe */
      box-sizing: border-box;
    }


    .bottom-controls input[type="text"] {
      flex: 1;
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #ccc; /* Keep static or make a variable */
      margin-right: 10px;
      background-color: var(--card-bg); /* Use variable */
      color: var(--text-light); /* Use variable */
    }

    .bottom-controls button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      background-color: var(--accent); /* Use variable */
      color: black; /* Changed color, or use var(--bg-dark) */
    }
    .bottom-controls button:hover {
       filter: brightness(1.2);
    }


    .fullscreen-button i {
      margin-right: 5px;
    }

    .bottom-icons {
      margin-top: auto;
      border-top: 1px solid #444; /* Keep static or make a variable */
      padding-top: 1rem;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .bottom-icons .icon {
      margin-top: 1rem;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7); /* Keep static or make a variable */
      z-index: 100;
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background-color: var(--card-bg); /* Use variable */
      padding: 2rem;
      border-radius: var(--border-radius);
      width: 300px;
      position: relative;
      box-shadow: 0 5px 20px rgba(0,0,0,0.3); /* Keep static or make a variable */
    }

    .modal-close {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: var(--text-muted); /* Use variable */
      font-size: var(--icon-size);
      cursor: pointer;
    }

    .modal-close:hover {
      color: white; /* Or var(--text-light) */
    }

    .modal-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 1rem;
    }

    .games-container {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem; /* Increased gap */
        justify-content: center;
        padding: 1rem; /* Add padding */
        width: 100%; /* Take full width */
    }

    .games-header {
      display: flex;
      justify-content: center;
      gap: 1rem;
      width: 100%;
      margin-bottom: 1rem;
    }

    .remove-game {
      margin-top: 1rem;
      background-color: #ff4444; /* Keep specific color or make a variable */
      color: white;
      font-weight: bold;
      width: 100%;
    }

    .remove-icon {
      position: absolute;
      top: 5px;
      right: 5px;
      color: #ff4444; /* Keep specific color or make a variable */
      background: rgba(0,0,0,0.7); /* Keep static or make a variable */
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      cursor: pointer;
      z-index: 2;
      transition: background 0.2s, color 0.2s;
    }

    .remove-icon:hover {
      background: #ff4444; /* Keep specific color or make a variable */
      color: white;
    }


    .game-card.dragging {
      opacity: 0.5;
      transform: scale(0.95);
    }

    .game-card-placeholder {
      border: 2px dashed #444; /* Keep static or make a variable */
      background-color: transparent;
    }

    .theme-option {
      width: 50px;
      height: 50px;
      margin: 5px;
      cursor: pointer;
      transition: transform 0.2s, border-color 0.2s; /* Smooth transition */
    }

    .theme-option:hover {
      transform: scale(1.1);
       border-color: rgba(255, 255, 255, 0.5); /* Subtle border on hover */
    }

    .theme-option.selected {
      border-color: var(--accent); /* Use variable */
      transform: scale(1.1);
    }

    .theme-selector {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 1rem;
    }

    .theme-default-preview { background: linear-gradient(135deg, #1c1c1e 50%, #2c2c2e 50%); }
    .theme-cyberpunk-preview { background: linear-gradient(135deg, #0f0f1a 50%, #1a1a2e 50%); }
    .theme-sunset-preview { background: linear-gradient(135deg, #2c1a1a 50%, #4a2c2c 50%); }
    .theme-forest-night-preview { background: linear-gradient(135deg, #0d1a0b 50%, #1a2e17 50%); }
    .theme-midnight-sky-preview { background: linear-gradient(135deg, #1a1c2e 50%, #2b2e4a 50%); }
    .theme-volcano-preview { background: linear-gradient(135deg, #3a0d0d 50%, #5f1c1c 50%); }
    .theme-arctic-preview { background: linear-gradient(135deg, #0a1a1c 50%, #1c3a3d 50%); }
    .theme-grayscale-preview { background: linear-gradient(135deg, #1c1c1c 50%, #2c2c2c 50%); }
    .theme-sunny-preview { background: linear-gradient(135deg, #4a3a1a 50%, #6a4a1a 50%); }
    .theme-marine-preview { background: linear-gradient(135deg, #0f2a3a 50%, #1a3c4a 50%); }
    .theme-swamp-preview { background: linear-gradient(135deg, #2b2b1c 50%, #3a3a2a 50%); }
      
    .favorite-button {
      background-color: transparent;
      color: var(--text-muted); /* Use muted text color variable */
      border: none;
      padding: 5px 8px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: all 0.2s;
    }

    .favorite-button:hover {
      background-color: rgba(255,255,255,0.1); /* Keep static or make a variable */
      color: var(--text-light); /* Lighten on hover using variable */
    }
     .favorite-button i.fa-star { /* Style filled star */
        color: var(--accent); /* Use variable */
     }


    #librarySearch {
        margin: 1rem auto; /* Add margin */
        display: block;
        width: 80%;
        max-width: 400px; /* Max width */
    }

    .library-item {
      position: relative;
      padding: 4px 12px;
      border-radius: 6px;
      transition: all 0.2s ease;
      width: 90%;
      margin: 4px auto;
      background-color: var(--card-bg); /* Use variable */
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 30px;
      min-height: 30px;
      box-sizing: border-box;
      overflow: hidden;
    }

    .library-item-content {
      flex: 1;
      text-align: left; /* Align left */
      padding: 0 35px 0 25px; /* Adjust padding for icons */
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 0.9rem;
      border-radius: 4px;
      transition: all 0.2s ease;
      color: var(--text-light); /* Ensure text is visible using variable */
    }

    .library-item:hover {
       background-color: var(--sidebar-dark); /* Darker background on hover using variable */
    }

    .library-item:hover .library-item-content {
       color: var(--accent); /* Accent color for text on hover using variable */
       background-color: transparent; /* Remove background change */
     }


    .library-item .remove-icon {
      position: absolute;
      left: 6px;
      top: 50%; /* Center vertically */
      transform: translateY(-50%); /* Center vertically */
      color: var(--text-muted); /* Use variable */
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s;
      z-index: 2;
    }

    .library-item:hover .remove-icon {
       color: #ff4444; /* Red remove icon on hover - keep static or make variable */
       background: rgba(255, 68, 68, 0.2); /* Slight red background - keep static or make variable */
    }


    .favorite-transition {
      opacity: 0;
      transition: opacity var(--transition-speed) ease;
    }

    .favorite-transition.show {
      opacity: 1;
    }

    .action-card i {
      font-size: 2rem;
      margin-bottom: 0.5rem;
      color: var(--accent); /* Use variable */
    }

    .action-card p {
      margin: 0;
       color: var(--text-muted); /* Muted text for actions using variable */
    }
     .action-card:hover p {
        color: var(--text-light); /* Lighten text on hover using variable */
     }

    .library-columns {
      display: flex;
      flex-wrap: wrap; /* Allow wrapping on smaller screens */
      gap: 2rem;
      justify-content: center;
      width: 100%;
    }

    .library-column {
      flex: 1;
      min-width: 250px; /* Min width before wrapping */
      max-width: 45%;
    }

    .library-column h3 {
      text-align: center;
      margin-bottom: 1rem;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--accent); /* Use variable */
      color: var(--accent); /* Accent color for headings using variable */
    }
    /* Add specific styling for changelog modal content */
    #changelogContent {
        background-color: var(--bg-dark); /* Match theme background */
        color: var(--text-light); /* Match theme text color */
        padding: 1rem;
        border-radius: var(--border-radius);
        max-height: 60vh;
        max-width: 900px;/* Limit height */
        overflow-y: auto; /* Allow scrolling */
        border: 1px solid var(--sidebar-dark); /* Subtle border using variable */
    }

    /* --- Home Page Specific Styles --- */
    .home-bottom-section {
        display: flex; /* Use flexbox to place news and game button side-by-side */
        justify-content: space-between; /* Push items to the ends */
        align-items: flex-start; /* Align items to the top */
        gap: 20px; /* Space between news and game button */
        width: 95%; /* Match the width of the news panel */
        max-width: 1100px; /* Adjust max-width as needed to accommodate both */
        margin: 0 auto; /* Center the section */
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
    }

    .home-layout {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%; /* Take full height of content container */
        position: relative; /* Needed for absolute positioning of middle section */
        align-items: center; /* Center items horizontally by default */
        overflow-y: auto; /* Allow scrolling if content exceeds height */
        padding-top: 20px; /* Add some space at the top */
    }

    .home-header {
        width: 100%;
        text-align: center; /* Center the logo */
        margin-bottom: 20px; /* Space below the logo */
    }

    .home-logo {
        font-size: 3rem; /* Large font size for the name */
        font-weight: bold;
        color: var(--text-light); /* Ensure name is bright using variable */
        text-shadow: 0 0 10px var(--accent); /* Optional: glow effect using variable */
    }

    .home-main-section {
        display: flex;
        align-items: center;
        justify-content: center; /* Center the items horizontally */
        gap: 20px; /* Space between items */
        margin-bottom: 30px; /* Space below this section */
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
    }

    .home-search-container {
        display: flex;
        align-items: center;
        position: relative; /* For search icon */
        flex-grow: 1; /* Allow search to take available space */
        max-width: 400px; /* Limit max width */
    }

    .home-search-container input[type="text"] {
        flex-grow: 1; /* Allow input to fill space */
        padding-left: calc(1rem + 24px); /* Adjust padding for icon */
    }

    .home-search-container .search-icon {
        position: absolute;
        left: 10px;
        color: var(--text-muted); /* Use variable */
        font-size: 1.2rem;
        height: var(--search-height); /* Match search height */
        display: flex;
        align-items: center; /* Vertically center icon */
    }

    .home-status {
        color: var(--text-muted); /* Use variable */
        font-size: 0.9rem;
        display: flex; /* Use flexbox for status items */
        gap: 15px; /* Space between status items */
    }

    .home-status p {
        margin: 0; /* Remove default paragraph margin */
    }


    .home-news-panel {
        width: 95%; /* Adjust width as needed */
        max-width: 800px; /* Limit max width */
        margin: 0 auto; /* Center the news panel */
        flex-shrink: 0; /* Prevent shrinking */
        flex: 2;
        min-width: 300px;
    }

     /* Explicitly set color for the pre tag containing news content */
    #news-content {
        color: var(--text-light); /* Ensure news content text uses the light text color variable */
    }


    .game-of-day-container {
        flex: 1; /* Allow the game container to take remaining space */
        min-width: 180px; /* Minimum width for the game container */
        max-width: 200px; /* Maximum width for the game container */
        display: flex; /* Use flex to center the button */
        flex-direction: column; /* Stack content vertically if needed */
        align-items: center; /* Center button horizontally */
        padding: 1.5rem; /* Add padding similar to panels */
        background-color: var(--card-bg); /* Use card background variable */
        border-radius: var(--border-radius); /* Use defined radius */
        box-shadow: 0 4px 15px rgba(0,0,0,0.2); /* Add shadow */
         text-align: center; /* Center text inside */
         box-sizing: border-box; /* Include padding in width */
    }

     .game-of-day-container h3 {
         margin-top: 0;
         margin-bottom: 1rem;
         color: var(--accent); /* Use variable */
     }


    .game-of-day-button {
        /* Inherit styles from game-card but maybe adjust size */
        background-color: var(--card-bg); /* Use variable */
        border-radius: 10px;
        padding: 1rem;
        text-align: center;
        cursor: pointer;
        transition: transform 0.2s;
        width: 100%; /* Take full width of its container */
        position: relative;
        box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        box-sizing: border-box; /* Include padding in width */
         /* Ensure flex properties don't conflict if container is flex */
         flex-shrink: 0;
         flex-grow: 0;
         margin: 0; /* Remove margin if inheriting from game-card */
    }

     .game-of-day-button:hover {
        transform: scale(1.05);
     }

     .game-of-day-button img {
        width: 100%;
        border-radius: var(--border-radius);
        margin-bottom: 0.5rem;
     }
      .game-of-day-button p {
          margin: 0;
          color: var(--text-light); /* Use variable */
          font-weight: bold;
      }

    .changelog-button {
        background-color: var(--accent); /* Use the theme's accent color variable */
        color: black; /* Set text color to black for contrast on the accent color */
        border: none; /* Remove the border */
        padding: 0.5rem 1rem;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: all var(--transition-speed) ease;
        display: flex; /* Use flexbox to align the icon and text */
        align-items: center; /* Vertically center the icon and text */
        gap: 5px; /* Add a small gap between the icon and the text */
    }

    .changelog-button:hover {
        filter: brightness(1.2); /* Make the button slightly brighter on hover */
        box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Add a subtle shadow on hover */
    }
/* Updated styles for Settings Grid Layout */
/* Updated styles for Settings Grid Layout */
 .settings-grid-container {
     display: grid;
     grid-template-columns: repeat(3, 1fr); /* Exactly 3 equal columns */
     gap: 1.5rem; /* Space between grid items */
     padding: 1rem; /* Add some padding around the grid */
     max-width: 900px; /* Limit the maximum width of the grid */
     margin: 0 auto; /* Center the grid */
     /* Add responsiveness: Below a certain width, allow fewer columns */
     @media (max-width: 900px) {
         grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /* Adjust min width as needed */
         max-width: none; /* Allow it to take more width on smaller screens */
     }
      @media (max-width: 550px) { /* Further adjust for very small screens */
          grid-template-columns: 1fr; /* Single column */
      }
 }

.settings-grid-item {
    background-color: var(--card-bg); /* Use variable */
    border-radius: var(--border-radius);
    padding: 1.5rem; /* Adjust padding as needed */
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    display: flex; /* Use flexbox for content within the item */
    flex-direction: column; /* Stack content vertically */
    /* Removed justify-content: space-between; to allow content to flow naturally */
    /* Removed aspect-ratio for more horizontal flexibility */
    box-sizing: border-box; /* Include padding in the size */
    text-align: center; /* This centers the text inside */
    height: 100%; /* Ensure items in the same row have equal height */
}

.settings-grid-item h2 {
     margin-top: 0;
     margin-bottom: 1rem;
     color: var(--accent); /* Use variable */
     font-size: 1.2rem;
     /* Removed margin-right: 60px; */
     text-align: center; /* Ensure the h2 content itself is centered */
 }

 .settings-grid-item h3 {
      color: var(--text-light); /* Use variable */
      margin-top: 0.8rem; /* Space above subheadings */
      margin-bottom: 0.5rem;
      font-size: 1rem; /* Adjust subheading size */
 }

    .settings-grid-item p {
        font-size: 0.9rem;
        color: var(--text-muted); /* Use variable */
        margin-bottom: 0.8rem;
        flex-grow: 1; /* Add this line to make the paragraph take up available space */
    }

   .settings-grid-item button {
       margin-top: 0.8rem; /* Add margin above buttons */
       width: 100%; /* Make buttons full width */
   }

   .settings-grid-item input[type="text"],
   .settings-grid-item select {
        width: 100%;
        margin-bottom: 0.8rem;
        box-sizing: border-box;
         padding: 0.5rem; /* Add padding */
         background-color: var(--bg-dark); /* Darker background using variable */
         color: var(--text-light); /* Light text using variable */
         border: 1px solid var(--sidebar-dark); /* Subtle border using variable */
         border-radius: 5px;
   }

    /* Specific adjustments for Theme Selector within grid item */
    .settings-grid-item .theme-selector {
        justify-content: center; /* Center theme options */
        flex-wrap: wrap;
        gap: 5px; /* Adjust gap for smaller icons */
        margin-top: 0.5rem;
        flex-grow: 1; /* Allow theme selector to take up space */
         align-items: center; /* Center vertically if space available */
    }

    .settings-grid-item .theme-option {
        width: 40px; /* Smaller size for theme options in grid */
        height: 40px;
         margin: 0; /* Remove margin defined elsewhere */
    }

     /* Style for the select dropdown arrow */
    .settings-grid-item select {
        -webkit-appearance: none; /* Remove default arrow */
        -moz-appearance: none;
        appearance: none;
        /* The fill color in the SVG is calculated based on --text-light */
        background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.362%22%20height%3D%22292.362%22%3E%3Cpath%20fill%3D%22%23${encodeURIComponent(getComputedStyle(document.documentElement).getPropertyValue('--text-light').trim().substring(1))}%22%20d%3D%22M287.9%20197.2c.9%201.3%201.1%202.9.8%204.3s-1.3%202.6-2.6%203.5l-124.5%20124.5c-1.8%201.8-4.3%202.9-7.4%202.9s-5.7-1.1-7.4-2.9l-124.7-124.7c-1.8-1.8-2.9-4.1-2.9-6.3s1.1-4.5%202.9-6.3l20.8-20.8c1.9-1.9%204.5-3%207.8-3%203.3%200%205.9%201.1%207.8%203l96.8%2096.7%2096.7-96.7c1.9-1.9%204.5-3%207.8-3%203.2%200%205.8%201.1%207.8%203l20.8%2020.8z%22%2F%3E%3C%2Fsvg%3E');
        background-repeat: no-repeat;
        background-position: right 0.7em top 50%, 0 0;
        background-size: 0.65em auto, 100%;
    }

    /* Style for individual setting reset buttons */
/* Style for individual setting reset buttons */
    .setting-reset-button {
        background-color: #666; /* Grey background - keep static or make variable */
        color: white;
        padding: 0.3rem 0.6rem; /* Smaller padding */
        font-size: 0.8rem;     /* Smaller font size */
        border-radius: 4px;
        border: none;
        cursor: pointer;
        transition: background-color 0.2s;
        /* Use margin-top: auto to push the button to the bottom in the flex column */
        margin-top: auto;
        /* Ensure it is a block element to take up its own line and center horizontally */
        display: block;
        /* Center horizontally within the flex item */
        margin-left: auto;
        margin-right: auto;
        /* Optional: set a specific width if not 100% */
        width: fit-content; /* Adjust width based on content */
    }

    .setting-reset-button:hover {
        background-color: #888; /* Lighter grey on hover - keep static or make variable */
    }

    /* Adjust grid item padding if needed to accommodate buttons */
    .settings-grid-item {
         position: relative; /* Needed for absolute/float positioning inside */
         padding-bottom: 3rem; /* Add more bottom padding if buttons overlap */
     }
    .settings-grid-item h2 {
         margin-top: 0;
         margin-bottom: 1rem;
         color: var(--accent); /* Use variable */
         font-size: 1.2rem; /* Adjust heading size */
         /* Removed margin-right: 60px; */
         text-align: center; /* Ensure the title text is centered */
     }


    /* --- Update Overlay Styles --- */
    .update-overlay {
        display: none; /* Hidden by default */
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8); /* Semi-transparent dark background */
        z-index: 200; /* Ensure it's above other elements like modals */
        justify-content: center;
        align-items: center;
        backdrop-filter: blur(5px); /* Optional: Add a blur effect */
    }
    
    .update-message-box {
        background-color: var(--card-bg);
        padding: 2rem;
        border-radius: var(--border-radius);
        text-align: center;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
        /* Keep the increased max-width to help with horizontal text flow */
        max-width: 350px; /* Or your preferred wider value */
        width: 90%;
        color: var(--text-light);
    }
    
    .update-message-box h2 {
        margin-top: 0;
        color: var(--accent);
        margin-bottom: 1rem;
    }
    
    .update-message-box button {
        margin-top: 0.5rem;
        padding: 0.5rem 1rem; /* Button size adjustments */
        font-size: 1rem;
         margin-right: 0 !important; /* Ensure no extra margin on buttons */
         margin-top: 0;
    }
    
    /* Optional: Style for disabled download button */
    .update-message-box button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
      
    .update-options-container {
        margin-top: 1.5rem;
        display: flex;
        flex-direction: column; /* Stack the options vertically */
        /* Increase the gap to add more vertical space between options */
        gap: 20px; /* Increased gap */
        align-items: center; /* Center items horizontally */
    }
    
    .update-option {
        display: flex;
        /* Change direction to stack items vertically */
        flex-direction: column;
        /* Center items horizontally within the column */
        align-items: center;
        gap: 5px; /* Reduce gap since items are now stacked */
        /* Remove flex-wrap as items are explicitly stacked */
        /* flex-wrap: wrap; */
        /* Ensure the whole option is centered or takes appropriate width */
        width: 100%; /* Allow the option container to take full width within its parent */
    }

    
    .update-option button {
        /* Keep button size adjustments */
        padding: 0.5rem 1rem;
        font-size: 1rem;
        margin: 0 !important; /* Remove all margins to control spacing with gap */
         width: auto; /* Ensure button doesn't stretch to full width */
    }
    
    .update-option p {
        margin: 0; /* Remove default paragraph margin */
        font-size: 0.9rem;
        color: var(--text-muted);
        /* Remove flex-grow as text is now below the button */
        /* flex-grow: 1; */
        /* Center the text itself */
        text-align: center;
         max-width: 100%; /* Ensure text doesn't overflow if very long */
         box-sizing: border-box; /* Include padding/border in width */
    }


  </style>
</head>
<body class="theme-default"> <div class="tooltip" id="tooltip"></div>

  <div class="modal" id="addGameModal">
    <div class="modal-content">
      <button class="modal-close" onclick="closeModal()">&times;</button>
      <h2>Add New Game</h2>
      <input type="text" id="gameName" placeholder="Game Name" required>
      <input type="text" id="gameUrl" placeholder="Game URL" required>
      <input type="text" id="gameIcon" placeholder="Icon URL (optional)">
      <div class="modal-buttons">
        <button onclick="closeModal()">Cancel</button>
        <button onclick="addGame()">Add Game</button>
      </div>
    </div>
  </div>
    
    <div class="update-overlay" id="updateOverlay">
        <div class="update-message-box">
            <h2 id="updateTitle">New Update Available!</h2>
            <p id="updateMessage">A new version (vX.Y.Z) is available.</p> <div class="update-options-container">
                <div class="update-option">
                    <button id="reloadSiteButton">Reload Site</button>
                    <p>if you are on the website</p>
                </div>
                <div class="update-option">
                     <button id="downloadOfflineButton">Download Offline Version</button>
                     <p>if you are on a local version</p>
                </div>
            </div>
    
             <button id="updateCloseButton" style="margin-top: 1.5rem; background-color: #555; color: white;">Dismiss</button>
        </div>
    </div>

  <div class="modal" id="changelogModal">
    <div class="modal-content" style="max-width: 900px; max-height: 80vh;">
      <button class="modal-close" onclick="closeChangelogModal()">&times;</button>
      <h2>Changelog</h2>
      <pre id="changelogContent" style="white-space: pre-wrap; font-family: inherit;"></pre>
    </div>
  </div>

  <div class="sidebar">
    <div class="icon active" data-page="Home" title="Home"><i class="fas fa-home"></i></div>
    <div class="icon" data-page="Library" title="Library"><i class="fas fa-book"></i></div>
    <div class="icon" data-page="Viewer" title="Viewer"><i class="fas fa-globe"></i></div>
    <div class="icon" data-page="Games" title="Games"><i class="fas fa-gamepad"></i></div>
    <div class="icon" data-page="Updater" title="Updater"><i class="fas fa-sync-alt"></i></div>

    <div class="bottom-icons">
      <div class="icon" data-page="Settings" title="Settings"><i class="fas fa-cog"></i></div>
      <div class="icon" data-page="About" title="About"><i class="fas fa-info-circle"></i></div>
    </div>
  </div>

  <div class="content">
    <h1 id="page-title" style="display: none;">UnderGr0und</h1>
    <div id="page-content" class="panel-container">
      </div>
  </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.fog.min.js"></script>

  <script>
    // DOM Elements
    const icons = document.querySelectorAll('.sidebar .icon');
    const pageTitle = document.getElementById('page-title');
    const pageContent = document.getElementById('page-content');
    const tooltip = document.getElementById('tooltip');
    const addGameModal = document.getElementById('addGameModal');
    const changelogModal = document.getElementById('changelogModal'); // Get changelog modal

    // App State
    let games = [];
    let library = [];
    let draggedItem = null;
    let draggedIndex = null;
    // Removed: let currentTheme = 'default'; // We will use currentThemeName instead
    let favoriteGames = [];
    let isSidebarOpen = false;
    let vantaEffect = null;
    let showingFavorites = false;
    
    // Define themes in an array
    const themes = [
      {
        name: 'default',
        previewClass: 'theme-default-preview', // Keep existing preview class for visual swatch
        variables: {
          '--bg-dark': '#1c1c1e',
          '--sidebar-dark': '#2c2c2e',
          '--text-light': '#fff',
          '--text-muted': '#aaa',
          '--card-bg': '#1a1a1a',
          '--accent': '#00ff84',
        }
      },
      {
          name: 'cyberpunk',
           previewClass: 'theme-cyberpunk-preview',
          variables: {
            '--bg-dark': '#0f0f1a',
            '--sidebar-dark': '#1a1a2e',
            '--text-light': '#e6e6ff',
            '--text-muted': '#b3b3ff',
            '--card-bg': '#1a1a2e',
            '--accent': '#ff00ff',
          }
        },
         {
          name: 'sunset', // <--- Sunset theme is now kept
          previewClass: 'theme-sunset-preview',
          variables: {
            '--bg-dark': '#2c1a1a',
            '--sidebar-dark': '#4a2c2c',
            '--text-light': '#fff0e0',
            '--text-muted': '#e0b0a0',
            '--card-bg': '#3a2222',
            '--accent': '#ff8844',
          }
        },
         {
           name: 'forest-night',
           previewClass: 'theme-forest-night-preview',
           variables: {
             '--bg-dark': '#0d1a0b',
             '--sidebar-dark': '#1a2e17',
             '--text-light': '#e0f2f1',
             '--text-muted': '#a7ffeb',
             '--card-bg': '#132611',
             '--accent': '#11661f',
           }
         },
         {
            name: 'midnight-sky',
            previewClass: 'theme-midnight-sky-preview',
            variables: {
                '--bg-dark': '#1a1c2e',
                '--sidebar-dark': '#2b2e4a',
                '--text-light': '#e0e0ff',
                '--text-muted': '#a0a0c0',
                '--card-bg': '#20233d',
                '--accent': '#7b68ee',
            }
         },
         // --- New Themes (Plum removed) ---
        {
           name: 'volcano',
           previewClass: 'theme-volcano-preview',
           variables: {
               '--bg-dark': '#3a0d0d',
               '--sidebar-dark': '#5f1c1c',
               '--text-light': '#fff0e0',
               '--text-muted': '#e0b0a0',
               '--card-bg': '#4a1414',
               '--accent': '#ff4500',
           }
        },
        {
           name: 'arctic',
           previewClass: 'theme-arctic-preview',
           variables: {
               '--bg-dark': '#0a1a1c',
               '--sidebar-dark': '#1c3a3d',
               '--text-light': '#e0ffff',
               '--text-muted': '#a0e0e0',
               '--card-bg': '#152a2c',
               '--accent': '#00ffff',
           }
        },
         {
            name: 'grayscale',
            previewClass: 'theme-grayscale-preview',
            variables: {
                '--bg-dark': '#1c1c1c',
                '--sidebar-dark': '#2c2c2c',
                '--text-light': '#ffffff',
                '--text-muted': '#cccccc',
                '--card-bg': '#202020',
                '--accent': '#808080',
            }
         },
         {
            name: 'sunny',
            previewClass: 'theme-sunny-preview',
            variables: {
                '--bg-dark': '#4a3a1a',
                '--sidebar-dark': '#6a4a1a',
                '--text-light': '#fffacd',
                '--text-muted': '#f0d8a0',
                '--card-bg': '#5a4a1a',
                '--accent': '#ffcc00',
            }
         },
        {
            name: 'marine', // <--- New Marine theme
            previewClass: 'theme-marine-preview',
            variables: {
                '--bg-dark': '#0f2a3a',      // Dark blue-green
                '--sidebar-dark': '#1a3c4a', // Darker blue-green
                '--text-light': '#e0f0ff',   // Pale blue
                '--text-muted': '#a0c0d0',   // Muted blue-gray
                '--card-bg': '#15303a',      // Dark blue-green for cards
                '--accent': '#00bfff',       // Deep sky blue
            }
         },
        {
            name: 'swamp',
            previewClass: 'theme-swamp-preview',
            variables: {
                '--bg-dark': '#2b2b1c',      // Dark greenish-brown
                '--sidebar-dark': '#3a3a2a', // Slightly lighter greenish-brown
                '--text-light': '#e0e6d8',   // Pale green-gray
                '--text-muted': '#a0b390',   // Muted green-brown
                '--card-bg': '#303020',      // Darker greenish-brown for cards
                '--accent': '#8a9a5b',       // Dull green
            }
         }
    ];

let currentThemeName = 'default'; // Store the name of the current theme

    // --- VANTA.JS HELPER ---
    // Function to convert CSS hex/rgb color to Vanta's number format
    function colorToVantaFormat(colorString) {
        if (!colorString) {
            console.warn("colorToVantaFormat received empty color string. Defaulting to black.");
            return 0x000000; // Default to black if color is missing
        }

        // Check if it's hex (e.g., #ff0000 or #f00)
        if (colorString.startsWith('#')) {
            let hex = colorString.substring(1);
            if (hex.length === 3) {
                hex = hex.split('').map(char => char + char).join('');
            }
            try {
                 return parseInt(`0x${hex}`);
            } catch (e) {
                 console.error(`Failed to parse hex color "${colorString}":`, e);
                 return 0x000000;
            }

        }

        // Check if it's rgb (e.g., rgb(255, 0, 0))
        const rgbMatch = colorString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (rgbMatch) {
            const r = parseInt(rgbMatch[1]);
            const g = parseInt(rgbMatch[2]);
            const b = parseInt(rgbMatch[3]);
            return (r << 16) + (g << 8) + b;
        }

        // Fallback for named colors or other formats (this is basic, might need improvement)
        try {
            // Use a temporary element to resolve named colors etc.
            const tempDiv = document.createElement('div');
            tempDiv.style.color = colorString;
            document.body.appendChild(tempDiv);
            const computedColor = getComputedStyle(tempDiv).color;
            document.body.removeChild(tempDiv);
            console.log(`Resolved named color "${colorString}" to "${computedColor}".`);
            return colorToVantaFormat(computedColor); // Recursively call with the resolved rgb/hex
        } catch (e) {
             console.warn(`Could not parse color: ${colorString}. Defaulting to black.`);
             return 0x000000;
        }
    }

    // --- INITIALIZATION ---
    window.addEventListener('DOMContentLoaded', async () => {
      console.log('DOMContentLoaded fired.');
      loadData(); // Load theme preference first
      console.log('Theme data loaded. Initial theme:', currentTheme);

      // Add a small delay before initializing Vanta
      setTimeout(() => {
          console.log('Attempting to initialize Vanta.js...');
          initializeVanta(); // Initialize Vanta with the loaded theme
          console.log('initializeVanta() called. Vanta effect:', vantaEffect);

          // Explicitly call setTheme with the current theme after initialization
          // This might help trigger the initial rendering/option update
          if (vantaEffect) {
              console.log('Calling setTheme with currentTheme after Vanta initialization.');
              setTheme(currentTheme);
          } else {
              console.warn('Vanta effect is null after initialization, cannot call setTheme to update options.');
          }


      }, 50); // 50ms delay

      setupEventListeners();
      console.log('Event listeners set up.');
      updateGamesPage(); // Now safe to call as it relies on DOM elements potentially defined in 'pages'
      setupDragAndDrop();
      console.log('Games page updated and drag/drop setup.');
      // checkVersion(); // Moved checkVersion call to the Home page content load
      switchPage('Home'); // Initial page load
      console.log('Switched to Home page.');
    });

    function initializeVanta() {
        console.log('Entering initializeVanta() function.');
        try {
            // Get initial baseColor based on the current theme's --bg-dark color
            const computedStyle = getComputedStyle(document.body);
            const themeBgDark = computedStyle.getPropertyValue('--bg-dark').trim();
            console.log('Computed --bg-dark for initial theme:', themeBgDark);
            const themeBaseColor = colorToVantaFormat(themeBgDark);
            console.log('Converted Vanta.js baseColor:', '0x' + themeBaseColor.toString(16)); // Log as hex

            if (vantaEffect) {
                console.log('Destroying existing Vanta effect.');
                vantaEffect.destroy(); // Clean up previous instance if exists
            }

            console.log('Creating new VANTA.FOG instance...');
            vantaEffect = VANTA.FOG({
              el: "body", // Target the body element
              mouseControls: true,
              touchControls: true,
              gyroControls: false,
              minHeight: 200.00,
              minWidth: 200.00,
              highlightColor: 0x0,    // Set highlightColor to static 0x0 (black)
              midtoneColor: 0x0,      // Set midtoneColor to static 0x0 (black)
              lowlightColor: 0x0,     // Set lowlightColor to static 0x0 (black)
              baseColor: themeBaseColor, // baseColor will change with the theme
              blurFactor: 0.56, // Set blurFactor to 0.56
              speed: 1.10,      // Set speed to 1.10
              zoom: 1.20        // Set zoom to 1.20
            });
             console.log('VANTA.FOG instance creation attempted.');

        } catch (error) {
            console.error("Error initializing Vanta.js:", error);
            vantaEffect = null; // Ensure vantaEffect is null if creation failed
        }
    }


function processLinkedText(text) {
        let processedText = text;

        const linkRegex = /;(\w+);/g;
        processedText = processedText.replace(linkRegex, (match, pageName) => {
            const formattedPageName = pageName.charAt(0).toUpperCase() + pageName.slice(1);
            return `<a href="#" onclick="switchPage('${escapeHtml(formattedPageName)}'); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">${escapeHtml(pageName)}</a>`;
        });

        const sizeRegex = /\[\[size:(.*?)\]\](.*?)\[\[\/size\]\]/g;
         processedText = processedText.replace(sizeRegex, '<span style="font-size: $1;">$2</span>');

        const boldRegex = /\*\*(.*?)\*\*/g;
        processedText = processedText.replace(boldRegex, '<strong>$1</strong>');

        const italicRegex = /\*(.*?)\*/g;
        processedText = processedText.replace(italicRegex, '<em>$1</em>');

        return processedText;
    }


function fetchNews() {
       const newsBox = document.getElementById('news-content');
       const gameOfTheDayContainer = document.getElementById('game-of-day-container');

       if (!newsBox || !gameOfTheDayContainer) {
         console.log("News or Game of the Day elements not found.");
         return;
       }

       newsBox.textContent = "Loading news...";
       gameOfTheDayContainer.innerHTML = ''; // Clear previous content
       console.log("Fetching news...");

       fetch('https://hostfilez.glitch.me/news.txt')
         .then(response => {
              if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
              console.log("News fetched successfully.");
              return response.text();
          })
         .then(text => {
           let rawNewsText = text;
           let gameOfTheDayName = null;

           const gameOfTheDayRegex = /\{([^}]+)\}/; // Matches {Game name} and captures Game name
           const match = rawNewsText.match(gameOfTheDayRegex);

           if (match && match[1]) {
             gameOfTheDayName = match[1].trim();
             console.log("Found Game of the Day name:", gameOfTheDayName);

             // Remove the {Game name} marker from the news text
             rawNewsText = rawNewsText.replace(gameOfTheDayRegex, '').trim();

             // Find the game in the games array
             const gameOfTheDay = games.find(game => game.name.toLowerCase() === gameOfTheDayName.toLowerCase());

             if (gameOfTheDay) {
               console.log("Found Game of the Day data:", gameOfTheDay.name);

               // Find the index of the game in the main games array (needed for favorite/proxy toggling)
               const gameIndex = games.findIndex(game => game.name.toLowerCase() === gameOfTheDayName.toLowerCase());

               // Generate HTML for the Game of the Day container
               gameOfTheDayContainer.innerHTML = `
                  <h3>Game of the Day</h3>
                  <div class="game-card" style="width: 100%; margin: 0;">
                     <img src="${escapeHtml(gameOfTheDay.icon)}" alt="${escapeHtml(gameOfTheDay.name)}"
                           onerror="this.src='https://via.placeholder.com/150?text=No+Image'"
                           onclick="loadGame('${escapeHtml(gameOfTheDay.name)}', '${escapeHtml(gameOfTheDay.url)}')">
                      <p onclick="loadGame('${escapeHtml(gameOfTheDay.name)}', '${escapeHtml(gameOfTheDay.url)}')">${escapeHtml(gameOfTheDay.name)}</p>
                       <div style="display: flex; flex-direction: column; gap: 5px; align-items: center; margin-top: 5px;">
                           <button class="favorite-button" onclick="event.stopPropagation(); toggleFavoriteGame(${gameIndex})">
                                <i class="fas ${isFavoriteGame(gameOfTheDay) ? 'fa-solid' : 'fa-regular'} fa-star" style="${isFavoriteGame(gameOfTheDay) ? 'color: var(--accent);' : ''}"></i>
                                <span>${isFavoriteGame(gameOfTheDay) ? 'Favorited' : 'Favorite'}</span>
                           </button>
                           ${gameOfTheDay.proxiedUrl && gameOfTheDay.proxiedUrl !== 'none' ? // Only show proxy toggle if proxy URL exists
                            `<button class="favorite-button" onclick="event.stopPropagation(); toggleProxied(${gameIndex})">
                              <i class="fas fa-shield-alt"></i>
                              <span>Proxy: ${gameOfTheDay.proxied ? 'On' : 'Off'}</span>
                            </button>`
                            : ''
                          }
                      </div>
                   </div>
               `;
               console.log("Generated Game of the Day game-card HTML.");

               // Note: Clicking Favorite or Proxy toggle on the Home page
               // will update the state in games array and localStorage,
               // but the button display on the Home page won't auto-update
               // unless you manually re-render the game-of-day-container
               // or refetch the news after a toggle. The functionality still works.

             } else {
                 console.log("Game of the Day not found in games list:", gameOfTheDayName);
                  gameOfTheDayContainer.innerHTML = `
                     <h3>Game of the Day</h3>
                     <p style="color: var(--text-muted);">Game "${escapeHtml(gameOfTheDayName)}" not found.</p>
                  `;
             }
           } else {
             console.log("No {Game name} found in news text.");
               gameOfTheDayContainer.innerHTML = `
                  <h3>Game of the Day</h3>
                  <p style="color: var(--text-muted);">No Game of the Day selected.</p>
               `;
           }

           // Process and display the remaining news text
           const processedNewsText = processLinkedText(rawNewsText);
           newsBox.innerHTML = processedNewsText;

         })
         .catch(err => {
           console.error("Failed to load news:", err);
           newsBox.textContent = "Failed to load news.";
           gameOfTheDayContainer.innerHTML = `
               <h3>Game of the Day</h3>
               <p style="color: var(--text-muted);">Failed to load Game of the Day.</p>
           `;
         });
     }


    function openChangelogModal() {
      const modal = document.getElementById("changelogModal");
      const content = document.getElementById("changelogContent");
      if (!modal || !content) return;
      modal.style.display = "flex";
      content.textContent = "Loading...";
      fetch('https://hostfilez.glitch.me/changelog.txt')
        .then(response => response.text())
        .then(text => {
          const processedText = processLinkedText(text);
          content.innerHTML = processedText;
        })
        .catch(err => {
          console.error("Failed to load changelog:", err);
          content.textContent = "Failed to load changelog.";
        });
    }

    function closeChangelogModal() {
      console.log('Closing changelog modal.');
      const modal = document.getElementById("changelogModal");
      if (modal) {
        modal.style.display = "none";
      }
    }


// --- About:Blank Startup Toggle ---
    function toggleAboutBlankStartup() {
        const toggle = document.getElementById('aboutBlankToggle');
        if (toggle) {
            const isEnabled = toggle.checked;
            localStorage.setItem('aboutBlankOnStartup', isEnabled);
            console.log('About:Blank on startup set to:', isEnabled);
            // Optional: Add user feedback like a small notification/alert
            // alert(`About:Blank on startup ${isEnabled ? 'enabled' : 'disabled'}.`);
        } else {
            console.error("About:Blank toggle element not found.");
        }
    }

    // --- Modified loadData function ---
function loadData() {
        console.log('Loading data from localStorage...');
        // Load theme name first
        const savedThemeName = localStorage.getItem('theme') || 'default'; // Default to 'default'
        currentThemeName = savedThemeName; // Set the state variable

        // Apply the theme using the new setTheme function
        // Call setTheme here to apply the variables from the themes array
        setTheme(currentThemeName);

        console.log('Theme data loaded. Initial theme:', currentThemeName);

        // --- Check and apply About:Blank on Startup preference ---
        const aboutBlankPref = localStorage.getItem('aboutBlankOnStartup');
        // Default to true (enabled) if not explicitly set to false
        const shouldOpenInAboutBlank = aboutBlankPref !== 'false';
        if (shouldOpenInAboutBlank) {
             // You might want to gate this behind a check to ensure it only happens
             // when the page is *initially* loaded, not on subsequent calls to loadData.
             // A simple flag or checking the window location could work.
             // For simplicity here, we'll assume it's checked elsewhere or desired on every loadData call.
             // openAppInAboutBlank(); // Consider the implications of calling this here.
             console.log('About:Blank on startup is enabled (logic placeholder).');
        } else {
             console.log('About:Blank on startup is disabled.');
        }
         // Ensure the toggle reflects the saved state when the Settings page loads
         const toggle = document.getElementById('aboutBlankToggle');
         if (toggle) {
             toggle.checked = shouldOpenInAboutBlank;
         }
        // --- End About:Blank Check ---


        const defaultGames = [
             { name: "Agar.io", url: "https://fluxaga.glitch.me", icon: "https://static.wikia.nocookie.net/yogscast/images/1/19/Agar.io_appstore_logo.png", proxiedUrl: "https://flux.englishd.workers.dev/", proxied: false },
             { name: "Slither.io", url: "https://slither.io", icon: "https://pbs.twimg.com/profile_images/1854966120509267968/gUTLTAMd_400x400.jpg", proxiedUrl: "place", proxied: false }, // Placeholder for proxiedUrl
             { name: "n-gon", url: "https://landgreen.github.io/n-gon/", icon: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSIiXBQof9-UTot6CA0A-X9Ntyp0pNALernmg&s", proxiedUrl: "https://skibidi.global.fastly.net/uv/service/hvtrs8%2F-lcnfgpegn%2Cgktju%60.ko-n%2Fgmn-", proxied: false },
             { name: "FreeRiderHD", url: "https://freeriderhd.com", icon: "https://cdn.freeriderhd.com/free_rider_hd/sprites/youtube_poster_art.png", proxiedUrl: "https://skibidi.global.fastly.net/uv/service/hvtrs8%2F-wuw%2Cfpegrkdgrjd%2Ccmm-", proxied: false },
             { name: "Shell Shockers", url: "https://shellshock.io/", icon: "https://rocketgames.imgix.net/uploads/games/s/shell-shockers/shell-shockers.jpg", proxiedUrl: "none", proxied: false },
             { name: "Happy Wheels", url: "https://totaljerkface.com/happy_wheels.tjf", icon: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR8ZZNe14xfg_CvlBFQRnl2Boj4GIEuiyVqYw&s", proxiedUrl: "https://nyx-2b7o.onrender.com/active/go/hvtrs8%2F-tmtclhepkdaae%2Ccmm-hcpry%5Dwjeglq.vjd", proxied: false }
        ];

        const savedGames = localStorage.getItem('games');
        const userGames = savedGames ? JSON.parse(savedGames) : [];

        games = [...defaultGames];
        const gameNames = new Set(defaultGames.map(g => g.name));
        userGames.forEach(g => {
            if (!gameNames.has(g.name)) {
                games.push(g);
                gameNames.add(g.name);
            }
        });
        console.log('Games loaded:', games.length);

        const savedLibrary = localStorage.getItem('library');
        library = savedLibrary ? JSON.parse(savedLibrary) : [];
        console.log('Library loaded:', library.length);


        const savedFavoriteGames = localStorage.getItem('favoriteGames');
        favoriteGames = savedFavoriteGames ? JSON.parse(savedFavoriteGames) : [];
        console.log('Favorite games loaded:', favoriteGames.length);

        // --- Load App Appearance Settings ---
        const savedAppSettings = localStorage.getItem('appSettings');
        if (savedAppSettings) {
            const appSettings = JSON.parse(savedAppSettings);
            applyAppSettings(appSettings); // applyAppSettings updates the UI inputs as well
            console.log('Loaded and applied saved app settings.');
        } else {
            // If no saved settings, apply defaults and update UI inputs to show defaults
            applyAppSettings({
                tabTitle: 'Underground',
                faviconUrl: ''
            });
            console.log('No saved app settings found, applying defaults.');
        }

        console.log('Theme selector UI update logic is handled by setTheme.');

         console.log('Data loading complete.');
    }

    function applyAppSettings(settings) {
    console.log('Applying app settings:', settings);
    // Apply Tab Title
    if (settings.tabTitle !== undefined) { // Check if setting exists
        document.title = settings.tabTitle;
        console.log('Applied app tab title:', settings.tabTitle);
    }

    // Apply Favicon
    let link = document.querySelector("link[rel~='icon']");
    if (settings.faviconUrl) { // Check if a URL is provided
        if (!link) {
            link = document.createElement('link');
            link.rel = 'icon';
            document.getElementsByTagName('head')[0].appendChild(link);
             console.log('Created favicon link element.');
        }
        link.href = settings.faviconUrl;
        console.log('Applied app favicon URL:', settings.faviconUrl);
    } else {
         // If no favicon URL is provided, remove the link element to use browser default
        if (link) {
             link.remove(); // Remove the custom favicon link
             console.log('Removed custom favicon, using browser default.');
        }
    }

    // Update the UI elements on the Settings page if they exist
    const appTabTitleInput = document.getElementById('appTabTitleInput');
    const appFaviconUrlInput = document.getElementById('appFaviconUrlInput');

    if (appTabTitleInput && settings.tabTitle !== undefined) {
         appTabTitleInput.value = settings.tabTitle;
    }
     if (appFaviconUrlInput && settings.faviconUrl !== undefined) {
        appFaviconUrlInput.value = settings.faviconUrl;
     }
     console.log('Updated app settings page UI elements.');
}

    function saveAppSettings() {
    console.log('Saving app settings...');
    const appTabTitleInput = document.getElementById('appTabTitleInput');
    const appFaviconUrlInput = document.getElementById('appFaviconUrlInput');

    if (!appTabTitleInput || !appFaviconUrlInput) {
        console.error("App settings input elements not found, cannot save.");
        alert("Error: App Settings page elements not found.");
        return;
    }

    const appSettingsToSave = {
        tabTitle: appTabTitleInput.value.trim(),
        faviconUrl: appFaviconUrlInput.value.trim()
    };

    localStorage.setItem('appSettings', JSON.stringify(appSettingsToSave)); // Use 'appSettings' key
    console.log('App settings saved to localStorage:', appSettingsToSave);

    // Apply the newly saved settings immediately
    applyAppSettings(appSettingsToSave);

    alert('App Settings saved!');
}

function openAppInAboutBlank() {
        console.log('Attempting to open app in about:blank window by getting current document HTML and writing, setting opener to null.');
        // Get the full HTML content of the current page
        const htmlContent = document.documentElement.outerHTML;
        const currentAppUrl = window.location.href; // Still useful context, though not fetched

        const newWindow = window.open('about:blank', '_blank');

        if (newWindow) {
            console.log('Opened new about:blank window.');

            // Set opener to null immediately to try and break the link
            try {
                newWindow.opener = null;
                console.log('Set new window opener to null.');
            } catch (e) {
                console.warn('Failed to set new window opener to null:', e);
            }


            // Use setTimeout to allow the window document to be ready for writing
            setTimeout(() => {
                try {
                    // Write the obtained HTML content into the new window's document
                    newWindow.document.open();
                    newWindow.document.write(htmlContent);
                    newWindow.document.close();

                    console.log('Successfully wrote current document HTML to about:blank window.');

                    // Optional: You might want to set the new window's history or URL to the original URL
                    // This can sometimes help with relative paths but might re-introduce detection issues
                    try {
                         // Setting history.pushState is cleaner than changing location.href directly if you want to spoof the URL
                         newWindow.history.pushState({}, '', currentAppUrl);
                         console.log('Attempted to set new window history state URL.');
                    } catch (e) {
                         console.warn('Failed to set new window history state URL:', e);
                    }


                } catch (e) {
                    console.error('Failed to write HTML content to about:blank window:', e);
                     // This alert indicates that writing to the document itself failed
                     alert("Could not write app content to about:blank window.");
                }
            }, 50); // Small delay

        } else {
            alert('Could not open a new window. Please check your browser popup blocker.');
            console.warn('Failed to open new window for about:blank.');
        }
    }

    function setupEventListeners() {
      icons.forEach(icon => {
        icon.addEventListener('click', handleIconClick);
        icon.addEventListener('mousemove', handleTooltipShow);
        icon.addEventListener('mouseleave', handleTooltipHide);
      });

      addGameModal.addEventListener('click', (e) => {
        if (e.target === addGameModal) closeModal();
      });

      // Use existing changelogModal variable
      changelogModal.addEventListener('click', (e) => {
          if (e.target === changelogModal) closeChangelogModal();
      });


      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if (addGameModal.style.display === 'flex') closeModal();
            if (changelogModal.style.display === 'flex') closeChangelogModal();
        }
      });

      // Sidebar hover - simplified
       const sidebar = document.querySelector('.sidebar');
       document.addEventListener('mousemove', (e) => {
           if (e.clientX < 10 && !sidebar.classList.contains('open')) {
               sidebar.classList.add('open');
           } else if (e.clientX > 70 && sidebar.classList.contains('open')) { // Give more leeway
               sidebar.classList.remove('open');
           }
       });
       // Ensure sidebar closes if mouse leaves window from the left
       document.documentElement.addEventListener('mouseleave', (e) => {
          if (sidebar.classList.contains('open')) {
            sidebar.classList.remove('open');
          }
       });
      console.log('Core event listeners set up.');

    }

    function handleReloadSiteClick() {
            console.log("Reload Site button clicked. Reloading page.");
            location.reload(); // Reload the current page
        }
      
    function handleDownloadOfflineClick() {
        if (updateDownloadUrl) {
            console.log("Download Offline button clicked. Downloading from:", updateDownloadUrl);
            // Create a temporary anchor element
            const link = document.createElement('a');
            link.href = updateDownloadUrl;
            // Set the download attribute with an optional filename
            link.setAttribute('download', 'Underground_Update.html'); // You can change the filename
            // Append to the body, trigger click, and remove
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            // Optionally close the update overlay after initiating download
            // document.getElementById("updateOverlay").style.display = 'none';

        } else {
            console.warn("Download Offline button clicked, but no download URL is available.");
            alert("Download link not found. Please try again or reload.");
        }
    }

    function hideUpdateOverlay() {
        const updateOverlay = document.getElementById("updateOverlay");
         if (updateOverlay) {
             updateOverlay.style.display = 'none';
             // Optionally reset the overlay content back to its initial state
             // (Less critical with the single overlay structure, but good practice)
             // document.getElementById("updateTitle").textContent = "New Update Available!";
             // document.getElementById("updateMessage").textContent = "A new version (vX.Y.Z) is available.";
             // const downloadButton = document.getElementById("downloadOfflineButton");
             // if (downloadButton) {
             //     downloadButton.disabled = false; // Reset disabled state
             //     downloadButton.title = ""; // Clear title
             // }
             updateDownloadUrl = null; // Clear the stored URL
             console.log("Update overlay hidden.");
         }
    }

let updateDownloadUrl = null; // Variable to store the fetched download URL

    async function handleUpdateNowClick() {
        const updateInitialButtonDiv = document.getElementById("updateInitialButton");
        const updateOptionsDiv = document.getElementById("updateOptions");
        const updateNowButton = document.getElementById("updateNowButton");
        const updateTitle = document.getElementById("updateTitle");
        const updateMessage = document.getElementById("updateMessage");


        if (!updateInitialButtonDiv || !updateOptionsDiv || !updateNowButton || !updateTitle || !updateMessage) {
             console.error("Update overlay elements not found for handling click.");
             return;
        }

        updateNowButton.textContent = "Fetching link...";
        updateNowButton.disabled = true;

        const versionURL = "https://hostfilez.glitch.me/version.txt";
        console.log("Fetching update link from:", versionURL);

        try {
            const versionResponse = await fetch(versionURL, { cache: "no-store" });
            if (!versionResponse.ok) throw new Error(`HTTP error! status: ${versionResponse.status}`);
            const latestVersionText = (await versionResponse.text()).trim();

            // Use regex to find the URL within parentheses ()
            const urlMatch = latestVersionText.match(/\((.*?)\)/);

            if (urlMatch && urlMatch[1]) {
                updateDownloadUrl = urlMatch[1].trim(); // Store the fetched URL
                console.log("Found update download URL:", updateDownloadUrl);

                // Hide the initial button and show the options
                updateInitialButtonDiv.style.display = 'none';
                updateOptionsDiv.style.display = 'block';
                updateTitle.textContent = "Update Options";
                updateMessage.textContent = "Choose how to update:";


            } else {
                alert("Update link not found in version file. Cannot provide download option.");
                console.warn("No URL found in parentheses in version file.");
                 // Optionally revert the button or provide only reload option
                 updateNowButton.textContent = "Update Now"; // Reset button text
                 updateNowButton.disabled = false;
                 // Or show only reload: updateInitialButtonDiv.style.display = 'none'; updateOptionsDiv.innerHTML = '<p style="margin-bottom: 1rem;">Cannot find download link.</p><button id="reloadSiteButton">Reload Site</button>'; setupReloadSiteListener();
            }

        } catch (err) {
            alert("Failed to fetch update link.");
            console.error("Error fetching update link:", err);
            updateNowButton.textContent = "Update Now"; // Reset button text
            updateNowButton.disabled = false;
            // Optionally hide the overlay or show error state
             updateTitle.textContent = "Update Error";
             updateMessage.textContent = "Could not fetch update details.";
             updateInitialButtonDiv.style.display = 'none'; // Hide the button div
             updateOptionsDiv.style.display = 'none'; // Hide the options div
        }
    }

// Variable to store the fetched download URL

    async function checkVersion() {
       console.log("Checking for latest version (triggered by interval or Home page switch)...");

       // Define the installed version here
       const installedVersion = "v1.0.0"; // <-- Set your installed version here

       const versionURL = "https://hostfilez.glitch.me/version.txt";
       let latestVersion = null;
       let fetchedDownloadUrl = null;
       let checkError = false;

       // --- Fetch Version and Extract Data ---
       try {
         const versionResponse = await fetch(versionURL, { cache: "no-store" }); // Avoid cache
         if (!versionResponse.ok) throw new Error(`HTTP error! status: ${versionResponse.status}`);
         const latestVersionText = (await versionResponse.text()).trim();

         // Extract just the version string (assuming it's the first part before any '(' or whitespace)
         const latestVersionMatch = latestVersionText.match(/^([^(\s]+)/);
         latestVersion = latestVersionMatch ? latestVersionMatch[1] : latestVersionText;

         // Extract the URL within parentheses
         const urlMatch = latestVersionText.match(/\((.*?)\)/);
         fetchedDownloadUrl = urlMatch && urlMatch[1] ? urlMatch[1].trim() : null;

         console.log("Fetched latest version text:", latestVersionText);
         console.log("Extracted latest version:", latestVersion);
         console.log("Extracted download URL:", fetchedDownloadUrl);

         updateDownloadUrl = fetchedDownloadUrl; // Store in the global variable

       } catch (err) {
         console.error("Failed to fetch or parse version:", err);
         checkError = true;
         latestVersion = "Error"; // Indicate error in UI if elements exist
         updateDownloadUrl = null; // Clear URL on error
       }

       // --- Update Home Page Elements (Only if they exist) ---
       // Do this AFTER fetching the version to minimize impact on fetch
       const homeVersionEl = document.getElementById("home-installed-version");
       const latestVersionEl = document.getElementById("home-latest-version");

       if (homeVersionEl) {
           homeVersionEl.textContent = installedVersion;
       }
       if (latestVersionEl) {
           latestVersionEl.textContent = latestVersion; // Will show version or "Error"
       }


       // --- Display/Hide Update Overlay (Independent of Home Page) ---
       // Get the update overlay elements
       const updateOverlay = document.getElementById("updateOverlay");
       const updateMessageEl = document.getElementById("updateMessage");
       const updateTitleEl = document.getElementById("updateTitle");
       const downloadButton = document.getElementById('downloadOfflineButton');

       // Check if overlay elements were successfully found before trying to manipulate them
       const canDisplayOverlay = updateOverlay && updateMessageEl && updateTitleEl && downloadButton;

       if (!canDisplayOverlay) {
            console.warn("Update overlay elements not found. Cannot display update notification.");
            // We can stop here if the overlay itself can't be shown
            return;
       }

       // Now that we know overlay elements exist, proceed with display logic
       if (latestVersion && latestVersion !== "Error" && latestVersion !== installedVersion) {
            console.log("New update available detected:", latestVersion);
            updateOverlay.style.display = 'flex'; // Show the update overlay
            updateTitleEl.textContent = "New Update Available!";
            updateMessageEl.textContent = `A new version (${latestVersion}) is available.`;

            // Enable or disable download button based on whether a URL was found
            downloadButton.disabled = !updateDownloadUrl;
            if (!updateDownloadUrl) {
                downloadButton.title = "Download link not found in version file.";
            } else {
                downloadButton.title = "";
            }

       } else {
           console.log("App is up to date or check failed, ensuring overlay is hidden.");
           updateOverlay.style.display = 'none'; // Ensure overlay is hidden
       }

       // If there was a fetch/parse error, the overlay will be hidden,
       // and the Home page status will show "Error".
       if (checkError) {
            console.log("Update check finished with errors.");
       } else if (latestVersion === installedVersion) {
            console.log("Update check finished: App is up to date.");
       } else if (latestVersion !== installedVersion && latestVersion !== "Error") {
            console.log("Update check finished: Update available.");
       }
     }

    function saveGames() {
      localStorage.setItem('games', JSON.stringify(games));
       console.log('Games data saved.');
    }

    function generateGamesHTML() {
       console.log('Generating Games HTML. Showing favorites:', isShowingFavoriteGames());
       const gamesToDisplay = isShowingFavoriteGames() ?
         games.filter(game => favoriteGames.some(fav => fav.name === game.name)) :
         games;

       // Generate the cards first
       const gameCardsHTML = gamesToDisplay.map((game, index) => {
         // Find original index to use for actions (like remove/favorite/proxy)
         const originalIndex = games.findIndex(g => g.name === game.name);
         // Ensure the index is valid before generating the card
         if (originalIndex === -1) return ''; // Skip if game not found in main list

         return `
           <div class="game-card" draggable="true" data-index="${originalIndex}">
             <div class="remove-icon" onclick="removeGame(event, ${originalIndex})" title="Remove Game">
               <i class="fas fa-times"></i>
             </div>
             <img src="${escapeHtml(game.icon)}" alt="${escapeHtml(game.name)}"
                  onerror="this.src='https://via.placeholder.com/150?text=No+Image'"
                  onclick="loadGame('${escapeHtml(game.name)}', '${escapeHtml(game.url)}')">
             <p onclick="loadGame('${escapeHtml(game.name)}', '${escapeHtml(game.url)}')">${escapeHtml(game.name)}</p>
             <div style="display: flex; flex-direction: column; gap: 5px; align-items: center; margin-top: 5px;">
               <button class="favorite-button" onclick="event.stopPropagation(); toggleFavoriteGame(${originalIndex})">
                 <i class="fas ${isFavoriteGame(game) ? 'fa-solid' : 'fa-regular'} fa-star" style="${isFavoriteGame(game) ? 'color: var(--accent);' : ''}"></i>
                 <span>${isFavoriteGame(game) ? 'Favorited' : 'Favorite'}</span>
               </button>
               ${game.proxiedUrl && game.proxiedUrl !== 'none' ? // Only show proxy toggle if proxy URL exists
                 `<button class="favorite-button" onclick="event.stopPropagation(); toggleProxied(${originalIndex})">
                   <i class="fas fa-shield-alt"></i>
                   <span>Proxy: ${game.proxied ? 'On' : 'Off'}</span>
                 </button>`
                 : ''
               }
             </div>
           </div>`;
         }).join('');


       // Return the full container HTML
       return `
         <input type="text" id="gameSearch" placeholder="Search Games..." oninput="filterGames()" style="width: 90%; max-width: 400px; margin: 0 auto 1.5rem auto; display: block;">
         <div class="games-header">
           <div class="action-card" onclick="showAddGameModal()">
             <i class="fas fa-plus"></i>
             <p>Add Game</p>
           </div>
           <div class="action-card" onclick="toggleFavoriteGamesView()">
             <i class="fas fa-star" style="${isShowingFavoriteGames() ? 'color: var(--accent);' : ''}"></i>
             <p>${isShowingFavoriteGames() ? 'All Games' : 'Favorites'}</p>
           </div>
         </div>
         <div class="games-container" id="gamesContainerInner">
             ${gameCardsHTML || '<p class="no-games-message" style="color: var(--text-muted); width: 100%; text-align: center;">No games found.</p>'}
         </div>`;
     }


    function toggleProxied(index) {
      console.log('Toggling proxy for game index:', index);
      if (games[index] && games[index].proxiedUrl && games[index].proxiedUrl !== 'none') {
         games[index].proxied = !games[index].proxied;
         saveGames();
         console.log('Proxy toggled.');
    
         // Update UI immediately for the specific card
          // Check if the clicked button is within the Game of the Day container
         const gameOfTheDayContainer = document.getElementById('game-of-day-container');
         let button = null;
    
         if (gameOfTheDayContainer && gameOfTheDayContainer.contains(event.target)) {
             // If the clicked element is inside the Game of the Day container,
             // find the proxy button relative to the container.
             // This assumes there's only one proxy button within the game-of-day-container's .game-card
             button = gameOfTheDayContainer.querySelector('.favorite-button i.fa-shield-alt').closest('button'); // Find button by icon
             console.log('Updating proxy button in Game of the Day container.');
    
         } else {
             // Otherwise, assume it's a button on the main Games page
              button = document.querySelector(`.game-card[data-index="${index}"] .favorite-button i.fa-shield-alt`).closest('button'); // Find button by icon
              console.log('Updating proxy button on Games page.');
         }
    
    
         if (button) {
           const span = button.querySelector('span');
           if (span) {
             span.textContent = `Proxy: ${games[index].proxied ? 'On' : 'Off'}`;
              console.log('Proxy button text updated.');
           }
         } else {
            console.warn('Proxy button not found for index:', index);
         }
    
         // If currently showing all games or favorites on Games page, re-render (optional but good for consistency)
         // updateGamesPage(); // Decided not to re-render the whole games page on proxy toggle unless necessary
      } else {
         alert("This game does not have a proxy URL configured.");
         console.warn('Attempted to toggle proxy for game without proxiedUrl.');
      }
    }

    function escapeHtml(unsafe) {
        if (typeof unsafe !== 'string') return '';
        return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    function loadViewerFromLibrary(url = '', customTitle = 'Viewer', displayUrl = url, updateRecents = true) {
      console.log('Loading viewer with URL:', url, 'Custom title:', customTitle);
      // Allow launching with no URL to show the input box immediately
      // if (!url) return; // Removed this check

      // Basic URL validation (only if a URL is provided)
      if (url && !url.startsWith('http://') && !url.startsWith('https://') && !url.startsWith('about:')) {
          url = 'https://' + url; // Attempt to prepend https
          displayUrl = url; // Update display URL as well
          console.log('Prepended https to URL:', url);
      }
       // If no URL is provided initially, the iframe src will be empty or about:blank

      try {
        if (url && !url.startsWith('about:')) { // Only validate if it's not about:blank
           new URL(url); // Validate if it's a proper URL now
        }
      } catch (e) {
        // If still invalid, try searching it
        console.warn("Invalid URL, attempting search:", url, e);
        url = `https://www.google.com/search?q=${encodeURIComponent(url)}`;
        displayUrl = url;
        customTitle = `Search Results for "${customTitle}"`;
        // Don't add search results to recents/library typically
        updateRecents = false;
      }

      // Hide sidebar and main content container for iframe view
       document.querySelector('.sidebar').style.display = 'none';
       pageContent.style.display = 'none';
       pageTitle.style.display = 'none'; // Hide main title

      // Create or get iframe container
      let iframeContainer = document.getElementById('iframe-viewer-container');
      if (!iframeContainer) {
         iframeContainer = document.createElement('div');
         iframeContainer.id = 'iframe-viewer-container';
         iframeContainer.className = 'iframe-container'; // Use existing class for styling
         document.body.appendChild(iframeContainer); // Append directly to body
         console.log('Created iframe container.');
      }

      iframeContainer.style.display = 'flex'; // Ensure it's visible
      iframeContainer.innerHTML = `
        <iframe src="${escapeHtml(url)}" frameborder="0" allowfullscreen></iframe>
        <div class="bottom-controls" id="iframe-bottom-controls">
          <button onclick="goBackToAppView()" title="Back to App"><i class="fas fa-arrow-left"></i></button>
          <input type="text" id="urlSearch" placeholder="Enter URL or Search" value="${escapeHtml(displayUrl)}" onkeydown="if(event.key==='Enter') goToUrl()">
          <button class="go-button" onclick="goToUrl()" title="Go"><i class="fas fa-check"></i></button>
          <button class="fullscreen-button" onclick="openFullscreen('${escapeHtml(url)}')" title="Open Fullscreen"><i class="fas fa-expand"></i></button>
          ${updateRecents ? `<button onclick="addToLibraryFromViewer('${escapeHtml(url)}')" title="Add to Library"><i class="fas fa-bookmark"></i></button>` : ''}
        </div>`;

      console.log('Set iframe source to:', url);

      if (updateRecents && url && url !== 'about:blank') {
         updateRecentlyViewed(url); // Only update recents if a valid URL was loaded
         console.log('Updated recently viewed.');
      }
    }

    function goBackToAppView() {
        console.log('Going back to app view.');
        // Hide iframe container
        const iframeContainer = document.getElementById('iframe-viewer-container');
        if (iframeContainer) {
            iframeContainer.style.display = 'none';
            iframeContainer.innerHTML = ''; // Clear content
            console.log('Hid and cleared iframe container.');
        }

        // Show sidebar and content again
        document.querySelector('.sidebar').style.display = 'flex'; // Or original display value
        pageContent.style.display = 'flex'; // Or original display value
        console.log('Showed sidebar and content.');


        // Restore the page title display based on the current page
        const currentPageKey = localStorage.getItem('lastActivePage') || 'Home';
         if (currentPageKey !== 'Home') {
              pageTitle.style.display = 'block';
              pageTitle.textContent = localStorage.getItem('lastActivePageTitle') || currentPageKey;
              console.log('Restored page title:', pageTitle.textContent);
         } else {
              pageTitle.style.display = 'none'; // Ensure title is hidden on Home
               console.log('Hid page title on Home page.');
         }


        // Optionally switch back to the last active page
        // switchPage(localStorage.getItem('lastActivePage') || 'Home'); // Decided against automatic page switch for simplicity
    }


    // This function is now less relevant as Viewer launches overlay directly
    // Leaving it in case it's called from other places, but updated to use the overlay logic
    function loadViewer() {
        console.log('loadViewer() called.');
        const urlInput = document.getElementById('homeSearchInput'); // Get input from Home/Viewer page
        const url = urlInput ? urlInput.value.trim() : ''; // Get value, default to empty
        console.log('URL from home search input:', url);

        loadViewerFromLibrary(url, url, url); // Load the URL in the overlay
    }

    function updateRecentlyViewed(url) {
      console.log('Updating recently viewed with URL:', url);
      let recentlyViewed = JSON.parse(localStorage.getItem('recentlyViewed')) || [];
      // Remove existing entry if present to move it to the top
      recentlyViewed = recentlyViewed.filter(item => item !== url);
      recentlyViewed.unshift(url); // Add to the beginning
      localStorage.setItem('recentlyViewed', JSON.stringify(recentlyViewed.slice(0, 10))); // Keep latest 10
       console.log('Recently viewed updated:', recentlyViewed.slice(0, 10));
       // Don't update library page here, it happens when Library page is switched to
    }

    function goToUrl() {
      console.log('goToUrl() called.');
      const urlInput = document.getElementById('urlSearch'); // In the iframe controls
      const url = urlInput ? urlInput.value.trim() : ''; // Get value, default to empty
      const iframe = document.querySelector('#iframe-viewer-container iframe');

      if (url) {
        let finalUrl = url;
         // Simple validation and prepend https if missing
         if (!finalUrl.startsWith('http://') && !finalUrl.startsWith('https://') && !finalUrl.startsWith('about:')) {
             finalUrl = 'https://' + finalUrl;
             console.log('Prepended https to input URL:', finalUrl);
         }

        try {
            if (!finalUrl.startsWith('about:')) {
                new URL(finalUrl); // Validate
            }
             // If valid or about:blank, set the iframe src
            if (iframe) {
               iframe.src = escapeHtml(finalUrl);
               updateRecentlyViewed(finalUrl); // Update recents for valid URLs
                // Update the input box to show the cleaned URL
               urlInput.value = escapeHtml(finalUrl);
               console.log('Navigated iframe to:', finalUrl);
            }
        } catch (e) {
             // If still invalid, attempt search
             console.warn("Invalid URL, attempting search:", finalUrl, e);
             const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(finalUrl)}`;
             if (iframe) {
                 iframe.src = escapeHtml(searchUrl);
                 // Don't add search results to recents
                 // Update input box to show the search query
                 urlInput.value = `Search: ${escapeHtml(finalUrl)}`;
                 console.log('Navigated iframe to search results for:', finalUrl);
             }
        }


      } else {
        // If input is empty, load about:blank
         if (iframe) {
             iframe.src = 'about:blank';
              // Clear input box value when blank
             urlInput.value = '';
             console.log('Navigated iframe to about:blank.');
         }
      }
    }

    function openFullscreen(url) {
        console.log('Attempting fullscreen for URL:', url);
        const iframe = document.querySelector('#iframe-viewer-container iframe');
        if (iframe && iframe.requestFullscreen) {
            iframe.requestFullscreen().catch(err => {
                console.error("Fullscreen failed:", err);
                // Fallback: open in new tab if fullscreen API fails
                if (iframe.src && iframe.src !== 'about:blank') {
                    window.open(iframe.src, '_blank');
                     console.log('Fullscreen failed, opening in new tab as fallback.');
                }
            });
        } else {
             // Fallback for browsers not supporting requestFullscreen on iframe directly
             if (iframe && iframe.src && iframe.src !== 'about:blank') {
                 window.open(iframe.src, '_blank');
                 console.log('Browser does not support iframe fullscreen, opening in new tab.');
             } else {
                 console.warn('Cannot open fullscreen: iframe or iframe source is not available.');
             }
        }
    }

    function showAddGameModal() {
      console.log('Showing add game modal.');
      addGameModal.style.display = 'flex';
      document.getElementById('gameName').focus();
    }

    function closeModal() {
      console.log('Closing add game modal.');
      addGameModal.style.display = 'none';
       // Clear fields
       document.getElementById('gameName').value = '';
       document.getElementById('gameUrl').value = '';
       document.getElementById('gameIcon').value = '';
    }

    function addGame() {
      console.log('Attempting to add game.');
      const nameInput = document.getElementById('gameName');
      const urlInput = document.getElementById('gameUrl');
      const iconInput = document.getElementById('gameIcon');

      const name = nameInput.value.trim();
      const url = urlInput.value.trim();
      const icon = iconInput.value.trim();

      if (!name || !url) {
        alert('Please provide both a name and URL for the game');
        console.warn('Add game failed: Name or URL missing.');
        return;
      }

      // Simple URL validation
      if (!url.includes('.') || url.includes(' ')) {
         alert('Please enter a valid URL.');
          console.warn('Add game failed: Invalid URL format.');
         return;
      }
      let finalUrl = url;
       if (!url.startsWith('http://') && !url.startsWith('https://')) {
         finalUrl = 'https://' + url;
         console.log('Prepended https to game URL:', finalUrl);
       }


      games.push({
        name: name,
        url: finalUrl,
        icon: icon || 'https://via.placeholder.com/150?text=No+Image',
        proxied: false, // Default to not proxied
        proxiedUrl: 'none' // Default proxy URL
      });

      saveGames(); // Save immediately
      updateGamesPage(); // Refresh the view
      closeModal();
      console.log('Game added successfully:', name);
    }

    function removeGame(event, index) {
      event.stopPropagation(); // Prevent card click
      console.log('Attempting to remove game index:', index);
      if (index >= 0 && index < games.length) {
         const gameName = games[index].name;
         if (confirm(`Are you sure you want to remove ${gameName}?`)) {
           // Also remove from favorites if it's there
           favoriteGames = favoriteGames.filter(fav => fav.name !== gameName);
           localStorage.setItem('favoriteGames', JSON.stringify(favoriteGames));
            console.log('Removed game from favorites if present.');

           games.splice(index, 1);
           saveGames();
           updateGamesPage();
           console.log('Game removed successfully:', gameName);
         }
      } else {
         console.error("Invalid index for removeGame:", index);
      }
    }

    // --- Drag and Drop (Games) ---
     function setupDragAndDrop() {
         console.log('Setting up drag and drop.');
         // Use event delegation on the container
         const container = document.getElementById('gamesContainerInner'); // Target the inner container
         if (!container) {
            console.log('Games container not found, skipping drag and drop setup.');
            return;
         }

         // Remove previous listeners if re-setting up
         container.removeEventListener('dragstart', handleDragStart);
         container.removeEventListener('dragover', handleDragOver);
         container.removeEventListener('dragenter', handleDragEnter);
         container.removeEventListener('dragleave', handleDragLeave);
         container.removeEventListener('drop', handleDrop);
         container.removeEventListener('dragend', handleDragEnd);

         // Add new listeners
         container.addEventListener('dragstart', handleDragStart);
         container.addEventListener('dragover', handleDragOver);
         container.addEventListener('dragenter', handleDragEnter);
         container.addEventListener('dragleave', handleDragLeave);
         container.addEventListener('drop', handleDrop);
         container.addEventListener('dragend', handleDragEnd);
          console.log('Drag and drop event listeners added.');
     }

     function handleDragStart(e) {
         // Only allow dragging on .game-card elements
         if (e.target.classList.contains('game-card')) {
             draggedItem = e.target;
             draggedIndex = parseInt(draggedItem.getAttribute('data-index'));
             console.log('Drag started for index:', draggedIndex);
             // Use setTimeout to allow the browser to render the drag image before hiding/styling
             setTimeout(() => {
                 if (draggedItem) draggedItem.classList.add('dragging');
             }, 0);
             e.dataTransfer.effectAllowed = 'move';
             // Set dummy data for Firefox compatibility
             e.dataTransfer.setData('text/plain', draggedIndex);
         } else {
             e.preventDefault(); // Prevent dragging other elements within the container
         }
     }

     function handleDragOver(e) {
         e.preventDefault(); // Necessary to allow dropping
         e.dataTransfer.dropEffect = 'move';
         // Optional: Visual feedback for where the drop will occur
         const target = e.target.closest('.game-card');
         if (target && target !== draggedItem) {
             // Simple placeholder logic (can be improved)
             document.querySelectorAll('.game-card-placeholder').forEach(p => p.classList.remove('game-card-placeholder'));
             target.classList.add('game-card-placeholder');
         }
         return false;
     }


    function handleDragEnter(e) {
       // Added check to ensure we're entering a game card and not the dragged item itself
       const targetCard = e.target.closest('.game-card');
       if (targetCard && targetCard !== draggedItem) {
          targetCard.classList.add('game-card-placeholder');
       }
    }

    function handleDragLeave(e) {
       // Added check to ensure we're leaving a game card
        const targetCard = e.target.closest('.game-card');
        if (targetCard) {
           targetCard.classList.remove('game-card-placeholder');
        }
        // Also remove if leaving the container entirely but over an empty space
        if (!e.target.closest('.game-card') && e.relatedTarget && !e.relatedTarget.closest('.game-card')) {
           document.querySelectorAll('.game-card-placeholder').forEach(p => p.classList.remove('game-card-placeholder'));
        }
    }


    function handleDrop(e) {
       e.preventDefault(); // Prevent default drop behavior
       e.stopPropagation(); // Prevent drop event from bubbling up
       console.log('Drop handled.');

       const dropTarget = e.target.closest('.game-card');
       if (dropTarget && draggedItem && dropTarget !== draggedItem) {
          const dropIndex = parseInt(dropTarget.getAttribute('data-index'));

          // Reorder the 'games' array
          if (draggedIndex !== null && dropIndex !== null && draggedIndex !== dropIndex) {
             const itemToMove = games.splice(draggedIndex, 1)[0];
             games.splice(dropIndex, 0, itemToMove);
             saveGames(); // Save the new order
             updateGamesPage(); // Refresh the display
             console.log(`Dropped item from index ${draggedIndex} to ${dropIndex}. Games array reordered.`);
          }
       }
       // Clean up placeholder classes even if drop wasn't on a valid target
       document.querySelectorAll('.game-card-placeholder').forEach(p => p.classList.remove('game-card-placeholder'));
        console.log('Drag and drop cleanup complete.');

       return false;
    }


     function handleDragEnd(e) {
         console.log('Drag ended.');
         // Use setTimeout to ensure cleanup happens after potential drop event processing
         setTimeout(() => {
             if (draggedItem) {
                 draggedItem.classList.remove('dragging');
             }
             document.querySelectorAll('.game-card-placeholder').forEach(p => p.classList.remove('game-card-placeholder'));
             draggedItem = null; // Reset dragged item
             draggedIndex = null;
             console.log('Drag end cleanup complete.');
         }, 0);
     }


    // --- Theme Handling ---
    function setTheme(themeName) {
      console.log('Attempting to set theme:', themeName);
    
      const selectedTheme = themes.find(theme => theme.name === themeName);
    
      if (!selectedTheme) {
        console.error('Theme not found:', themeName);
        return;
      }
    
      // Apply CSS variables from the selected theme to the document root
      for (const [variable, value] of Object.entries(selectedTheme.variables)) {
        document.documentElement.style.setProperty(variable, value);
      }
    
      currentThemeName = themeName; // Update the current theme name state
      localStorage.setItem('theme', themeName);
      console.log('Theme applied and saved to localStorage:', themeName);
    
      // Update theme selector UI
      document.querySelectorAll('.theme-option').forEach(option => {
        option.classList.remove('selected');
        // Find the option element that corresponds to the selected theme's previewClass
        if (option.classList.contains(selectedTheme.previewClass)) {
          option.classList.add('selected');
        }
      });
      console.log('Theme selector UI updated.');
    
       // Update Vanta.js colors and parameters - Keep this logic as it is,
       // it reads computed styles after they are applied.
        if (vantaEffect) {
            console.log('Vanta.js effect exists, updating options...');
             // Use document.documentElement to get computed styles from :root
             setTimeout(() => { // Small delay to ensure styles are computed
                 const computedStyle = getComputedStyle(document.documentElement);
                 const themeBgDark = computedStyle.getPropertyValue('--bg-dark').trim();
                 console.log(`Computed --bg-dark for theme ${themeName} during setOptions:`, themeBgDark);
                 const newThemeBaseColor = colorToVantaFormat(themeBgDark);
                 console.log(`Converted Vanta.js baseColor for theme ${themeName} during setOptions:`, '0x' + newThemeBaseColor.toString(16));
    
                 vantaEffect.setOptions({
                   highlightColor: 0x0,
                   midtoneColor: 0x0,
                   lowlightColor: 0x0,
                   baseColor: newThemeBaseColor,
                   blurFactor: 0.56,
                   speed: 1.10,
                   zoom: 1.20
                 });
                 console.log('Vanta.js options updated.');
             }, 50);
           } else {
               console.log('Vanta.js effect not initialized (null) when setTheme was called. Skipping setOptions.');
           }
    }

    // --- Game Filtering & Display ---
    function filterGames() {
       const query = document.getElementById('gameSearch').value.toLowerCase();
       const container = document.getElementById('gamesContainerInner'); // Target inner container
       if (!container) {
         console.log('Games container not found for filtering.');
         return;
       }
       console.log('Filtering games with query:', query);


       const allCards = container.querySelectorAll('.game-card');
       let foundMatch = false;

       allCards.forEach(card => {
          const name = card.querySelector('p')?.textContent.toLowerCase();
          const matches = name ? name.includes(query) : false;
          card.style.display = matches ? '' : 'none';
          if (matches) foundMatch = true;
       });

        // Show "No games found" message if needed
        let noGamesMessage = container.querySelector('.no-games-message');
        const gamesToConsider = isShowingFavoriteGames() ? games.filter(game => favoriteGames.some(fav => fav.name === game.name)) : games;

        if (!foundMatch && gamesToConsider.length > 0 && !noGamesMessage && query) {
            // Filter active, no matches, but games exist
             noGamesMessage = document.createElement('p');
             noGamesMessage.className = 'no-games-message';
             noGamesMessage.style.color = 'var(--text-muted)';
             noGamesMessage.style.width = '100%';
             noGamesMessage.style.textAlign = 'center';
             container.appendChild(noGamesMessage);
        } else if ((foundMatch || !query) && noGamesMessage) {
             // Filter not active or matches found, remove message
             noGamesMessage.remove();
             noGamesMessage = null; // Reset variable
        }

        // Update message text based on state
        if (!foundMatch && noGamesMessage) {
             noGamesMessage.textContent = isShowingFavoriteGames() ? 'No favorite games match your search.' : 'No games match your search.';
        } else if (!foundMatch && !query && !noGamesMessage && gamesToConsider.length === 0) {
             // No filter, no games, no message exists yet - create it
              noGamesMessage = document.createElement('p');
              noGamesMessage.className = 'no-games-message';
              noGamesMessage.style.color = 'var(--text-muted)';
              noGamesMessage.style.width = '100%';
              noGamesMessage.style.textAlign = 'center';
              container.appendChild(noGamesMessage);
             noGamesMessage.textContent = isShowingFavoriteGames() ? 'No favorite games found.' : 'No games found.';
        }
        console.log('Game filtering complete. Found matches:', foundMatch);

    }

    function updateGamesPage() {
           console.log('Updating Games page content. Showing favorites:', isShowingFavoriteGames());
           const gamesToDisplay = isShowingFavoriteGames() ?
             games.filter(game => favoriteGames.some(fav => fav.name === game.name)) :
             games;
    
           // Generate the cards first
           const gameCardsHTML = gamesToDisplay.map((game, index) => {
             // Find original index to use for actions (like remove/favorite/proxy)
             const originalIndex = games.findIndex(g => g.name === game.name);
             // Ensure the index is valid before generating the card
             if (originalIndex === -1) return ''; // Skip if game not found in main list
    
             return `
               <div class="game-card" draggable="true" data-index="${originalIndex}">
                 <div class="remove-icon" onclick="removeGame(event, ${originalIndex})" title="Remove Game">
                   <i class="fas fa-times"></i>
                 </div>
                 <img src="${escapeHtml(game.icon)}" alt="${escapeHtml(game.name)}"
                      onerror="this.src='https://via.placeholder.com/150?text=No+Image'"
                      onclick="loadGame('${escapeHtml(game.name)}', '${escapeHtml(game.url)}')">
                 <p onclick="loadGame('${escapeHtml(game.name)}', '${escapeHtml(game.url)}')">${escapeHtml(game.name)}</p>
                 <div style="display: flex; flex-direction: column; gap: 5px; align-items: center; margin-top: 5px;">
                   <button class="favorite-button" onclick="event.stopPropagation(); toggleFavoriteGame(${originalIndex})">
                     <i class="fas ${isFavoriteGame(game) ? 'fa-solid' : 'fa-regular'} fa-star" style="${isFavoriteGame(game) ? 'color: var(--accent);' : ''}"></i>
                     <span>${isFavoriteGame(game) ? 'Favorited' : 'Favorite'}</span>
                   </button>
                   ${game.proxiedUrl && game.proxiedUrl !== 'none' ? // Only show proxy toggle if proxy URL exists
                     `<button class="favorite-button" onclick="event.stopPropagation(); toggleProxied(${originalIndex})">
                       <i class="fas fa-shield-alt"></i>
                       <span>Proxy: ${game.proxied ? 'On' : 'Off'}</span>
                     </button>`
                     : ''
                   }
                 </div>
               </div>`;
             }).join('');
    
    
           // Return the full container HTML
           const gamesContent = `
             <input type="text" id="gameSearch" placeholder="Search Games..." oninput="filterGames()" style="width: 90%; max-width: 400px; margin: 0 auto 1.5rem auto; display: block;">
             <div class="games-header">
               <div class="action-card" onclick="showAddGameModal()">
                 <i class="fas fa-plus"></i>
                 <p>Add Game</p>
               </div>
               <div class="action-card" onclick="toggleFavoriteGamesView()">
                 <i class="fas fa-star" style="${isShowingFavoriteGames() ? 'color: var(--accent);' : ''}"></i>
                 <p>${isShowingFavoriteGames() ? 'All Games' : 'Favorites'}</p>
               </div>
             </div>
             <div class="games-container" id="gamesContainerInner">
                 ${gameCardsHTML || '<p class="no-games-message" style="color: var(--text-muted); width: 100%; text-align: center;">No games found.</p>'}
             </div>`;
    
    
          // Update the page content ONLY if we are currently displaying the Games or Favorite Games view
           // Check the actual pageTitle text to know if we are *conceptually* on the games page view
          if (pageTitle.textContent === 'Games' || pageTitle.textContent === 'Favorite Games') {
             pageContent.innerHTML = gamesContent; // Set the innerHTML
             console.log('Games page HTML updated.');
             // Re-run setup for drag/drop as elements were replaced
             setupDragAndDrop();
             // Restore search term if it exists
             const searchInput = document.getElementById('gameSearch');
             if (searchInput && searchInput.value) {
                filterGames(); // Re-apply filter
             } else {
                 // If no search term, ensure initial "No games found" message is correct
                 const container = document.getElementById('gamesContainerInner');
                  const gamesToConsider = isShowingFavoriteGames() ? games.filter(game => favoriteGames.some(fav => fav.name === game.name)) : games;
                 if (container && gamesToConsider.length === 0 && !container.querySelector('.no-games-message')) {
                     let noGamesMessage = document.createElement('p');
                     noGamesMessage.className = 'no-games-message';
                     noGamesMessage.style.color = 'var(--text-muted)'; // This line was potentially the issue or nearby
                     noGamesMessage.style.width = '100%';
                     noGamesMessage.style.textAlign = 'center';
                     noGamesMessage.textContent = isShowingFavoriteGames() ? 'No favorite games found.' : 'No games found.';
                     container.appendChild(noGamesMessage);
                      console.log('Displayed initial "No games found" message.');
                 } else if (container && gamesToConsider.length > 0 && container.querySelector('.no-games-message') && !searchInput.value) {
                     // Games now exist, and no filter is active, remove the "No games found" message
                     container.querySelector('.no-games-message').remove();
                      console.log('Removed "No games found" message as games are present.');
                 }
    
             }
          } else {
              console.log('Not on Games or Favorite Games page, skipping content update.');
          }
          // Updating pages.Games might not be necessary if content is always generated
          // pages.Games = gamesContent;
        }


    // --- Library Page ---
     function updateLibraryPage() {
       console.log('Updating Library page content.');
       const favoritedWebsitesContainer = document.getElementById('favoritedWebsites');
       const recentlyViewedContainer = document.getElementById('recentlyViewed');

       if (!favoritedWebsitesContainer || !recentlyViewedContainer) {
         console.log('Library containers not found, skipping update.');
         return;
       }

       const favoritedWebsites = library; // Already loaded in loadData
       const recentlyViewed = JSON.parse(localStorage.getItem('recentlyViewed')) || [];

       favoritedWebsitesContainer.innerHTML = favoritedWebsites.length > 0 ? favoritedWebsites.map((item, index) => `
         <div class="library-item" data-url="${escapeHtml(item)}">
           <div class="remove-icon" onclick="removeLibraryItem(event, ${index})" title="Remove Favorite">
             <i class="fas fa-times"></i>
           </div>
           <div class="library-item-content" onclick="loadViewerFromLibrary('${escapeHtml(item)}', '${escapeHtml(item)}')">
             ${escapeHtml(item)}
           </div>
         </div>
       `).join('') : '<p class="no-results-message" style="color: var(--text-muted); text-align: center;">No favorites added yet.</p>'; // Added class here

       recentlyViewedContainer.innerHTML = recentlyViewed.length > 0 ? recentlyViewed.slice(0, 10).map(item => `
         <div class="library-item">
           <div class="library-item-content" onclick="loadViewerFromLibrary('${escapeHtml(item)}', '${escapeHtml(item)}')">
             ${escapeHtml(item)}
           </div>
         </div>
       `).join('') : '<p style="color: var(--text-muted); text-align: center;">No recently viewed sites.</p>';

        console.log('Library HTML updated.');

       // Re-apply filter if search box has value
       const searchInput = document.getElementById('librarySearch');
       if (searchInput && searchInput.value) {
          filterLibrary();
       }
     }


function loadGame(name, url) {
      console.log('loadGame() called for:', name, url);
      const game = games.find(g => g.name === name);
      const useProxy = game && game.proxied && game.proxiedUrl && game.proxiedUrl !== 'none';
      const targetUrl = useProxy ? game.proxiedUrl : url;
      const displayUrl = useProxy ? "Proxy Active" : url;

      if (useProxy) {
        console.log('Proxy mode active. Loading proxied game in viewer:', game.proxiedUrl);
        // Removed the window.open and setInterval logic
        loadViewerFromLibrary(game.proxiedUrl, name, displayUrl, true); // Pass true to update recents
      } else {
        console.log('Direct game load:', url);
        loadViewerFromLibrary(url, name, displayUrl, true); // Pass true to update recents
      }
    }



    // --- Favorites ---
    function toggleFavoriteGame(index) {
      console.log('Toggling favorite for game index:', index);
      if (index < 0 || index >= games.length) {
        console.error("Invalid index for toggleFavoriteGame:", index);
        return; // Index check
      }
    
      const game = games[index];
      const gameName = game.name; // Use name for consistency
      const isCurrentlyFavorite = favoriteGames.some(favGame => favGame.name === gameName);
    
      if (isCurrentlyFavorite) {
        favoriteGames = favoriteGames.filter(favGame => favGame.name !== gameName);
        console.log('Removed game from favorites.');
      } else {
        // Add a minimal representation to favorites if not already there
         if (!favoriteGames.some(fav => fav.name === gameName)) {
           favoriteGames.push({ name: gameName }); // Store only name or minimal needed data
           console.log('Added game to favorites.');
         } else {
            console.log('Game was already in favorites list (check logic).');
         }
      }
      localStorage.setItem('favoriteGames', JSON.stringify(favoriteGames));
       console.log('Favorite games saved:', favoriteGames.length);
    
    
      // Update UI immediately for the specific card
      // Check if the clicked button is within the Game of the Day container
      const gameOfTheDayContainer = document.getElementById('game-of-day-container');
      let button = null;
    
      if (gameOfTheDayContainer && gameOfTheDayContainer.contains(event.target)) {
          // If the clicked element is inside the Game of the Day container,
          // find the favorite button relative to the container.
          // This assumes there's only one favorite button within the game-of-day-container's .game-card
          button = gameOfTheDayContainer.querySelector('.favorite-button');
          console.log('Updating favorite button in Game of the Day container.');
    
      } else {
          // Otherwise, assume it's a button on the main Games page
           button = document.querySelector(`.game-card[data-index="${index}"] .favorite-button`);
           console.log('Updating favorite button on Games page.');
      }
    
    
      if (button) {
        const icon = button.querySelector('i.fa-star');
        const span = button.querySelector('span');
        const isFavoriteNow = isFavoriteGame(game); // Check the state again after toggling
        if (isFavoriteNow) {
           if(icon) {
             icon.classList.remove('fa-regular');
             icon.classList.add('fa-solid'); // Add solid class for filled
             icon.style.color = 'var(--accent)'; // Accent color for filled star
           }
           if(span) span.textContent = 'Favorited';
        } else {
           if(icon) {
             icon.classList.remove('fa-solid');
             icon.classList.add('fa-regular'); // Add regular class for outline
             icon.style.color = ''; // Reset color
           }
           if(span) span.textContent = 'Favorite';
        }
         console.log('Favorite button UI updated.');
      } else {
         console.warn('Favorite button not found for index:', index);
      }
    
    
      // If currently showing favorites view on the Games page, re-render
       if (isShowingFavoriteGames() && pageTitle.textContent === 'Favorite Games') { // Check state and current page title
          console.log('Currently showing favorites view on Games page, re-rendering.');
          updateGamesPage(); // Re-render the list based on the updated favoriteGames array
       } else {
           console.log('Not on Favorite Games page or showing all games, skipping full re-render.');
       }
    }


    function isFavoriteGame(game) {
       // Check against the favoriteGames array (which might store just names or full objects)
       return favoriteGames.some(fav => fav.name === game.name);
    }

    function isShowingFavoriteGames() {
      return showingFavorites; // Check the state variable
    }

    function toggleFavoriteGamesView() {
      showingFavorites = !showingFavorites; // Flip state
      console.log('Toggling favorite games view. showingFavorites:', showingFavorites);

      // Update the action card's appearance (Favorites/All Games button)
      const favActionCard = document.querySelector('.games-header .action-card:nth-child(2)'); // Target the Favorites/All Games action card

      if (favActionCard) {
          const icon = favActionCard.querySelector('i.fa-star');
          const textP = favActionCard.querySelector('p');

          if (showingFavorites) {
               if (icon) {
                   icon.classList.remove('fa-regular');
                   icon.classList.add('fa-solid'); // Use fa-solid for filled star
                   icon.style.color = 'var(--accent)'; // Apply accent color
               }
               if (textP) textP.textContent = 'All Games';
               console.log('Updated action card to show All Games.');
          } else {
               if (icon) {
                   icon.classList.remove('fa-solid');
                   icon.classList.add('fa-regular'); // Use fa-regular for outline star
                    icon.style.color = ''; // Remove accent color
               }
               if (textP) textP.textContent = 'Favorites';
                console.log('Updated action card to show Favorites.');
          }
      } else {
         console.warn('Favorite games action card not found.');
      }


      // Update the page title based on the new state - HIDE for Home page
       if (pageTitle.textContent !== 'Home') {
         pageTitle.textContent = showingFavorites ? 'Favorite Games' : 'Games';
         pageTitle.style.display = 'block'; // Show title for Games/Favorites page
         console.log('Updated page title:', pageTitle.textContent);
       } else {
          pageTitle.style.display = 'none';
          console.log('Hid page title on Home.');
       }


      // Re-render the games list based on the new state
      updateGamesPage();
    }
    const cloakPresets = {
        goguardian: { title: 'GoGuardian Admin', favicon: 'https://www.goguardian.com/favicon.ico' },
        drive: { title: 'My Drive - Google Drive', favicon: 'https://ssl.gstatic.com/images/branding/product/1x/drive_2020q4_32dp.png' },
        classroom: { title: 'Classes', favicon: 'https://ssl.gstatic.com/classroom/favicon.png' },
        // 'custom' will use the values saved via 'App Appearance'
        custom: { title: null, favicon: null } // Placeholder
    };

    function applyPresetCloak() {
        const select = document.getElementById('tabCloakSelect');
        if (!select) {
            console.error("Tab cloak select element not found.");
            alert("Error: Could not find tab cloak dropdown.");
            return;
        }
        const selectedValue = select.value;
        let settingsToApply;

        if (selectedValue === 'custom') {
            // Load custom settings from localStorage
            const savedAppSettings = localStorage.getItem('appSettings');
            settingsToApply = savedAppSettings ? JSON.parse(savedAppSettings) : { title: 'Underground', favicon: '' }; // Default if no custom saved
             console.log('Applying custom cloak settings from App Appearance.');
        } else if (cloakPresets[selectedValue]) {
            settingsToApply = {
                tabTitle: cloakPresets[selectedValue].title,
                faviconUrl: cloakPresets[selectedValue].favicon
            };
             console.log(`Applying preset cloak: ${selectedValue}`);
        } else {
             console.error(`Invalid cloak preset selected: ${selectedValue}`);
             alert("Invalid cloak option selected.");
             return;
        }

        // Apply the settings
        applyAppSettings(settingsToApply);

        // Save the *choice* of preset (or 'custom') so it can be re-selected on load
        localStorage.setItem('currentCloakPreset', selectedValue);

        alert(`Tab cloak applied: ${select.options[select.selectedIndex].text}`);
    }

    function resetCloak() {
        console.log('Resetting tab cloak to default (Underground).');
        // Reset to the application's default title and potentially remove favicon
        const defaultSettings = {
            tabTitle: 'Underground', // Your app's default name
            faviconUrl: '' // Default (no favicon)
        };
        applyAppSettings(defaultSettings);

        // Remove the saved preset choice and custom settings
        localStorage.removeItem('currentCloakPreset');
        // Optionally, you might want to keep custom settings but just un-apply the cloak:
        // localStorage.setItem('currentCloakPreset', 'custom'); // Revert selection to custom
        // const savedAppSettings = localStorage.getItem('appSettings');
        // if (savedAppSettings) applyAppSettings(JSON.parse(savedAppSettings));

        // Update the dropdown selection
        const select = document.getElementById('tabCloakSelect');
        if (select) {
            select.value = 'custom'; // Set dropdown to custom after reset
        }

        alert("Tab cloak reset to default.");
    }

    // Function to load and apply the saved cloak state when settings page loads
    function loadTabCloakSettings() {
        const savedPreset = localStorage.getItem('currentCloakPreset');
        const select = document.getElementById('tabCloakSelect');

        if (select && savedPreset) {
            select.value = savedPreset;
            console.log(`Loaded saved cloak preset selection: ${savedPreset}`);
            // Optional: Automatically re-apply the cloak based on saved preset?
            // applyPresetCloak(); // Be cautious if this has side effects on initial load
        } else if (select) {
             select.value = 'custom'; // Default to custom if nothing saved
              console.log('No saved cloak preset found, defaulting select to custom.');
        }
    }
      
    // --- Page Definitions & Switching ---
const pages = {
        Home: `
            <div class="home-layout">
                <div class="home-header">
                    <div class="home-logo">undergr0und</div>
                </div>
                <div class="home-main-section">
                     <button class="changelog-button" onclick="openChangelogModal()" title="View Changelog"><i class="fas fa-list-alt"></i> Changelog</button>
                     <div class="home-search-container">
                         <i class="fas fa-search search-icon"></i>
                         <input type="text" id="homeSearchInput" placeholder="Search or type a URL" onkeydown="if(event.key==='Enter') loadViewer()">
                     </div>
                     <div class="home-status">
                        <p>Hidden: <span style="color: green;">True</span></p>
                        <p>Installed: <span id="home-installed-version">v1.0.0</span></p>
                        <p>Latest: <span id="home-latest-version">Checking...</span></p>
                    </div>
                </div>

                <div class="home-bottom-section">
                    <div class="panel home-news-panel">
                        <h2>News</h2>
                        <pre id="news-content" style="white-space: pre-wrap; font-family: inherit; text-align: left;"></pre>
                    </div>
                    <div class="game-of-day-container" id="game-of-day-container">
                        </div>
                </div>
            </div>
        `,
        Library: `
            <div class="panel" style="width: 95%; max-width: 900px;">
              <h2>Library</h2>
              <input type="text" id="librarySearch" placeholder="Search Favorites..." oninput="filterLibrary()">
              <div class="library-columns">
                <div class="library-column">
                  <h3><i class="fas fa-star" style="color:var(--accent); margin-right: 5px;"></i>Favorites</h3>
                  <div id="favoritedWebsites" style="max-height: 60vh; overflow-y: auto;"></div>
                </div>
                <div class="library-column">
                  <h3><i class="fas fa-history" style="color:var(--accent); margin-right: 5px;"></i>Recents</h3>
                  <div id="recentlyViewed" style="max-height: 60vh; overflow-y: auto;"></div>
                </div>
              </div>
            </div>`,
        Viewer: `<div class="panel"><h2>Viewer</h2><p>Click the globe icon or use the search bar on the Home page to launch the viewer.</p></div>`, // Simplified Viewer page, main viewing happens in iframe overlay
        Games: ``, // Placeholder - content is dynamically generated
        Updater: `
            <div class="panel">
              <h2>Updater</h2>
              <p>This section is for future update functionality.</p>
              <button onclick="checkForUpdatesManual()">Check Manually</button>
              <p id="update-status-message" style="color: var(--text-muted); margin-top: 1rem;">Status: Idle</p>
               <button onclick="openChangelogModal()" style="margin-top: 1rem;">View Changelog</button> </div>`,
        Settings: `
        <div class="settings-grid-container">
          <div class="settings-grid-item">
             <h2>Theme</h2>
             <h3>Theme Selection</h3>
              <div class="theme-selector" id="themeSelector">
                  ${themes.map(theme => `
                      <div class="theme-option ${theme.previewClass}"
                           onclick="setTheme('${theme.name}')"
                           title="${theme.name.charAt(0).toUpperCase() + theme.name.slice(1)}">
                      </div>
                  `).join('')}
              </div>
               <button class="setting-reset-button" onclick="resetThemeSettings()" title="Reset Theme to Default">
                   <i class="fas fa-undo"></i> Reset
               </button>
          </div>

          <div class="settings-grid-item">
            <h2>About:Blank</h2>
            <p>Cloak the site in an about:blank page and toggle about:blank on startup.</p>
            <div style="display: flex; align-items: center; gap: 10px; justify-content: center; flex-direction: column; height: 100%;">
                <div style="display: flex; align-items: center; gap: 10px;">
                     <label class="switch">
                       <input type="checkbox" id="aboutBlankToggle" onclick="toggleAboutBlankStartup()" checked>
                       <span class="slider round"></span>
                     </label>
                     <span>Enabled on Startup</span>
                </div>
                <button onclick="openAppInAboutBlank()">Open Popup Now</button>
            </div>
               <button class="setting-reset-button" onclick="resetAboutBlankSettings()" title="Reset About:Blank Setting">
                   <i class="fas fa-undo"></i> Reset
               </button>
          </div>

          <div class="settings-grid-item">
            <h2>Panic Key</h2>
             <p>Quick open another site with one press.</p>
             <input type="text" id="panicKeyInput" placeholder="Enter Key (e.g., Escape, Alt+Q)">
             <input type="text" id="panicUrlInput" placeholder="Redirect URL (e.g., https://google.com)">
             <button onclick="savePanicKeySettings()">Save Panic Key</button>
               <button class="setting-reset-button" onclick="resetPanicKeySettings()" title="Reset Panic Key">
                   <i class="fas fa-undo"></i> Reset
               </button>
          </div>

          <div class="settings-grid-item">
            <h2>Presets</h2>
            <p>Change the title and icon using presets.</p>
             <select id="tabCloakSelect">
              <option value="goguardian">GoGuardian Admin Block</option>
              <option value="drive">Google Drive</option>
              <option value="classroom">Google Classroom</option>
              <option value="custom">Custom (Use App Appearance)</option>
            </select>
            <button onclick="applyPresetCloak()">Apply Cloak</button>
            <button class="setting-reset-button" onclick="resetCloak()" title="Reset Tab Cloak to Default">
                <i class="fas fa-undo"></i> Reset
            </button>
             </div>

          <div class="settings-grid-item">
               <h2>App Appearance</h2>
               <p>Set a custom title and icon (favicon). Used by 'Custom' cloak.</p>
               <input type="text" id="appTabTitleInput" placeholder="Custom Tab Title">
               <input type="text" id="appFaviconUrlInput" placeholder="Custom Favicon URL">
               <button onclick="saveAppSettings()">Save App Appearance</button>
               <button class="setting-reset-button" onclick="resetAppAppearanceSettings()" title="Reset App Appearance to Default">
                   <i class="fas fa-undo"></i> Reset
               </button>
          </div>


           <div class="settings-grid-item">
            <h2>Reset All Data
                </h2>
            <p>This deletes all saved data (games, library, all settings).</p>
            <button class="reset-button" onclick="resetApp()">
              <i class="fas fa-trash-alt"></i> Reset App Data
            </button>
           </div>

           </div>
    `,
       About: `
            <div class="panel" style="max-width: 500px; text-align: left;">
              <h2>About Underground</h2>
              <p>Underground is a fully custom game launcher and viewer focused on providing a simple, user-friendly interface for accessing online games and websites to circumvent internet censorship</p>
              <p>Version: <span id="about-version">1.0.0</span></p>
              <p>Created by: Zerone</p>
              <p>
                <a href="#" onclick="openChangelogModal(); return false;" style="color: var(--accent); text-decoration: none;">View Changelog</a> |
                <a href="https://github.com/ZeroneV1" style="color: var(--accent); text-decoration: none;">Contact</a>
              </p>
              <h3 style="margin-top: 1rem;">Credits:</h3>
              <p style="font-size: 0.9rem;">
                Uses: Vanta.js, Three.js, Font Awesome.<br>
              </p>
              <h3 style="margin-top: 1rem;">Disclaimer:</h3>
              <p style="font-size: 0.8rem; color: var(--text-muted);">
                Underground is a third-party application. We are not affiliated with external websites or games. Use responsibly.
              </p>
            </div>
        `,
    };

    function checkForUpdatesManual() {
        console.log('Manual update check requested.');
        const statusEl = document.getElementById('update-status-message');
        if(statusEl) statusEl.textContent = "Status: Checking for updates...";
        // Add actual update check logic here if needed
        setTimeout(() => {
             if(statusEl) statusEl.textContent = "Status: No updates found (manual check).";
             console.log('Manual update check simulation complete.');
        }, 2000);
    }


    function switchPage(pageKey) {
       console.log('Switching to page:', pageKey);

       // Handle special case for Games page entry/exit to manage favorite view state
       if (pageKey === 'Games') {
           showingFavorites = false; // Always reset to show all games when navigating *to* the Games page
            pageTitle.textContent = 'Games'; // Ensure title is 'Games' when initially entering
            pageTitle.style.display = 'block'; // Show title for Games page
             console.log('Switched to Games page. Resetting favorites view state.');

           // Update the Favorites action card appearance to show 'Favorites'
            const favActionCard = document.querySelector('.games-header .action-card:nth-child(2)');
            if (favActionCard) {
                const icon = favActionCard.querySelector('i.fa-star');
                const textP = favActionCard.querySelector('p');
                 if (icon) {
                     icon.classList.remove('fa-solid');
                     icon.classList.add('fa-regular'); // Use fa-regular for outline star
                     icon.style.color = ''; // Remove accent color
                 }
                 if (textP) textP.textContent = 'Favorites';
                 console.log('Reset Games action card to show Favorites.');
            } else {
                console.warn('Games action card for favorites not found during page switch.');
            }


       } else if (pageKey === 'Home') {
           // Hide page title on the Home page
           pageTitle.style.display = 'none';
           console.log('Switched to Home page. Hiding page title.');
           // Reset favorite view state if coming from Games page
            if (showingFavorites) {
                 showingFavorites = false;
                  console.log('Came from favorites view, resetting showingFavorites state.');
            }
       } else {
            // Show page title for other pages
             pageTitle.style.display = 'block';
             pageTitle.textContent = pageKey; // Use the key as title for non-Games/Favorites pages
             console.log('Switched to page:', pageKey, 'Showing page title.');

            // Reset favorite view state if coming from Games page
             if (showingFavorites) {
                  showingFavorites = false;
                   console.log('Came from favorites view on another page, resetting showingFavorites state.');
             }
       }


       // Fade out content
       pageContent.classList.add('fade-out');
       console.log('Adding fade-out class to content.');


       // Store last page for potential back navigation - IMPORTANT: only store the actual page key
       localStorage.setItem('lastActivePage', pageKey);
       localStorage.setItem('lastActivePageTitle', pageTitle.textContent); // Store the actual title text
       console.log('Saved last active page:', pageKey);


       setTimeout(() => {
         console.log('Timeout before content switch complete.');
         // Set content based on the page key
         pageContent.innerHTML = pages[pageKey] || `<p>Content for ${pageKey} not found.</p>`;
         console.log(`Content set for page: ${pageKey}. Content found: ${!!pages[pageKey]}`);


         // Specific actions after loading content
         if (pageKey === 'Games') {
            updateGamesPage(); // This calls generateGamesHTML which now respects the showingFavorites state
         } else if (pageKey === 'Library') {
           updateLibraryPage();
         } else if (pageKey === 'Home') {
           checkVersion(); // Re-check version when going home
           fetchNews(); // Fetch news on home page load
            // The version spans are now in the Home page HTML, checkVersion will target them
             console.log('Home page specific actions (checkVersion, fetchNews) triggered.');
         } else if (pageKey === 'Settings') {
             // Ensure current theme is selected visually
             setTheme(currentTheme);
              console.log('Settings page loaded, setTheme called for current theme.');
         } else if (pageKey === 'About') {
             // Update about page version if needed
             const aboutVersionEl = document.getElementById('about-version');
             if (aboutVersionEl) aboutVersionEl.textContent = "1.0.0"; // Replace with dynamic version if available
             console.log('About page loaded, version updated.');
         }


         // Fade in new content
         pageContent.classList.remove('fade-out');
         console.log('Removing fade-out class, content should fade in.');


         // Ensure correct icon is active - ONLY for non-Viewer icons
          icons.forEach(i => {
              i.classList.remove('active');
              // Only activate if the data-page matches the actual pageKey AND it's not the Viewer icon
              if (i.getAttribute('data-page') === pageKey && pageKey !== 'Viewer') {
                  i.classList.add('active');
              }
          });
          console.log('Active sidebar icon updated.');


       }, 150); // Reduced fade time slightly
     }


    function handleIconClick() {
      const page = this.getAttribute('data-page');
      console.log('Sidebar icon clicked for page:', page);


      if (page === 'Viewer') {
          // Clicking the Viewer icon now launches the overlay directly
          // Call loadViewerFromLibrary with no URL to open the controls only
          loadViewerFromLibrary();
          console.log('Viewer icon clicked, launching viewer overlay.');
          // Do NOT call switchPage here, as we are staying on the current background page
          // No need to change active icon as the overlay covers everything
      } else {
          // For all other icons, perform normal page switching
          switchPage(page);
           console.log('Non-Viewer icon clicked, calling switchPage.');
      }
    }

    function handleTooltipShow(e) {
       // Debounce or throttle tooltip updates if performance becomes an issue
       tooltip.style.left = `${e.clientX + 15}px`; // Use clientX for fixed sidebar
       tooltip.style.top = `${e.clientY}px`;   // Use clientY
       tooltip.textContent = this.getAttribute('title');
       tooltip.style.display = 'block';
    }


    function handleTooltipHide() {
      tooltip.style.display = 'none';
    }

    // --- Library Management ---
    function addToLibraryFromHome() {
        console.log('addToLibraryFromHome() called.');
        const urlInput = document.getElementById('homeSearchInput'); // Get input from Home page
        const url = urlInput ? urlInput.value.trim() : null;
        addToLibrary(url);
        // Keep the text in the input box on the Home page
    }

    function addToLibraryFromViewer(url) {
         console.log('addToLibraryFromViewer() called with URL:', url);
         addToLibrary(url); // Add the URL currently in the viewer
    }


    function addToLibrary(url) {
      console.log('addToLibrary() called with URL:', url);
      if (!url) {
        alert('Please enter a URL first.');
        console.warn('addToLibrary failed: No URL provided.');
        return;
      }
       let finalUrl = url;
        if (!url.startsWith('http://') && !url.startsWith('https://')) {
         finalUrl = 'https://' + url;
         console.log('Prepended https to URL for library:', finalUrl);
       }

      if (!library.includes(finalUrl)) {
          library.push(finalUrl);
          localStorage.setItem('library', JSON.stringify(library));
          alert('Added to Library favorites!');
          console.log('Added to library:', finalUrl);
          // Update library view if currently visible
          if (pageTitle.textContent === 'Library') {
              updateLibraryPage();
               console.log('Library page is active, updating view.');
          }
      } else {
          alert('This URL is already in your Library favorites.');
          console.log('URL already in library:', finalUrl);
      }
    }


    function removeLibraryItem(event, index) {
      event.stopPropagation(); // Prevent triggering item click
      console.log('Attempting to remove library item at index:', index);
      if (index >= 0 && index < library.length) {
         const itemToRemove = library[index];
         if (confirm(`Remove "${itemToRemove}" from favorites?`)) {
            library.splice(index, 1);
            localStorage.setItem('library', JSON.stringify(library));
            updateLibraryPage(); // Refresh the library view
            console.log('Library item removed:', itemToRemove);
         }
      } else {
          console.error("Invalid index for removeLibraryItem:", index);
      }
    }


    function filterLibrary() {
       const query = document.getElementById('librarySearch').value.toLowerCase();
       const container = document.getElementById('favoritedWebsites'); // Target only favorites for filtering
       if (!container) {
         console.log('Favorited websites container not found for filtering.');
         return;
       }
        console.log('Filtering library favorites with query:', query);


       const allItems = container.querySelectorAll('.library-item');
       let foundMatch = false;

       allItems.forEach(item => {
          const url = item.getAttribute('data-url')?.toLowerCase(); // Use data-url
          const matches = url ? url.includes(query) : false;
          item.style.display = matches ? 'flex' : 'none'; // Use 'flex' as display type
          if (matches) foundMatch = true;
       });

        // Add/remove 'no results' message
        let noResultsMessage = container.querySelector('.no-results-message');
        const itemsToConsider = library; // Filtering the entire library list


        if (!foundMatch && itemsToConsider.length > 0 && !noResultsMessage && query) {
             // Filter active, no matches, but items exist
             noResultsMessage = document.createElement('p');
             noResultsMessage.className = 'no-results-message';
             noResultsMessage.style.color = 'var(--text-muted)';
             noResultsMessage.style.textAlign = 'center';
             noResultsMessage.style.width = '100%';
             container.appendChild(noResultsMessage);
             console.log('Created no-results message for filter.');
        } else if ((foundMatch || !query) && noResultsMessage) {
            // Filter not active or matches found, remove message
            noResultsMessage.remove();
            noResultsMessage = null; // Reset variable
             console.log('Removed no-results message.');
        }

        // Update message text based on state
        if (!foundMatch && noResultsMessage) {
             noResultsMessage.textContent = 'No favorites match your search.';
        } else if (!foundMatch && !query && !noResultsMessage && itemsToConsider.length === 0) {
             // No filter, no items, no message exists yet - create it
              noResultsMessage = document.createElement('p');
              noResultsMessage.className = 'no-results-message';
              noResultsMessage.style.color = 'var(--text-muted)';
              noResultsMessage.style.textAlign = 'center';
              noResultsMessage.style.width = '100%';
              container.appendChild(noResultsMessage);
             noResultsMessage.textContent = 'No favorites added yet.';
              console.log('Created initial no-favorites message.');
        }
        console.log('Library filtering complete. Found matches:', foundMatch);
    }


    // --- App Reset ---
    function resetApp() {
      console.log('Reset App requested.');
      if (confirm("Reset App? This deletes all custom games, library favorites, viewed history, and settings.")) {
        console.log('Reset confirmed.');
        // Clear localStorage
        localStorage.clear();
        console.log('localStorage cleared.');

        // Reset state variables
        games = []; // Will be repopulated by loadData
        library = [];
        favoriteGames = [];
        currentTheme = 'default';
        localStorage.setItem('theme', 'default'); // Set default theme immediately
        showingFavorites = false; // Reset favorite view state
        console.log('App state variables reset.');

        // Reload data (which includes defaults) and re-initialize UI
        loadData(); // This will set the default theme class
        setTheme('default'); // Explicitly call setTheme to update Vanta.js etc.
        initializeVanta(); // Re-initialize Vanta with default theme (although setTheme should handle this after init)
        switchPage('Home'); // Go to home page

        alert("App has been reset.");
        console.log('App reset complete.');
      } else {
          console.log('Reset cancelled.');
      }
    }
// --- Panic Key ---
    let panicKey = null;
    let panicUrl = null;

    function savePanicKeySettings() {
        const keyInput = document.getElementById('panicKeyInput');
        const urlInput = document.getElementById('panicUrlInput');

        if (keyInput && urlInput) {
            const key = keyInput.value.trim();
            const url = urlInput.value.trim();

            if (!key || !url) {
                alert("Please enter both a key and a URL for the panic key.");
                return;
            }
             // Basic URL validation (add https:// if missing)
             let finalUrl = url;
             if (!finalUrl.startsWith('http://') && !finalUrl.startsWith('https://')) {
                 finalUrl = 'https://' + finalUrl;
             }

            // Save to localStorage and update global variables
            localStorage.setItem('panicKey', key);
            localStorage.setItem('panicUrl', finalUrl);
            panicKey = key;
            panicUrl = finalUrl;

            alert(`Panic key set to '${key}' redirecting to '${finalUrl}'.`);
            console.log('Panic key settings saved:', { key: panicKey, url: panicUrl });

        } else {
            console.error("Panic key input elements not found.");
            alert("Error: Could not find panic key input elements.");
        }
    }

    function loadPanicKeySettings() {
        panicKey = localStorage.getItem('panicKey');
        panicUrl = localStorage.getItem('panicUrl');
        console.log('Loaded panic key settings:', { key: panicKey, url: panicUrl });

        // Update input fields if on settings page
        if (pageTitle.textContent === 'Settings') { // Check if settings page is active
             const keyInput = document.getElementById('panicKeyInput');
             const urlInput = document.getElementById('panicUrlInput');
             if (keyInput && panicKey) keyInput.value = panicKey;
             if (urlInput && panicUrl) urlInput.value = panicUrl;
        }
    }

function checkPanicKey(event) {
        const targetElement = event.target;
        // Log the tag name of the element that received the keydown event
        console.log(`Keydown event target: ${targetElement ? targetElement.tagName : 'null'}, Type: ${targetElement ? targetElement.type : 'N/A'}`);

        // Check if the event originated from an input field or textarea
        if (targetElement && (targetElement.tagName.toLowerCase() === 'input' || targetElement.tagName.toLowerCase() === 'textarea')) {
            // Specifically log if we are skipping because it's an input/textarea
            console.log('Target is input/textarea. Panic key check skipped.');
            return; // Stop execution if typing in these fields
        } else {
             // Log if we are proceeding because it's *not* an input/textarea
            console.log('Target is NOT input/textarea. Proceeding with panic key check.');
        }

        // --- Original panic key check logic ---
        if (!panicKey || !panicUrl) {
             // Log if the key/URL isn't set up
             console.log('Panic key or URL not set in variables. Aborting check.');
             return;
        }

        // Construct the key identifier string from the event
        let pressedKey = '';
        if (event.altKey) pressedKey += 'Alt+';
        if (event.ctrlKey) pressedKey += 'Control+'; // Note: Might be intercepted by OS/browser shortcuts
        if (event.shiftKey) pressedKey += 'Shift+';
        // Use event.key for character keys and specific names like 'Escape', 'Enter'
        pressedKey += event.key;
        // Log the keys being compared
        console.log(`Constructed pressedKey: "${pressedKey}", Comparing (case-insensitive) against panicKey: "${panicKey}"`);


        // Case-insensitive comparison
        if (pressedKey.toLowerCase() === panicKey.toLowerCase()) {
            // Log the successful match before redirecting
            console.log(`Panic key MATCHED: "${pressedKey}". Redirecting to: ${panicUrl}`);
            event.preventDefault(); // Prevent default action just in case
            window.location.href = panicUrl;
        } else {
             // Log if the keys didn't match
             console.log('Panic key did NOT match.');
        }
    }

    // --- Modify setupEventListeners to add panic key listener ---
    function setupEventListeners() {
          icons.forEach(icon => {
            icon.addEventListener('click', handleIconClick);
            icon.addEventListener('mousemove', handleTooltipShow);
            icon.addEventListener('mouseleave', handleTooltipHide);
          });
    
          addGameModal.addEventListener('click', (e) => {
            if (e.target === addGameModal) closeModal();
          });
    
          changelogModal.addEventListener('click', (e) => {
              if (e.target === changelogModal) closeChangelogModal();
          });
    
          document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (addGameModal.style.display === 'flex') closeModal();
                if (changelogModal.style.display === 'flex') closeChangelogModal();
                // Allow Escape key to dismiss the update overlay if it's visible
                 const updateOverlay = document.getElementById("updateOverlay");
                 if (updateOverlay && updateOverlay.style.display === 'flex') {
                    hideUpdateOverlay();
                 }
            }
            // Check for panic key on any keydown event
            checkPanicKey(e);
          });
    
           // Add event listener for the initial Update Now button
           const updateNowButton = document.getElementById('updateNowButton');
           if (updateNowButton) {
               updateNowButton.addEventListener('click', handleUpdateNowClick);
               console.log('Initial Update Now button event listener added.');
           } else {
                console.warn('Initial Update Now button not found.');
           }
    
           // Add event listeners for the new option buttons (need to get them after they are potentially added to the DOM)
           // A safer way is to add listeners after the HTML is rendered or use event delegation on the overlay.
           // For simplicity and to match the snippet style, let's add them here, but they might need adjustments
           // if the buttons are not immediately present when setupEventListeners runs initially.
           // An alternative is to add these listeners *after* handleUpdateNowClick reveals the buttons.
           // Let's add them here for now and make sure the elements are retrieved correctly.
    
           const reloadSiteButton = document.getElementById('reloadSiteButton');
           const downloadOfflineButton = document.getElementById('downloadOfflineButton');
           const updateCloseButton = document.getElementById('updateCloseButton');
    
           if (reloadSiteButton) {
               reloadSiteButton.addEventListener('click', handleReloadSiteClick);
                console.log('Reload Site button event listener added.');
           } else {
                console.warn('Reload Site button not found during setup.');
           }
    
           if (downloadOfflineButton) {
               downloadOfflineButton.addEventListener('click', handleDownloadOfflineClick);
                console.log('Download Offline button event listener added.');
           } else {
                console.warn('Download Offline button not found during setup.');
           }
    
            if (updateCloseButton) {
                updateCloseButton.addEventListener('click', hideUpdateOverlay);
                console.log('Update Close button event listener added.');
            } else {
                 console.warn('Update Close button not found.');
            }
    
    
           const sidebar = document.querySelector('.sidebar');
           document.addEventListener('mousemove', (e) => {
               if (e.clientX < 10 && !sidebar.classList.contains('open')) {
                   sidebar.classList.add('open');
               } else if (e.clientX > 70 && sidebar.classList.contains('open')) {
                   sidebar.classList.remove('open');
               }
           });
           document.documentElement.addEventListener('mouseleave', (e) => {
              if (sidebar.classList.contains('open')) {
                sidebar.classList.remove('open');
              }
           });
          console.log('Core event listeners set up.');
        }

     // --- Modify window.addEventListener('DOMContentLoaded') ---
window.addEventListener('DOMContentLoaded', async () => {
      console.log('DOMContentLoaded fired.');
      loadData(); // Load theme, app settings, games, library, favorites
      loadPanicKeySettings(); // Load panic key settings after other data
      console.log('Theme, app, game, library, favorite, panic key data loaded.');

      setTimeout(() => {
          console.log('Attempting to initialize Vanta.js...');
          initializeVanta();
          console.log('initializeVanta() called. Vanta effect:', vantaEffect);
          if (vantaEffect) {
              console.log('Calling setTheme with currentTheme after Vanta initialization.');
              // Fix: Use currentThemeName here, not currentTheme
              setTheme(currentThemeName); // Ensure Vanta uses the correct initial theme colors
          } else {
              console.warn('Vanta effect is null after initialization, cannot call setTheme to update options.');
          }
      }, 50);

      setupEventListeners(); // Setup listeners including the panic key listener
      console.log('Event listeners set up.');
      updateGamesPage();
      setupDragAndDrop();
      console.log('Games page updated and drag/drop setup.');
      switchPage('Home'); // Initial page load and triggers the first checkVersion call for Home page
      console.log('Switched to Home page.');

      // --- ADD THIS SECTION ---
      // Set up periodic update check (every 5 seconds for debugging)
      // This will call checkVersion() every 5000 milliseconds.
      setInterval(checkVersion, 60000);
      console.log("Periodic update check started (every 5 seconds).");
      // --- END OF SECTION TO ADD ---
    });

     // --- Modify switchPage function ---
     function switchPage(pageKey) {
        console.log('Switching to page:', pageKey);

        // Handle page-specific logic before fading out
        if (pageKey === 'Games') {
            showingFavorites = false;
            pageTitle.textContent = 'Games';
            pageTitle.style.display = 'block';
            console.log('Switched to Games page. Resetting favorites view state.');
        } else if (pageKey === 'Home') {
            pageTitle.style.display = 'none';
            console.log('Switched to Home page. Hiding page title.');
            if (showingFavorites) {
                showingFavorites = false;
                console.log('Came from favorites view, resetting showingFavorites state.');
            }
        } else {
            pageTitle.style.display = 'block';
            pageTitle.textContent = pageKey;
            console.log('Switched to page:', pageKey, 'Showing page title.');
             if (showingFavorites) {
                  showingFavorites = false;
                   console.log('Came from favorites view on another page, resetting showingFavorites state.');
             }
        }

        pageContent.classList.add('fade-out');
        console.log('Adding fade-out class to content.');

        localStorage.setItem('lastActivePage', pageKey);
        localStorage.setItem('lastActivePageTitle', pageTitle.textContent);
        console.log('Saved last active page:', pageKey);

        setTimeout(() => {
            console.log('Timeout before content switch complete.');
            pageContent.innerHTML = pages[pageKey] || `<p>Content for ${pageKey} not found.</p>`;
            console.log(`Content set for page: ${pageKey}. Content found: ${!!pages[pageKey]}`);

            // Specific actions after loading content
            if (pageKey === 'Games') {
                updateGamesPage();
            } else if (pageKey === 'Library') {
                updateLibraryPage();
            } else if (pageKey === 'Home') {
                checkVersion();
                fetchNews();
                console.log('Home page specific actions (checkVersion, fetchNews) triggered.');
            } else if (pageKey === 'Settings') {
                setTheme(currentThemeName); // Ensure theme selector visually matches
                loadPanicKeySettings(); // Ensure panic key inputs show saved values
                // Load App Settings into inputs
                const savedAppSettings = localStorage.getItem('appSettings');
                 if (savedAppSettings) {
                     applyAppSettings(JSON.parse(savedAppSettings)); // Reloads settings into inputs
                 }
                 // Load Tab Cloaker state
                 loadTabCloakSettings(); // Ensure dropdown/button state is correct
                // Load About:Blank toggle state
                const aboutBlankPref = localStorage.getItem('aboutBlankOnStartup');
                const shouldOpenInAboutBlank = aboutBlankPref !== 'false';
                const toggle = document.getElementById('aboutBlankToggle');
                if (toggle) {
                    toggle.checked = shouldOpenInAboutBlank;
                }

                console.log('Settings page loaded, UI updated for theme, panic key, app settings, cloaker, and about:blank.');
            } else if (pageKey === 'About') {
                const aboutVersionEl = document.getElementById('about-version');
                if (aboutVersionEl) aboutVersionEl.textContent = "1.0.0";
                console.log('About page loaded, version updated.');
            }

            pageContent.classList.remove('fade-out');
            console.log('Removing fade-out class, content should fade in.');

            icons.forEach(i => {
                i.classList.remove('active');
                if (i.getAttribute('data-page') === pageKey && pageKey !== 'Viewer') {
                    i.classList.add('active');
                }
            });
            console.log('Active sidebar icon updated.');

        }, 150);
     }

    // --- Individual Settings Reset Functions ---

    function resetThemeSettings() {
        console.log("Resetting theme to default.");
        setTheme('default'); // This already updates localStorage and UI
        alert("Theme reset to Default.");
    }

    function resetAboutBlankSettings() {
        console.log("Resetting About:Blank settings.");
        const toggle = document.getElementById('aboutBlankToggle');
        if (toggle) {
            toggle.checked = true; // Set to default state (checked/enabled)
        }
        localStorage.removeItem('aboutBlankOnStartup'); // Remove saved preference
        console.log("Removed aboutBlankOnStartup from localStorage.");
        alert("About:Blank setting reset to default (Enabled on Startup).");
    }

    function resetPanicKeySettings() {
        console.log("Resetting Panic Key settings.");
        const keyInput = document.getElementById('panicKeyInput');
        const urlInput = document.getElementById('panicUrlInput');

        // Clear UI
        if (keyInput) keyInput.value = '';
        if (urlInput) urlInput.value = '';

        // Clear variables and localStorage
        panicKey = null;
        panicUrl = null;
        localStorage.removeItem('panicKey');
        localStorage.removeItem('panicUrl');
        console.log("Removed panicKey and panicUrl from localStorage.");
        alert("Panic Key settings cleared.");
    }

    // For Tab Cloaker, the existing resetCloak() function works, so we just call that
    // from the new button. No new JS function needed here unless you want different behavior.

    function resetAppAppearanceSettings() {
        console.log("Resetting App Appearance settings.");
        const titleInput = document.getElementById('appTabTitleInput');
        const iconInput = document.getElementById('appFaviconUrlInput');

        // Clear UI
        if (titleInput) titleInput.value = '';
        if (iconInput) iconInput.value = '';

        // Clear localStorage
        localStorage.removeItem('appSettings');
        console.log("Removed appSettings from localStorage.");

        // Apply default appearance
        applyAppSettings({
            tabTitle: 'Underground', // Your app's default name
            faviconUrl: ''
        });
        alert("App Appearance reset to default.");
    }
  </script>
</body>
</html>
