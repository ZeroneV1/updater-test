<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Underground</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <style>
    :root { /* Apply variables to the root element */
      --bg-dark: #1c1c1e;
      --sidebar-dark: #2c2c2e;
      --text-light: #fff;
      --text-muted: #aaa;
      --card-bg: #1a1a1a;
      --accent: #00ff84;
      --transition-speed: 0.3s;
      --border-radius: 8px;
      --icon-size: 1.2rem;
      --search-height: 40px; /* Added for consistent search bar height */
    }


    .reset-button {
        background-color: #ff4444;
        color: white;
        width: 100%;
        margin-top: auto !important;
    }

    .reset-button:hover {
      background-color: #cc0000;
    }


    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      display: flex;
      /* Background color is now primarily handled by Vanta.js */
      /* background-color: var(--bg-dark); */
      color: var(--text-light); /* Use variable */
      height: 100vh;
      overflow: hidden;
      position: relative; /* Needed for z-index stacking */
    }

    /* Ensure Vanta canvas is behind everything else */
    .vanta-canvas {
       z-index: -1 !important; /* Important might be needed depending on Vanta's internal styles */
       position: absolute !important;
       top: 0;
       left: 0;
       width: 100% !important;
       height: 100% !important;
    }


    .sidebar {
      width: 60px;
      position: fixed; /* Use fixed for positioning relative to viewport */
      top: 0;
      left: -60px;
      height: 100%;
      background-color: var(--sidebar-dark); /* Use variable */
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem 0;
      gap: 1.5rem;
      transition: left var(--transition-speed) ease;
      z-index: 10; /* Sidebar needs to be above Vanta */
    }

    .sidebar.open {
      left: 0;
    }

    .icon {
      color: var(--text-muted); /* Use variable */
      font-size: var(--icon-size);
      padding: 10px;
      border-radius: var(--border-radius);
      transition: background 0.2s;
      cursor: pointer;
      position: relative;
    }

    .icon:hover, .icon.active {
      background-color: var(--accent); /* Use variable */
      color: white; /* Or var(--text-light) if you want icon hover color to change */
    }

    .tooltip {
      position: fixed;
      background-color: var(--accent); /* Use variable */
      color: white; /* Or var(--text-light) */
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.8rem;
      pointer-events: none;
      z-index: 9999;
      display: none;
    }

    .content {
      flex: 1;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      /* Removed align-items: center; to allow flexible layout */
      overflow-y: auto;
      margin-left: 0; /* Adjust margin since sidebar is fixed */
      transition: margin-left var(--transition-speed) ease;
      z-index: 5; /* Content above Vanta */
      position: relative; /* Needed for z-index */
      background-color: transparent; /* Let Vanta show through */
      width: 100%; /* Ensure content takes full width */
      box-sizing: border-box;
      color: var(--text-light); /* Ensure text color is set for the content area */
    }

    .sidebar.open ~ .content {
        margin-left: 60px; /* Push content when sidebar is open */
    }


    h1 {
      margin-bottom: 2rem;
    }

    .panel {
        /* Existing styles */
        padding: 1.5rem; /* This is a good starting point, maybe increase slightly if content feels cramped */
        margin: 1rem auto; /* Use auto for left/right margin to center the block if it has a max-width */
        max-width: 800px; /* Example: Give panels a max-width to prevent them from stretching too wide on large screens */
        width: 95%; /* Ensure responsiveness */
        box-shadow: 0 4px 15px rgba(0,0,0,0.2); /* Existing shadow */
        background-color: var(--card-bg); /* Use variable */
        border-radius: var(--border-radius);
        box-sizing: border-box;
        color: var(--text-light); /* Ensure text color is set for the panel */
    }

    .panel-container {
      display: flex;
      flex-direction: column; /* Stack panels vertically */
      gap: 1rem; /* Adjust gap between panels */
      flex-wrap: wrap;
      justify-content: flex-start; /* Align panels to the start */
      opacity: 1;
      transition: opacity var(--transition-speed) ease;
      width: 100%; /* Ensure container takes width */
       align-items: center; /* Center panels horizontally */
    }

    .panel-container.fade-out {
      opacity: 0;
    }

    .panel h2 {
        margin-top: 0; /* Remove top margin from the first element */
        margin-bottom: 1rem; /* Space below the heading */
        color: var(--accent); /* Use accent for headings */
    }

    .panel h3 {
         margin-top: 1.5rem; /* Space above subheadings */
         margin-bottom: 0.8rem; /* Space below subheadings */
         color: var(--text-light); /* Or var(--accent) */
    }

    .panel p {
        margin-bottom: 1em; /* Space below paragraphs */
         color: var(--text-muted); /* Use variable for paragraph text */
    }

    input[type="text"] {
      background: var(--card-bg); /* Use variable */
      border: 1px solid var(--accent); /* Use variable */
      padding: 0.5rem;
      width: 100%; /* Take full width of parent */
      margin-bottom: 0.5rem;
      color: var(--text-light); /* Use variable */
      border-radius: 5px;
      transition: border var(--transition-speed) ease;
      box-sizing: border-box; /* Include padding and border in element's total width */
       height: var(--search-height); /* Use defined height */
       font-size: 1rem; /* Adjust font size */
       padding-left: calc(0.5rem + 24px); /* Space for search icon */
    }

    input[type="text"]:focus {
      outline: none;
      border-color: var(--text-light); /* Use variable */
    }

    button {
      background-color: var(--accent); /* Use variable */
      color: black; /* Changed for better contrast on accent, or use var(--bg-dark) */
      border: none; /* Removed border */
      padding: 0.5rem 1rem;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      transition: all var(--transition-speed) ease;
    }

    button:hover {
      filter: brightness(1.2); /* Brighter accent on hover */
      box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Slight shadow on hover */
    }


    .game-card, .action-card {
      background-color: var(--card-bg); /* Use variable */
      border-radius: 10px;
      padding: 1rem;
      text-align: center;
      cursor: pointer;
      transition: transform 0.2s;
      width: 150px;
      position: relative;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2); /* Add shadow */
    }

    .game-card:hover, .action-card:hover {
      transform: scale(1.05);
    }

    .game-card img {
      width: 100%;
      border-radius: var(--border-radius);
      margin-bottom: 0.5rem;
    }

    .iframe-container {
      position: absolute;
      top: 0;
      left: 0; /* Starts from the very left */
      right: 0;
      bottom: 60px; /* Space for bottom controls */
      display: flex;
      justify-content: center;
      align-items: center;
       width: 100%; /* Take full width */
       height: calc(100% - 60px); /* Adjust height */
       z-index: 20; /* Above sidebar and content when viewing */
       background: var(--bg-dark); /* Background for iframe view */
    }

    .iframe-container iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    .bottom-controls {
      position: fixed; /* Fixed to bottom */
      bottom: 0;
      left: 0; /* Starts from the very left */
      right: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 10px;
      background-color: var(--bg-dark); /* Use variable */
      border-top: 1px solid #444; /* Keep static or make a variable */
      z-index: 25; /* Above iframe */
      box-sizing: border-box;
    }


    .bottom-controls input[type="text"] {
      flex: 1;
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #ccc; /* Keep static or make a variable */
      margin-right: 10px;
      background-color: var(--card-bg); /* Use variable */
      color: var(--text-light); /* Use variable */
    }

    .bottom-controls button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      background-color: var(--accent); /* Use variable */
      color: black; /* Changed color, or use var(--bg-dark) */
    }
    .bottom-controls button:hover {
       filter: brightness(1.2);
    }


    .fullscreen-button i {
      margin-right: 5px;
    }

    .bottom-icons {
      margin-top: auto;
      border-top: 1px solid #444; /* Keep static or make a variable */
      padding-top: 1rem;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .bottom-icons .icon {
      margin-top: 1rem;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7); /* Keep static or make a variable */
      z-index: 100;
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background-color: var(--card-bg); /* Use variable */
      padding: 2rem;
      border-radius: var(--border-radius);
      width: 300px;
      position: relative;
      box-shadow: 0 5px 20px rgba(0,0,0,0.3); /* Keep static or make a variable */
    }

    .modal-close {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: var(--text-muted); /* Use variable */
      font-size: var(--icon-size);
      cursor: pointer;
    }

    .modal-close:hover {
      color: white; /* Or var(--text-light) */
    }

    .modal-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 1rem;
    }

    .games-container {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem; /* Increased gap */
        justify-content: center;
        padding: 1rem; /* Add padding */
        width: 100%; /* Take full width */
    }

    .games-header {
      display: flex;
      justify-content: center;
      gap: 1rem;
      width: 100%;
      margin-bottom: 1rem;
    }

    .remove-game {
      margin-top: 1rem;
      background-color: #ff4444; /* Keep specific color or make a variable */
      color: white;
      font-weight: bold;
      width: 100%;
    }

    .remove-icon {
      position: absolute;
      top: 5px;
      right: 5px;
      color: #ff4444; /* Keep specific color or make a variable */
      background: rgba(0,0,0,0.7); /* Keep static or make a variable */
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      cursor: pointer;
      z-index: 2;
      transition: background 0.2s, color 0.2s;
    }

    .remove-icon:hover {
      background: #ff4444; /* Keep specific color or make a variable */
      color: white;
    }


    .game-card.dragging {
      opacity: 0.5;
      transform: scale(0.95);
    }

    .game-card-placeholder {
      border: 2px dashed #444; /* Keep static or make a variable */
      background-color: transparent;
    }

    .theme-option {
      width: 50px;
      height: 50px;
      margin: 5px;
      cursor: pointer;
      transition: transform 0.2s, border-color 0.2s; /* Smooth transition */
    }

    .theme-option:hover {
      transform: scale(1.1);
       border-color: rgba(255, 255, 255, 0.5); /* Subtle border on hover */
    }

    .theme-option.selected {
      border-color: var(--accent); /* Use variable */
      transform: scale(1.1);
    }

    .theme-selector {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 1rem;
    }

    .theme-default-preview { background: linear-gradient(135deg, #1c1c1e 50%, #2c2c2e 50%); }
    .theme-cyberpunk-preview { background: linear-gradient(135deg, #0f0f1a 50%, #1a1a2e 50%); }
    .theme-sunset-preview { background: linear-gradient(135deg, #2c1a1a 50%, #4a2c2c 50%); }
    .theme-forest-night-preview { background: linear-gradient(135deg, #0d1a0b 50%, #1a2e17 50%); }
    .theme-midnight-sky-preview { background: linear-gradient(135deg, #1a1c2e 50%, #2b2e4a 50%); }
    .theme-volcano-preview { background: linear-gradient(135deg, #3a0d0d 50%, #5f1c1c 50%); }
    .theme-arctic-preview { background: linear-gradient(135deg, #0a1a1c 50%, #1c3a3d 50%); }
    .theme-grayscale-preview { background: linear-gradient(135deg, #1c1c1c 50%, #2c2c2c 50%); }
    .theme-sunny-preview { background: linear-gradient(135deg, #4a3a1a 50%, #6a4a1a 50%); }
    .theme-marine-preview { background: linear-gradient(135deg, #0f2a3a 50%, #1a3c4a 50%); }
    .theme-swamp-preview { background: linear-gradient(135deg, #2b2b1c 50%, #3a3a2a 50%); }
      
    .favorite-button {
      background-color: transparent;
      color: var(--text-muted); /* Use muted text color variable */
      border: none;
      padding: 5px 8px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: all 0.2s;
    }

    .favorite-button:hover {
      background-color: rgba(255,255,255,0.1); /* Keep static or make a variable */
      color: var(--text-light); /* Lighten on hover using variable */
    }
     .favorite-button i.fa-star { /* Style filled star */
        color: var(--accent); /* Use variable */
     }


    #librarySearch {
        margin: 1rem auto; /* Add margin */
        display: block;
        width: 80%;
        max-width: 400px; /* Max width */
    }

    .library-item {
      position: relative;
      padding: 4px 12px;
      border-radius: 6px;
      transition: all 0.2s ease;
      width: 90%;
      margin: 4px auto;
      background-color: var(--card-bg); /* Use variable */
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 30px;
      min-height: 30px;
      box-sizing: border-box;
      overflow: hidden;
    }

    .library-item-content {
      flex: 1;
      text-align: left; /* Align left */
      padding: 0 35px 0 25px; /* Adjust padding for icons */
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 0.9rem;
      border-radius: 4px;
      transition: all 0.2s ease;
      color: var(--text-light); /* Ensure text is visible using variable */
    }

    .library-item:hover {
       background-color: var(--sidebar-dark); /* Darker background on hover using variable */
    }

    .library-item:hover .library-item-content {
       color: var(--accent); /* Accent color for text on hover using variable */
       background-color: transparent; /* Remove background change */
     }


    .library-item .remove-icon {
      position: absolute;
      left: 6px;
      top: 50%; /* Center vertically */
      transform: translateY(-50%); /* Center vertically */
      color: var(--text-muted); /* Use variable */
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s;
      z-index: 2;
    }

    .library-item:hover .remove-icon {
       color: #ff4444; /* Red remove icon on hover - keep static or make variable */
       background: rgba(255, 68, 68, 0.2); /* Slight red background - keep static or make variable */
    }


    .favorite-transition {
      opacity: 0;
      transition: opacity var(--transition-speed) ease;
    }

    .favorite-transition.show {
      opacity: 1;
    }

    .action-card i {
      font-size: 2rem;
      margin-bottom: 0.5rem;
      color: var(--accent); /* Use variable */
    }

    .action-card p {
      margin: 0;
       color: var(--text-muted); /* Muted text for actions using variable */
    }
     .action-card:hover p {
        color: var(--text-light); /* Lighten text on hover using variable */
     }

    .library-columns {
      display: flex;
      flex-wrap: wrap; /* Allow wrapping on smaller screens */
      gap: 2rem;
      justify-content: center;
      width: 100%;
    }

    .library-column {
      flex: 1;
      min-width: 250px; /* Min width before wrapping */
      max-width: 45%;
    }

    .library-column h3 {
      text-align: center;
      margin-bottom: 1rem;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--accent); /* Use variable */
      color: var(--accent); /* Accent color for headings using variable */
    }
    /* Add specific styling for changelog modal content */
    #changelogContent {
        background-color: var(--bg-dark); /* Match theme background */
        color: var(--text-light); /* Match theme text color */
        padding: 1rem;
        border-radius: var(--border-radius);
        max-height: 60vh;
        max-width: 900px;/* Limit height */
        overflow-y: auto; /* Allow scrolling */
        border: 1px solid var(--sidebar-dark); /* Subtle border using variable */
    }

    /* --- Home Page Specific Styles --- */
    .home-bottom-section {
        display: flex; /* Use flexbox to place news and game button side-by-side */
        justify-content: space-between; /* Push items to the ends */
        align-items: flex-start; /* Align items to the top */
        gap: 20px; /* Space between news and game button */
        width: 95%; /* Match the width of the news panel */
        max-width: 1100px; /* Adjust max-width as needed to accommodate both */
        margin: 0 auto; /* Center the section */
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
    }

    .home-layout {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%; /* Take full height of content container */
        position: relative; /* Needed for absolute positioning of middle section */
        align-items: center; /* Center items horizontally by default */
        overflow-y: auto; /* Allow scrolling if content exceeds height */
        padding-top: 20px; /* Add some space at the top */
    }

    .home-header {
        width: 100%;
        text-align: center; /* Center the logo */
        margin-bottom: 20px; /* Space below the logo */
    }

    .home-logo {
        font-size: 3rem; /* Large font size for the name */
        font-weight: bold;
        color: var(--text-light); /* Ensure name is bright using variable */
        text-shadow: 0 0 10px var(--accent); /* Optional: glow effect using variable */
    }

    .home-main-section {
        display: flex;
        align-items: center;
        justify-content: center; /* Center the items horizontally */
        gap: 20px; /* Space between items */
        margin-bottom: 30px; /* Space below this section */
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
    }

    .home-search-container {
        display: flex;
        align-items: center;
        position: relative; /* For search icon */
        flex-grow: 1; /* Allow search to take available space */
        max-width: 400px; /* Limit max width */
    }

    .home-search-container input[type="text"] {
        flex-grow: 1; /* Allow input to fill space */
        padding-left: calc(1rem + 24px); /* Adjust padding for icon */
    }

    .home-search-container .search-icon {
        position: absolute;
        left: 10px;
        color: var(--text-muted); /* Use variable */
        font-size: 1.2rem;
        height: var(--search-height); /* Match search height */
        display: flex;
        align-items: center; /* Vertically center icon */
    }

    .home-status {
        color: var(--text-muted); /* Use variable */
        font-size: 0.9rem;
        display: flex; /* Use flexbox for status items */
        gap: 15px; /* Space between status items */
    }

    .home-status p {
        margin: 0; /* Remove default paragraph margin */
    }


    .home-news-panel {
        width: 95%; /* Adjust width as needed */
        max-width: 800px; /* Limit max width */
        margin: 0 auto; /* Center the news panel */
        flex-shrink: 0; /* Prevent shrinking */
        flex: 2;
        min-width: 300px;
    }

     /* Explicitly set color for the pre tag containing news content */
    #news-content {
        color: var(--text-light); /* Ensure news content text uses the light text color variable */
    }


    .game-of-day-container {
        flex: 1; /* Allow the game container to take remaining space */
        min-width: 180px; /* Minimum width for the game container */
        max-width: 200px; /* Maximum width for the game container */
        display: flex; /* Use flex to center the button */
        flex-direction: column; /* Stack content vertically if needed */
        align-items: center; /* Center button horizontally */
        padding: 1.5rem; /* Add padding similar to panels */
        background-color: var(--card-bg); /* Use card background variable */
        border-radius: var(--border-radius); /* Use defined radius */
        box-shadow: 0 4px 15px rgba(0,0,0,0.2); /* Add shadow */
         text-align: center; /* Center text inside */
         box-sizing: border-box; /* Include padding in width */
    }

     .game-of-day-container h3 {
         margin-top: 0;
         margin-bottom: 1rem;
         color: var(--accent); /* Use variable */
     }


    .game-of-day-button {
        /* Inherit styles from game-card but maybe adjust size */
        background-color: var(--card-bg); /* Use variable */
        border-radius: 10px;
        padding: 1rem;
        text-align: center;
        cursor: pointer;
        transition: transform 0.2s;
        width: 100%; /* Take full width of its container */
        position: relative;
        box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        box-sizing: border-box; /* Include padding in width */
         /* Ensure flex properties don't conflict if container is flex */
         flex-shrink: 0;
         flex-grow: 0;
         margin: 0; /* Remove margin if inheriting from game-card */
    }

     .game-of-day-button:hover {
        transform: scale(1.05);
     }

     .game-of-day-button img {
        width: 100%;
        border-radius: var(--border-radius);
        margin-bottom: 0.5rem;
     }
      .game-of-day-button p {
          margin: 0;
          color: var(--text-light); /* Use variable */
          font-weight: bold;
      }

    .changelog-button {
        background-color: var(--accent); /* Use the theme's accent color variable */
        color: black; /* Set text color to black for contrast on the accent color */
        border: none; /* Remove the border */
        padding: 0.5rem 1rem;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: all var(--transition-speed) ease;
        display: flex; /* Use flexbox to align the icon and text */
        align-items: center; /* Vertically center the icon and text */
        gap: 5px; /* Add a small gap between the icon and the text */
    }

    .changelog-button:hover {
        filter: brightness(1.2); /* Make the button slightly brighter on hover */
        box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Add a subtle shadow on hover */
    }
/* Updated styles for Settings Grid Layout */
/* Updated styles for Settings Grid Layout */
 .settings-grid-container {
     display: grid;
     grid-template-columns: repeat(3, 1fr); /* Exactly 3 equal columns */
     gap: 1.5rem; /* Space between grid items */
     padding: 1rem; /* Add some padding around the grid */
     max-width: 900px; /* Limit the maximum width of the grid */
     margin: 0 auto; /* Center the grid */
     /* Add responsiveness: Below a certain width, allow fewer columns */
     @media (max-width: 900px) {
         grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /* Adjust min width as needed */
         max-width: none; /* Allow it to take more width on smaller screens */
     }
      @media (max-width: 550px) { /* Further adjust for very small screens */
          grid-template-columns: 1fr; /* Single column */
      }
 }

.settings-grid-item {
    background-color: var(--card-bg); /* Use variable */
    border-radius: var(--border-radius);
    padding: 1.5rem; /* Adjust padding as needed */
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    display: flex; /* Use flexbox for content within the item */
    flex-direction: column; /* Stack content vertically */
    /* Removed justify-content: space-between; to allow content to flow naturally */
    /* Removed aspect-ratio for more horizontal flexibility */
    box-sizing: border-box; /* Include padding in the size */
    text-align: center; /* This centers the text inside */
    height: 100%; /* Ensure items in the same row have equal height */
}

.settings-grid-item h2 {
     margin-top: 0;
     margin-bottom: 1rem;
     color: var(--accent); /* Use variable */
     font-size: 1.2rem;
     /* Removed margin-right: 60px; */
     text-align: center; /* Ensure the h2 content itself is centered */
 }

 .settings-grid-item h3 {
      color: var(--text-light); /* Use variable */
      margin-top: 0.8rem; /* Space above subheadings */
      margin-bottom: 0.5rem;
      font-size: 1rem; /* Adjust subheading size */
 }

    .settings-grid-item p {
        font-size: 0.9rem;
        color: var(--text-muted); /* Use variable */
        margin-bottom: 0.8rem;
        flex-grow: 1; /* Add this line to make the paragraph take up available space */
    }

   .settings-grid-item button {
       margin-top: 0.8rem; /* Add margin above buttons */
       width: 100%; /* Make buttons full width */
   }

   .settings-grid-item input[type="text"],
   .settings-grid-item select {
        width: 100%;
        margin-bottom: 0.8rem;
        box-sizing: border-box;
         padding: 0.5rem; /* Add padding */
         background-color: var(--bg-dark); /* Darker background using variable */
         color: var(--text-light); /* Light text using variable */
         border: 1px solid var(--sidebar-dark); /* Subtle border using variable */
         border-radius: 5px;
   }

    /* Specific adjustments for Theme Selector within grid item */
    .settings-grid-item .theme-selector {
        justify-content: center; /* Center theme options */
        flex-wrap: wrap;
        gap: 5px; /* Adjust gap for smaller icons */
        margin-top: 0.5rem;
        flex-grow: 1; /* Allow theme selector to take up space */
         align-items: center; /* Center vertically if space available */
    }

    .settings-grid-item .theme-option {
        width: 40px; /* Smaller size for theme options in grid */
        height: 40px;
         margin: 0; /* Remove margin defined elsewhere */
    }

     /* Style for the select dropdown arrow */
    .settings-grid-item select {
        -webkit-appearance: none; /* Remove default arrow */
        -moz-appearance: none;
        appearance: none;
        /* The fill color in the SVG is calculated based on --text-light */
        background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.362%22%20height%3D%22292.362%22%3E%3Cpath%20fill%3D%22%23${encodeURIComponent(getComputedStyle(document.documentElement).getPropertyValue('--text-light').trim().substring(1))}%22%20d%3D%22M287.9%20197.2c.9%201.3%201.1%202.9.8%204.3s-1.3%202.6-2.6%203.5l-124.5%20124.5c-1.8%201.8-4.3%202.9-7.4%202.9s-5.7-1.1-7.4-2.9l-124.7-124.7c-1.8-1.8-2.9-4.1-2.9-6.3s1.1-4.5%202.9-6.3l20.8-20.8c1.9-1.9%204.5-3%207.8-3%203.3%200%205.9%201.1%207.8%203l96.8%2096.7%2096.7-96.7c1.9-1.9%204.5-3%207.8-3%203.2%200%205.8%201.1%207.8%203l20.8%2020.8z%22%2F%3E%3C%2Fsvg%3E');
        background-repeat: no-repeat;
        background-position: right 0.7em top 50%, 0 0;
        background-size: 0.65em auto, 100%;
    }

    /* Style for individual setting reset buttons */
/* Style for individual setting reset buttons */
    .setting-reset-button {
        background-color: #666; /* Grey background - keep static or make variable */
        color: white;
        padding: 0.3rem 0.6rem; /* Smaller padding */
        font-size: 0.8rem;     /* Smaller font size */
        border-radius: 4px;
        border: none;
        cursor: pointer;
        transition: background-color 0.2s;
        /* Use margin-top: auto to push the button to the bottom in the flex column */
        margin-top: auto;
        /* Ensure it is a block element to take up its own line and center horizontally */
        display: block;
        /* Center horizontally within the flex item */
        margin-left: auto;
        margin-right: auto;
        /* Optional: set a specific width if not 100% */
        width: fit-content; /* Adjust width based on content */
    }

    .setting-reset-button:hover {
        background-color: #888; /* Lighter grey on hover - keep static or make variable */
    }

    /* Adjust grid item padding if needed to accommodate buttons */
    .settings-grid-item {
         position: relative; /* Needed for absolute/float positioning inside */
         padding-bottom: 3rem; /* Add more bottom padding if buttons overlap */
     }
    .settings-grid-item h2 {
         margin-top: 0;
         margin-bottom: 1rem;
         color: var(--accent); /* Use variable */
         font-size: 1.2rem; /* Adjust heading size */
         /* Removed margin-right: 60px; */
         text-align: center; /* Ensure the title text is centered */
     }


    /* --- Update Overlay Styles --- */
    .update-overlay {
        display: none; /* Hidden by default */
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8); /* Semi-transparent dark background */
        z-index: 200; /* Ensure it's above other elements like modals */
        justify-content: center;
        align-items: center;
        backdrop-filter: blur(5px); /* Optional: Add a blur effect */
    }
    
    .update-message-box {
        background-color: var(--card-bg);
        padding: 2rem;
        border-radius: var(--border-radius);
        text-align: center;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
        /* Keep the increased max-width to help with horizontal text flow */
        max-width: 350px; /* Or your preferred wider value */
        width: 90%;
        color: var(--text-light);
    }
    
    .update-message-box h2 {
        margin-top: 0;
        color: var(--accent);
        margin-bottom: 1rem;
    }
    
    .update-message-box button {
        margin-top: 0.5rem;
        padding: 0.5rem 1rem; /* Button size adjustments */
        font-size: 1rem;
         margin-right: 0 !important; /* Ensure no extra margin on buttons */
         margin-top: 0;
    }
    
    /* Optional: Style for disabled download button */
    .update-message-box button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
      
    .update-options-container {
        margin-top: 1.5rem;
        display: flex;
        flex-direction: column; /* Stack the options vertically */
        /* Increase the gap to add more vertical space between options */
        gap: 20px; /* Increased gap */
        align-items: center; /* Center items horizontally */
    }
    
    .update-option {
        display: flex;
        /* Change direction to stack items vertically */
        flex-direction: column;
        /* Center items horizontally within the column */
        align-items: center;
        gap: 5px; /* Reduce gap since items are now stacked */
        /* Remove flex-wrap as items are explicitly stacked */
        /* flex-wrap: wrap; */
        /* Ensure the whole option is centered or takes appropriate width */
        width: 100%; /* Allow the option container to take full width within its parent */
    }

    
    .update-option button {
        /* Keep button size adjustments */
        padding: 0.5rem 1rem;
        font-size: 1rem;
        margin: 0 !important; /* Remove all margins to control spacing with gap */
         width: auto; /* Ensure button doesn't stretch to full width */
    }
    
    .update-option p {
        margin: 0; /* Remove default paragraph margin */
        font-size: 0.9rem;
        color: var(--text-muted);
        /* Remove flex-grow as text is now below the button */
        /* flex-grow: 1; */
        /* Center the text itself */
        text-align: center;
         max-width: 100%; /* Ensure text doesn't overflow if very long */
         box-sizing: border-box; /* Include padding/border in width */
    }

    /* --- Sliding Notification Styles --- */
    .sliding-notification {
        background-color: var(--card-bg); /* Use theme card background */
        color: var(--text-light); /* Use theme text color */
        padding: 1rem 1.5rem; /* Adjust padding as needed */
        border-radius: var(--border-radius);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        word-wrap: break-word; /* Prevent long words from overflowing */
        overflow-wrap: break-word; /* Standard property */
        opacity: 0; /* Start hidden */
        transform: translateX(120%); /* Start off-screen to the right */
        transition: transform 0.5s ease-out, opacity 0.5s ease-out; /* Animation */
        pointer-events: auto; /* Allow clicks on the notification itself */
        position: relative; /* Needed for progress bar positioning */
        /* Initial display state will be handled by JS setting display: block/none */
        display: none;
    }
    
    .sliding-notification.show {
        opacity: 1; /* Fade in */
        transform: translateX(0); /* Slide in to position */
    }

    .sliding-notification h3 {
        margin-top: 0;
        margin-bottom: 0.5rem; /* Space below the title */
        color: var(--accent); /* Use theme accent color for title */
        font-size: 1.1rem;
    }

    .sliding-notification div { /* Styling for the body content */
        font-size: 0.9rem;
        line-height: 1.4;
        color: var(--text-muted); /* Muted text for body */
        /* Styling to match news text (from your <pre id="news-content"> styles) */
        white-space: pre-wrap; /* Allow wrapping but preserve line breaks */
        font-family: inherit; /* Use the same font as the rest of the body */
        text-align: left; /* Left-align the text */
         margin-top: 0.5rem; /* Add some space above the body */
    }

    .notification-progress-bar {
        position: absolute;
        bottom: 0; /* Position at the bottom edge */
        left: 0; /* Start from the left edge */
        width: 100%; /* Start with the bar fully visible */
        height: 4px; /* Set the height of the progress line */
        background-color: var(--accent); /* Use the theme's accent color */
        /* Define the transition for the width property */
        transition-property: width;
        /* Use linear timing for steady progress. Duration set by JS. */
        transition-timing-function: linear;
        /* Ensure the border radius doesn't clip the corners if parent has one */
        border-bottom-left-radius: var(--border-radius);
        border-bottom-right-radius: var(--border-radius);
    }

    /* Style for individual notification close button */
     .notification-close-button {
         position: absolute;
         top: 5px;
         right: 5px;
         background: none;
         border: none;
         color: var(--text-muted);
         font-size: 0.8rem; /* Smaller close button */
         cursor: pointer;
         z-index: 1; /* Above text/progress bar */
         padding: 0; /* Remove padding */
         width: 20px; /* Make it a small square clickable area */
         height: 20px;
         display: flex;
         align-items: center;
         justify-content: center;
         border-radius: 50%; /* Make it round */
         transition: color 0.2s, background-color 0.2s;
     }

     .notification-close-button:hover {
         color: var(--text-light);
         background-color: rgba(255, 255, 255, 0.1); /* Subtle hover effect */
     }

    #notificationContainer {
        position: fixed;
        top: 20px; /* Distance from the top */
        right: 20px; /* Distance from the right */
        z-index: 150; /* Ensure it's above content but below main overlays */
        display: flex;
        flex-direction: column; /* Stack notifications vertically */
        gap: 10px; /* Space between stacked notifications */
        max-width: 300px; /* Limit the width of the container */
        pointer-events: none; /* Allow clicks to pass through the container */
    }

        /* Music Player Specific Layout */
    .music-player-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: var(--padding, 15px); /* Use app padding or default */
        width: 100%;
        /* Adjust height if needed, or let it grow naturally */
        /* max-height: calc(100vh - 180px); /* Example: Limit height if needed */
        overflow: hidden; /* Prevent grid from overflowing content area */
        padding-bottom: 80px; /* Space for fixed controls bar if needed */
    }
    
    .music-box {
        background-color: var(--card-bg); /* Use theme card background */
        border-radius: var(--border-radius);
        padding: var(--padding, 15px); /* Use app padding or default */
        display: flex;
        flex-direction: column;
        overflow: hidden; /* Prevent content overflow */
        color: var(--text-light); /* Ensure text color */
        box-shadow: 0 4px 10px rgba(0,0,0,0.2); /* Match panel shadow */
        min-height: 200px; /* Give boxes some minimum height */
    }
    
    .music-box h2 {
        margin-top: 0;
        margin-bottom: 10px;
        color: var(--accent); /* Use theme accent */
        font-size: 1.2em;
    }
    .music-box h4 { /* Style for subsection headings in modals */
         margin-top: 15px;
         margin-bottom: 5px;
         color: var(--text-light);
         font-size: 1em;
         border-bottom: 1px solid var(--text-muted);
         padding-bottom: 3px;
     }
    
    .music-box p {
        font-size: 0.9em;
        color: var(--text-muted); /* Use theme muted text */
        margin-bottom: 15px;
    }
    
    .scrollable-list {
        flex-grow: 1;
        overflow-y: auto;
        margin-top: 10px;
        padding-right: 5px; /* Space for scrollbar */
        min-height: 100px; /* Min height for list areas */
    }
    
    /* Custom Scrollbar using Theme Variables */
    .scrollable-list::-webkit-scrollbar {
        width: 8px;
    }
    .scrollable-list::-webkit-scrollbar-track {
        background: rgba(0,0,0,0.1);
        border-radius: 4px;
    }
    .scrollable-list::-webkit-scrollbar-thumb {
        background-color: var(--text-muted);
        border-radius: 4px;
    }
    .scrollable-list::-webkit-scrollbar-thumb:hover {
        background-color: var(--accent);
    }
    
    .list-item {
        padding: 8px 10px;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 5px;
        background-color: rgba(0, 0, 0, 0.1); /* Subtle dark background */
        transition: background-color var(--transition-speed);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-size: 0.95em;
        color: var(--text-light); /* Ensure text color */
    }
    
    .list-item:hover {
        background-color: rgba(255, 255, 255, 0.1); /* Lighter on hover */
        color: var(--accent); /* Accent text on hover */
    }
    
    .list-item.playing {
        background-color: var(--accent); /* Use theme accent */
        color: var(--bg-dark); /* Use theme dark for contrast */
        font-weight: bold;
    }
    .list-item.playing:hover {
         color: var(--bg-dark); /* Keep text color dark on hover when playing */
    }
    
    
    .list-item .playlist-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .list-item .playlist-controls button {
        background: none;
        border: none;
        color: var(--text-light);
        cursor: pointer;
        font-size: 1em;
        margin-left: 8px;
        padding: 2px 5px;
    }
     .list-item .playlist-controls button:hover {
         color: var(--accent);
     }
    
    /* Make Music Player buttons use theme button styles */
    .music-box button, #mp_playback_controls button, .mp-modal-content button {
         /* Inherit general button styles from main app */
    }
    /* Style secondary buttons */
    .music-box button.secondary, .mp-modal-content button.secondary {
         background-color: #555;
         color: var(--text-light);
    }
    .music-box button.secondary:hover, .mp-modal-content button.secondary:hover {
         background-color: #777;
         filter: none;
    }
    
    /* Style inputs to match theme */
    .music-box input[type="text"],
    .music-box input[type="search"],
    .mp-modal-content input[type="text"] {
         /* Inherit general input styles from main app */
         background: var(--card-bg); /* Use card background */
         border: 1px solid var(--accent); /* Accent border */
         color: var(--text-light); /* Light text */
         padding: 0.5rem; /* Add padding if not inherited */
          box-sizing: border-box; /* Include padding and border in element's total width */
          width: 100%; /* Ensure it takes full width of its container */
          margin-bottom: 10px; /* Add some space below it */
          border-radius: 5px; /* Match other inputs */
           height: var(--search-height); /* Use defined height */
           font-size: 1rem; /* Adjust font size */
           /* Remove or adjust padding-left if you don't need a search icon inside */
           /* padding-left: calc(0.5rem + 24px); /* Space for search icon */
    }
    .music-box input[type="text"]:focus,
    .music-box input[type="search"]:focus,
    .mp-modal-content input[type="text"]:focus {
          /* Inherit focus styles or define */
          border-color: var(--text-light); /* Light border on focus */
          outline: none;
    }
    
    
    /* Playback Controls Bar Styles (Adapted) */
    #mp_playback_controls { /* Target the specific ID */
        position: fixed;
        bottom: 0;
        left: 0; /* Keep this as the default for when sidebar is closed */
        width: 100%; /* Keep this as the default for when sidebar is closed */
        background-color: var(--sidebar-dark); /* Use sidebar dark for contrast */
        padding: 10px 15px; /* Use app padding or default */
        box-sizing: border-box;
        display: flex; /* Handled by JS, but ensure default is flex */
        align-items: center;
        gap: 15px;
        border-top: 1px solid #444;
        z-index: 90; /* Below modals but above content/sidebar */
        color: var(--text-light); /* Ensure text color */
         /* Add a transition for 'left' and 'width' */
        transition: left var(--transition-speed) ease, width var(--transition-speed) ease;
    }
    
    /* Add this new rule */
    .sidebar.open ~ #mp_playback_controls {
        left: 60px; /* Push the playback bar by the sidebar width */
        width: calc(100% - 60px); /* Reduce width by the sidebar width */
    }
    
    #mp_playback_controls .song-info {
        flex-basis: 200px;
        flex-shrink: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-size: 0.9em;
    }
    
    #mp_playback_controls .controls {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    #mp_playback_controls .controls button,
    #mp_playback_controls .volume-container button {
        background: none;
        border: none;
        color: var(--text-light);
        font-size: 1.3em;
        padding: 5px;
        cursor: pointer;
    }
    #mp_playback_controls .controls button:hover,
    #mp_playback_controls .volume-container button:hover {
        color: var(--accent); /* Use theme accent on hover */
        filter: none;
    }
    #mp_playback_controls .controls button:disabled {
         color: var(--text-muted);
         cursor: not-allowed;
         opacity: 0.5;
    }
    
    
    #mp_playback_controls .seek-bar-container {
        flex-grow: 1;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    #mp_playback_controls input[type="range"] {
        flex-grow: 1;
        cursor: pointer;
        height: 5px;
        background: #555;
        border-radius: 3px;
        -webkit-appearance: none;
        appearance: none;
    }
    #mp_playback_controls input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 14px;
        height: 14px;
        background: var(--accent); /* Use theme accent */
        border-radius: 50%;
        cursor: pointer;
    }
    #mp_playback_controls input[type="range"]::-moz-range-thumb {
         width: 14px;
         height: 14px;
         background: var(--accent);
         border-radius: 50%;
         cursor: pointer;
         border: none;
    }
    
    
    #mp_playback_controls .time-display {
        font-size: 0.85em;
        color: var(--text-muted); /* Use theme muted text */
        min-width: 45px; /* Reduced width */
        text-align: center;
    }
    
    #mp_playback_controls .volume-container {
        display: flex;
        align-items: center;
        gap: 5px;
    }
    
    #mp_playback_controls .volume-container button {
         font-size: 1.1em;
    }
    
    #mp_playback_controls .volume-container input[type="range"] {
        width: 80px;
        height: 4px;
    }
     #mp_playback_controls .volume-container input[type="range"]::-webkit-slider-thumb {
         width: 12px;
         height: 12px;
     }
     #mp_playback_controls .volume-container input[type="range"]::-moz-range-thumb {
          width: 12px;
          height: 12px;
     }
    
    #mp_playback_controls .volume-percentage {
         font-size: 0.8em;
         color: var(--text-muted);
         min-width: 30px;
         text-align: right;
    }
    
    
    /* Modal Styles (Adapted) */
    .mp-modal { /* Use a specific class for music player modals */
        display: none;
        position: fixed;
        z-index: 150; /* Above most content, maybe below update overlay */
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.6);
        justify-content: center;
        align-items: center;
    }
    
    .mp-modal-content {
        background-color: var(--card-bg); /* Use theme card background */
        margin: auto;
        padding: 20px;
        border: 1px solid var(--sidebar-dark); /* Use theme border */
        width: 90%;
        max-width: 500px;
        border-radius: var(--border-radius);
        position: relative;
        color: var(--text-light);
        display: flex;
        flex-direction: column;
        max-height: 80vh; /* Limit height */
    }
    
    .mp-modal-close {
        color: var(--text-muted);
        position: absolute;
        top: 10px;
        right: 15px;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
    }
    .mp-modal-close:hover,
    .mp-modal-close:focus {
        color: var(--accent); /* Use theme accent */
        text-decoration: none;
    }
    
    .mp-modal-content h3 {
         margin-top: 0;
         color: var(--accent);
    }
    
    .mp-modal-body {
         flex-grow: 1;
         overflow-y: auto;
         margin-bottom: 15px;
    }
    
    
    .mp-modal-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 10px;
        flex-shrink: 0;
    }
    
    /* Styles for lists within modals */
    #mp_removeSongsModalList .list-item,
    #mp_viewPlaylistModalList .list-item,
    #mp_createPlaylistSongList .list-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        background-color: rgba(0,0,0,0.2); /* Slightly different background for modal lists */
    }
    #mp_createPlaylistSongList .list-item {
         cursor: default !important;
         margin-bottom: 2px !important;
    }
    
    
    #mp_removeSongsModalList .list-item label,
    #mp_viewPlaylistModalList .list-item span,
    #mp_createPlaylistSongList .list-item label {
         flex-grow: 1;
         margin-left: 10px;
         overflow: hidden;
         text-overflow: ellipsis;
         white-space: nowrap;
         cursor: pointer;
     }
     #mp_removeSongsModalList input[type="checkbox"],
     #mp_createPlaylistSongList input[type="checkbox"] {
         flex-shrink: 0;
         margin-right: 8px;
          vertical-align: middle;
     }
    
    #mp_viewPlaylistModalList .list-item button {
         background: none;
         border: none;
         color: #ff6b6b;
         cursor: pointer;
         font-size: 0.9em;
         flex-shrink: 0;
         margin-left: 5px;
     }
     #mp_viewPlaylistModalList .list-item button:hover {
         color: #ff4f4f;
     }
    .placeholder-text {
         color: var(--text-muted);
         font-style: italic;
         text-align: center;
         margin-top: 20px;
     }



  </style>
</head>
<body class="theme-default"> <div class="tooltip" id="tooltip"></div>

  <div class="modal" id="addGameModal">
    <div class="modal-content">
      <button class="modal-close" onclick="closeModal()">&times;</button>
      <h2>Add New Game</h2>
      <input type="text" id="gameName" placeholder="Game Name" required>
      <input type="text" id="gameUrl" placeholder="Game URL" required>
      <input type="text" id="gameIcon" placeholder="Icon URL (optional)">
      <div class="modal-buttons">
        <button onclick="closeModal()">Cancel</button>
        <button onclick="addGame()">Add Game</button>
      </div>
    </div>
  </div>
    
    <div class="update-overlay" id="updateOverlay">
        <div class="update-message-box">
            <h2 id="updateTitle">New Update Available!</h2>
            <p id="updateMessage">A new version (vX.Y.Z) is available.</p> <div class="update-options-container">
                <div class="update-option">
                    <button id="reloadSiteButton">Reload Site</button>
                    <p>if you are on the website</p>
                </div>
                <div class="update-option">
                     <button id="downloadOfflineButton">Download Offline Version</button>
                     <p>if you are on a local version</p>
                </div>
            </div>
    
             <button id="updateCloseButton" style="margin-top: 1.5rem; background-color: #555; color: white;">Dismiss</button>
        </div>
    </div>

  <div class="modal" id="changelogModal">
    <div class="modal-content" style="max-width: 900px; max-height: 80vh;">
      <button class="modal-close" onclick="closeChangelogModal()">&times;</button>
      <h2>Changelog</h2>
      <pre id="changelogContent" style="white-space: pre-wrap; font-family: inherit;"></pre>
    </div>
  </div>

<div id="notificationContainer">
    </div>
    
  <div class="sidebar">
    <div class="icon active" data-page="Home" title="Home"><i class="fas fa-home"></i></div>
    <div class="icon" data-page="Library" title="Library"><i class="fas fa-book"></i></div>
    <div class="icon" data-page="Viewer" title="Viewer"><i class="fas fa-globe"></i></div>
    <div class="icon" data-page="Games" title="Games"><i class="fas fa-gamepad"></i></div>
    <div class="icon" data-page="Updater" title="Updater"><i class="fas fa-sync-alt"></i></div>
    <div class="icon" data-page="Music" title="Music"><i class="fas fa-music"></i></div>

    <div class="bottom-icons">
      <div class="icon" data-page="Settings" title="Settings"><i class="fas fa-cog"></i></div>
      <div class="icon" data-page="About" title="About"><i class="fas fa-info-circle"></i></div>
    </div>
  </div>
    
<audio id="mp_audioPlayer"></audio>

<div class="playback-controls" id="mp_playback_controls" style="display: none;"> <div class="song-info" id="mp_currentSongInfo">No Song Playing</div>
    <div class="controls">
        <button id="mp_prevButton" title="Previous"><i class="fas fa-step-backward"></i></button>
        <button id="mp_playPauseButton" title="Play"><i class="fas fa-play"></i></button>
        <button id="mp_nextButton" title="Next"><i class="fas fa-step-forward"></i></button>
    </div>
    <div class="seek-bar-container">
        <span class="time-display" id="mp_currentTime">0:00</span>
        <input type="range" id="mp_seekBar" value="0" step="0.1" max="100">
        <span class="time-display" id="mp_totalDuration">0:00</span>
    </div>
    <div class="volume-container">
        <button id="mp_muteButton" title="Mute"><i class="fas fa-volume-up"></i></button>
        <input type="range" id="mp_volumeSlider" min="0" max="1" step="0.01" value="1">
        <span class="volume-percentage" id="mp_volumePercentage">100%</span>
    </div>
</div>

<div id="mp_removeSongsModal" class="mp-modal"> <div class="mp-modal-content">
        <span class="mp-modal-close" onclick="mp_closeModal('mp_removeSongsModal')">&times;</span>
        <h3>Remove Songs</h3>
        <div class="mp-modal-body">
            <p>Select songs to remove permanently from the library.</p>
            <div class="scrollable-list" id="mp_removeSongsModalList" style="max-height: 300px;">
                </div>
        </div>
        <div class="mp-modal-buttons">
             <button class="secondary" onclick="mp_closeModal('mp_removeSongsModal')">Cancel</button>
             <button onclick="mp_removeSelectedSongs()">Remove Selected</button>
        </div>
    </div>
</div>

<div id="mp_createPlaylistModal" class="mp-modal"> <div class="mp-modal-content">
         <span class="mp-modal-close" onclick="mp_closeModal('mp_createPlaylistModal')">&times;</span>
         <h3>Create New Playlist</h3>
         <div class="mp-modal-body">
              <input type="text" id="mp_newPlaylistName" placeholder="Playlist Name">
              <h4>Add Songs (Optional):</h4>
              <div class="scrollable-list" id="mp_createPlaylistSongList" style="max-height: 200px; border: 1px solid var(--text-muted); padding: 5px;">
                 <p class="placeholder-text">Loading library...</p>
              </div>
         </div>
         <div class="mp-modal-buttons">
             <button class="secondary" onclick="mp_closeModal('mp_createPlaylistModal')">Cancel</button>
             <button onclick="mp_createNewPlaylist()">Create</button>
         </div>
     </div>
 </div>

 <div id="mp_viewPlaylistModal" class="mp-modal"> <div class="mp-modal-content">
         <span class="mp-modal-close" onclick="mp_closeModal('mp_viewPlaylistModal')">&times;</span>
         <h3 id="mp_viewPlaylistName">Playlist</h3>
         <div class="mp-modal-body">
              <div class="scrollable-list" id="mp_viewPlaylistModalList" style="max-height: 300px;">
                  </div>
         </div>
          <div class="mp-modal-buttons">
              <button class="secondary" onclick="mp_closeModal('mp_viewPlaylistModal')">Close</button>
              <button onclick="mp_deleteCurrentPlaylist()">Delete Playlist</button>
         </div>
     </div>
 </div>

  <div class="content">
    <h1 id="page-title" style="display: none;">UnderGr0und</h1>
    <div id="page-content" class="panel-container">
      </div>
  </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.fog.min.js"></script>

  <script>
    // DOM Elements
    const icons = document.querySelectorAll('.sidebar .icon');
    const pageTitle = document.getElementById('page-title');
    const pageContent = document.getElementById('page-content');
    const tooltip = document.getElementById('tooltip');
    const addGameModal = document.getElementById('addGameModal');
    const changelogModal = document.getElementById('changelogModal'); // Get changelog modal

    // App State
    let games = [];
    let library = [];
    let draggedItem = null;
    let draggedIndex = null;
    // Removed: let currentTheme = 'default'; // We will use currentThemeName instead
    let favoriteGames = [];
    let isSidebarOpen = false;
    let vantaEffect = null;
    let showingFavorites = false;
    let shownNotificationContentSet = new Set();
    let activeNotifications = {};
    let notificationEnabled = true; // Default is enabled
    let notificationDisplayDuration = 8000; // Default duration in milliseconds (8 seconds)
    
    // Define themes in an array
    const themes = [
      {
        name: 'default',
        previewClass: 'theme-default-preview', // Keep existing preview class for visual swatch
        variables: {
          '--bg-dark': '#1c1c1e',
          '--sidebar-dark': '#2c2c2e',
          '--text-light': '#fff',
          '--text-muted': '#aaa',
          '--card-bg': '#1a1a1a',
          '--accent': '#00ff84',
        }
      },
      {
          name: 'cyberpunk',
           previewClass: 'theme-cyberpunk-preview',
          variables: {
            '--bg-dark': '#0f0f1a',
            '--sidebar-dark': '#1a1a2e',
            '--text-light': '#e6e6ff',
            '--text-muted': '#b3b3ff',
            '--card-bg': '#1a1a2e',
            '--accent': '#ff00ff',
          }
        },
         {
          name: 'sunset', // <--- Sunset theme is now kept
          previewClass: 'theme-sunset-preview',
          variables: {
            '--bg-dark': '#2c1a1a',
            '--sidebar-dark': '#4a2c2c',
            '--text-light': '#fff0e0',
            '--text-muted': '#e0b0a0',
            '--card-bg': '#3a2222',
            '--accent': '#ff8844',
          }
        },
         {
           name: 'forest-night',
           previewClass: 'theme-forest-night-preview',
           variables: {
             '--bg-dark': '#0d1a0b',
             '--sidebar-dark': '#1a2e17',
             '--text-light': '#e0f2f1',
             '--text-muted': '#a7ffeb',
             '--card-bg': '#132611',
             '--accent': '#11661f',
           }
         },
         {
            name: 'midnight-sky',
            previewClass: 'theme-midnight-sky-preview',
            variables: {
                '--bg-dark': '#1a1c2e',
                '--sidebar-dark': '#2b2e4a',
                '--text-light': '#e0e0ff',
                '--text-muted': '#a0a0c0',
                '--card-bg': '#20233d',
                '--accent': '#7b68ee',
            }
         },
         // --- New Themes (Plum removed) ---
        {
           name: 'volcano',
           previewClass: 'theme-volcano-preview',
           variables: {
               '--bg-dark': '#3a0d0d',
               '--sidebar-dark': '#5f1c1c',
               '--text-light': '#fff0e0',
               '--text-muted': '#e0b0a0',
               '--card-bg': '#4a1414',
               '--accent': '#ff4500',
           }
        },
        {
           name: 'arctic',
           previewClass: 'theme-arctic-preview',
           variables: {
               '--bg-dark': '#0a1a1c',
               '--sidebar-dark': '#1c3a3d',
               '--text-light': '#e0ffff',
               '--text-muted': '#a0e0e0',
               '--card-bg': '#152a2c',
               '--accent': '#00ffff',
           }
        },
         {
            name: 'grayscale',
            previewClass: 'theme-grayscale-preview',
            variables: {
                '--bg-dark': '#1c1c1c',
                '--sidebar-dark': '#2c2c2c',
                '--text-light': '#ffffff',
                '--text-muted': '#cccccc',
                '--card-bg': '#202020',
                '--accent': '#808080',
            }
         },
         {
            name: 'sunny',
            previewClass: 'theme-sunny-preview',
            variables: {
                '--bg-dark': '#4a3a1a',
                '--sidebar-dark': '#6a4a1a',
                '--text-light': '#fffacd',
                '--text-muted': '#f0d8a0',
                '--card-bg': '#5a4a1a',
                '--accent': '#ffcc00',
            }
         },
        {
            name: 'marine', // <--- New Marine theme
            previewClass: 'theme-marine-preview',
            variables: {
                '--bg-dark': '#0f2a3a',      // Dark blue-green
                '--sidebar-dark': '#1a3c4a', // Darker blue-green
                '--text-light': '#e0f0ff',   // Pale blue
                '--text-muted': '#a0c0d0',   // Muted blue-gray
                '--card-bg': '#15303a',      // Dark blue-green for cards
                '--accent': '#00bfff',       // Deep sky blue
            }
         },
        {
            name: 'swamp',
            previewClass: 'theme-swamp-preview',
            variables: {
                '--bg-dark': '#2b2b1c',      // Dark greenish-brown
                '--sidebar-dark': '#3a3a2a', // Slightly lighter greenish-brown
                '--text-light': '#e0e6d8',   // Pale green-gray
                '--text-muted': '#a0b390',   // Muted green-brown
                '--card-bg': '#303020',      // Darker greenish-brown for cards
                '--accent': '#8a9a5b',       // Dull green
            }
         },
        {
            name: 'inverted-bw',
            previewClass: 'theme-inverted-bw-preview',
            variables: {
                '--bg-dark': '#e3e3e3', // Very light grey background
                '--sidebar-dark': '#d3d3d3', // Slightly darker light grey sidebar
                '--text-light': '#000000', // Black text
                '--text-muted': '#333333', // Dark grey muted text
                '--card-bg': '#dddddd', // Light grey card background
                '--accent': '#404040', // Dark grey accent
            }
        }
    ];

let currentThemeName = 'default'; // Store the name of the current theme

    // --- VANTA.JS HELPER ---
    // Function to convert CSS hex/rgb color to Vanta's number format
    function colorToVantaFormat(colorString) {
        if (!colorString) {
            console.warn("colorToVantaFormat received empty color string. Defaulting to black.");
            return 0x000000; // Default to black if color is missing
        }

        // Check if it's hex (e.g., #ff0000 or #f00)
        if (colorString.startsWith('#')) {
            let hex = colorString.substring(1);
            if (hex.length === 3) {
                hex = hex.split('').map(char => char + char).join('');
            }
            try {
                 return parseInt(`0x${hex}`);
            } catch (e) {
                 console.error(`Failed to parse hex color "${colorString}":`, e);
                 return 0x000000;
            }

        }

        // Check if it's rgb (e.g., rgb(255, 0, 0))
        const rgbMatch = colorString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (rgbMatch) {
            const r = parseInt(rgbMatch[1]);
            const g = parseInt(rgbMatch[2]);
            const b = parseInt(rgbMatch[3]);
            return (r << 16) + (g << 8) + b;
        }

        // Fallback for named colors or other formats (this is basic, might need improvement)
        try {
            // Use a temporary element to resolve named colors etc.
            const tempDiv = document.createElement('div');
            tempDiv.style.color = colorString;
            document.body.appendChild(tempDiv);
            const computedColor = getComputedStyle(tempDiv).color;
            document.body.removeChild(tempDiv);
            console.log(`Resolved named color "${colorString}" to "${computedColor}".`);
            return colorToVantaFormat(computedColor); // Recursively call with the resolved rgb/hex
        } catch (e) {
             console.warn(`Could not parse color: ${colorString}. Defaulting to black.`);
             return 0x000000;
        }
    }

    window.addEventListener('DOMContentLoaded', async () => { // Make listener async
        console.log('DOMContentLoaded fired. Starting application initialization...');
    
        // Load saved data from localStorage (theme, app settings, games, library, favorites) - Keep this
        loadData();
        console.log('App data loaded from localStorage.');
    
        // Load panic key settings from localStorage - Keep this
        loadPanicKeySettings();
        console.log('Panic key settings loaded.');
    
        // Load music player data ASYNCHRONOUSLY from IndexedDB
        await mp_loadDataFromDB(); // <-- Uses await for the IndexedDB loading
        console.log('Music Player data loaded from IndexedDB.');
    
        // Initialize Vanta.js background effect - Keep this block
        setTimeout(() => {
            console.log('Attempting to initialize Vanta.js...');
            initializeVanta();
            console.log('initializeVanta() called. Vanta effect:', vantaEffect);
    
            if (vantaEffect) {
                console.log('Calling setTheme with currentThemeName after Vanta initialization.');
                setTheme(currentThemeName);
            } else {
                console.warn('Vanta effect is null after initialization, cannot call setTheme to update Vanta options.');
            }
        }, 50); // Short delay
    
        // Initialize the Music Player Playback Bar - Keep this
        // Ensure this runs AFTER mp_loadDataFromDB which might load the last volume etc.
        mp_initializePlaybackBar();
        console.log('Music Player playback bar initialization called.');
    
        // Set up all general event listeners for user interactions - Keep this
        setupEventListeners();
        console.log('Event listeners set up.');
    
        // Switch to the initial page - Keep this
        // This will call mp_initializeMusicPlayerPage if needed, AFTER data is loaded
        switchPage(localStorage.getItem('lastActivePage') || 'Home');
        console.log('Initial page switched to:', localStorage.getItem('lastActivePage') || 'Home');
    
        // Setup Periodic Checks - Keep this block
        setInterval(checkVersion, 60000); // Check every 60 seconds
        console.log("Periodic update check started (every 60 seconds).");
        setInterval(checkNotifications, 15000); // Check every 15 seconds
        console.log("Periodic notification check started (every 15 seconds).");
        checkNotifications(); // Initial check
    
        console.log('Application initialization completed.');
    });

    function initializeVanta() {
        console.log('Entering initializeVanta() function.');
        try {
            // Get initial baseColor based on the current theme's --bg-dark color
            const computedStyle = getComputedStyle(document.body);
            const themeBgDark = computedStyle.getPropertyValue('--bg-dark').trim();
            console.log('Computed --bg-dark for initial theme:', themeBgDark);
            const themeBaseColor = colorToVantaFormat(themeBgDark);
            console.log('Converted Vanta.js baseColor:', '0x' + themeBaseColor.toString(16)); // Log as hex

            if (vantaEffect) {
                console.log('Destroying existing Vanta effect.');
                vantaEffect.destroy(); // Clean up previous instance if exists
            }

            console.log('Creating new VANTA.FOG instance...');
            vantaEffect = VANTA.FOG({
              el: "body", // Target the body element
              mouseControls: true,
              touchControls: true,
              gyroControls: false,
              minHeight: 200.00,
              minWidth: 200.00,
              highlightColor: 0x0,    // Set highlightColor to static 0x0 (black)
              midtoneColor: 0x0,      // Set midtoneColor to static 0x0 (black)
              lowlightColor: 0x0,     // Set lowlightColor to static 0x0 (black)
              baseColor: themeBaseColor, // baseColor will change with the theme
              blurFactor: 0.56, // Set blurFactor to 0.56
              speed: 1.10,      // Set speed to 1.10
              zoom: 1.20        // Set zoom to 1.20
            });
             console.log('VANTA.FOG instance creation attempted.');

        } catch (error) {
            console.error("Error initializing Vanta.js:", error);
            vantaEffect = null; // Ensure vantaEffect is null if creation failed
        }
    }

// --- Individual Notification Management ---
    // Store active notifications with their hide timeouts

    function showIndividualNotification(title, body, duration = 8000) { // Default duration 8 seconds
        const container = document.getElementById('notificationContainer');
        if (!container) {
            console.error("Notification container not found. Cannot show notification.");
            return;
        }

        // Create the notification element
        const notificationElement = document.createElement('div');
        notificationElement.classList.add('sliding-notification');
        const notificationId = `notification-${Date.now()}-${Math.random().toString(36).substring(7)}`;
        notificationElement.id = notificationId;
        notificationElement.setAttribute('data-hide-timeout-id', ''); // Placeholder for timeout ID
        notificationElement.style.display = 'block'; // Make it a block element to trigger layout


        // Add content (including close button and progress bar)
        notificationElement.innerHTML = `
            <button class="notification-close-button" onclick="hideIndividualNotification('${notificationId}')" title="Dismiss">&times;</button>
            <h3>${escapeHtml(title)}</h3>
            <div>${processLinkedText(body)}</div>
            <div class="notification-progress-bar"></div>
        `;

        // Append to the container
        container.appendChild(notificationElement);
        console.log(`Created and appended new notification: ${notificationId}`);

        // --- Start Show Animation and Progress Bar ---
         // Use a minimal timeout to allow the element to be added to the DOM before animating
         setTimeout(() => {
             notificationElement.classList.add('show');

             // Start progress bar animation after a slight delay
             const progressBarElement = notificationElement.querySelector('.notification-progress-bar');
             if (progressBarElement) {
                 // Ensure initial state is set before transition
                 progressBarElement.style.transitionDuration = '0ms';
                 progressBarElement.style.width = '100%';
                  // Delay applying the transition and new width
                 setTimeout(() => {
                      progressBarElement.style.transitionDuration = `${duration}ms`;
                      progressBarElement.style.width = '0%';
                 }, 50); // Small delay
             }

             // Set the hide timeout
             const hideTimeoutId = setTimeout(() => {
                 hideIndividualNotification(notificationId);
             }, duration);

             // Store the timeout ID and element reference
             notificationElement.setAttribute('data-hide-timeout-id', hideTimeoutId);
             activeNotifications[notificationId] = hideTimeoutId;
             console.log(`Notification ${notificationId} set to hide in ${duration}ms.`);

         }, 20); // Small delay to allow element to appear in DOM

        return notificationElement; // Return the created element
    }

    function hideIndividualNotification(notificationId, immediate = false) {
        const notificationElement = document.getElementById(notificationId);
        if (!notificationElement) {
            console.warn(`Notification element with ID "${notificationId}" not found or already removed.`);
            // Clean up activeNotifications state even if element is missing
            if (activeNotifications[notificationId]) {
                clearTimeout(activeNotifications[notificationId]);
                delete activeNotifications[notificationId];
                console.log(`Cleaned up activeNotifications state for ID "${notificationId}".`);
            }
            return;
        }

        console.log(`Attempting to hide notification: ${notificationId} (immediate: ${immediate})`);

        // Clear the hide timeout associated with this specific notification
        const hideTimeoutId = parseInt(notificationElement.getAttribute('data-hide-timeout-id'));
        if (!isNaN(hideTimeoutId)) {
            clearTimeout(hideTimeoutId);
            console.log(`Cleared hide timeout ${hideTimeoutId} for notification ${notificationId}.`);
        }
         // Also clear from activeNotifications state
        if (activeNotifications[notificationId]) {
            delete activeNotifications[notificationId];
             console.log(`Removed notification ${notificationId} from activeNotifications state.`);
        }


        // Start the slide-out animation
        notificationElement.classList.remove('show');

        const transitionDuration = 500; // Must match your CSS transition duration
        const delay = immediate ? 0 : transitionDuration;

         // Clear any previously set display:none timeout for this element
         if (notificationElement.hideDisplayTimeout) {
             clearTimeout(notificationElement.hideDisplayTimeout);
             notificationElement.hideDisplayTimeout = null;
         }


        // Set a timeout to remove the element from the DOM after the CSS transition completes
        notificationElement.hideDisplayTimeout = setTimeout(() => {
            // Check if the element is still attached before removing
            if (notificationElement.parentNode) {
                 notificationElement.parentNode.removeChild(notificationElement);
                 console.log(`Removed notification element ${notificationId} from DOM.`);
            }
        }, delay);
    }

    function hideAllNotifications() {
        console.log("Hiding all active notifications.");
        // Iterate through all currently managed notification IDs
        for (const id in activeNotifications) {
            if (activeNotifications.hasOwnProperty(id)) {
                // Pass immediate=true to hide them instantly on user action
                hideIndividualNotification(id, true);
            }
        }
         // Clear the active notifications object
        activeNotifications = {};
        console.log("All notifications cleared from activeNotifications state.");
    }


function processLinkedText(text) {
        let processedText = text;

        const linkRegex = /;(\w+);/g;
        processedText = processedText.replace(linkRegex, (match, pageName) => {
            const formattedPageName = pageName.charAt(0).toUpperCase() + pageName.slice(1);
            return `<a href="#" onclick="switchPage('${escapeHtml(formattedPageName)}'); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">${escapeHtml(pageName)}</a>`;
        });

        const sizeRegex = /\[\[size:(.*?)\]\](.*?)\[\[\/size\]\]/g;
         processedText = processedText.replace(sizeRegex, '<span style="font-size: $1;">$2</span>');

        const boldRegex = /\*\*(.*?)\*\*/g;
        processedText = processedText.replace(boldRegex, '<strong>$1</strong>');

        const italicRegex = /\*(.*?)\*/g;
        processedText = processedText.replace(italicRegex, '<em>$1</em>');

        return processedText;
    }


function fetchNews() {
       const newsBox = document.getElementById('news-content');
       const gameOfTheDayContainer = document.getElementById('game-of-day-container');

       if (!newsBox || !gameOfTheDayContainer) {
         console.log("News or Game of the Day elements not found.");
         return;
       }

       newsBox.textContent = "Loading news...";
       gameOfTheDayContainer.innerHTML = ''; // Clear previous content
       console.log("Fetching news...");

       fetch('https://hostfilez.glitch.me/news.txt')
         .then(response => {
              if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
              console.log("News fetched successfully.");
              return response.text();
          })
         .then(text => {
           let rawNewsText = text;
           let gameOfTheDayName = null;

           const gameOfTheDayRegex = /\{([^}]+)\}/; // Matches {Game name} and captures Game name
           const match = rawNewsText.match(gameOfTheDayRegex);

           if (match && match[1]) {
             gameOfTheDayName = match[1].trim();
             console.log("Found Game of the Day name:", gameOfTheDayName);

             // Remove the {Game name} marker from the news text
             rawNewsText = rawNewsText.replace(gameOfTheDayRegex, '').trim();

             // Find the game in the games array
             const gameOfTheDay = games.find(game => game.name.toLowerCase() === gameOfTheDayName.toLowerCase());

             if (gameOfTheDay) {
               console.log("Found Game of the Day data:", gameOfTheDay.name);

               // Find the index of the game in the main games array (needed for favorite/proxy toggling)
               const gameIndex = games.findIndex(game => game.name.toLowerCase() === gameOfTheDayName.toLowerCase());

               // Generate HTML for the Game of the Day container
               gameOfTheDayContainer.innerHTML = `
                  <h3>Game of the Day</h3>
                  <div class="game-card" style="width: 100%; margin: 0;">
                     <img src="${escapeHtml(gameOfTheDay.icon)}" alt="${escapeHtml(gameOfTheDay.name)}"
                           onerror="this.src='https://via.placeholder.com/150?text=No+Image'"
                           onclick="loadGame('${escapeHtml(gameOfTheDay.name)}', '${escapeHtml(gameOfTheDay.url)}')">
                      <p onclick="loadGame('${escapeHtml(gameOfTheDay.name)}', '${escapeHtml(gameOfTheDay.url)}')">${escapeHtml(gameOfTheDay.name)}</p>
                       <div style="display: flex; flex-direction: column; gap: 5px; align-items: center; margin-top: 5px;">
                           <button class="favorite-button" onclick="event.stopPropagation(); toggleFavoriteGame(${gameIndex})">
                                <i class="fas ${isFavoriteGame(gameOfTheDay) ? 'fa-solid' : 'fa-regular'} fa-star" style="${isFavoriteGame(gameOfTheDay) ? 'color: var(--accent);' : ''}"></i>
                                <span>${isFavoriteGame(gameOfTheDay) ? 'Favorited' : 'Favorite'}</span>
                           </button>
                           ${gameOfTheDay.proxiedUrl && gameOfTheDay.proxiedUrl !== 'none' ? // Only show proxy toggle if proxy URL exists
                            `<button class="favorite-button" onclick="event.stopPropagation(); toggleProxied(${gameIndex})">
                              <i class="fas fa-shield-alt"></i>
                              <span>Proxy: ${gameOfTheDay.proxied ? 'On' : 'Off'}</span>
                            </button>`
                            : ''
                          }
                      </div>
                   </div>
               `;
               console.log("Generated Game of the Day game-card HTML.");

               // Note: Clicking Favorite or Proxy toggle on the Home page
               // will update the state in games array and localStorage,
               // but the button display on the Home page won't auto-update
               // unless you manually re-render the game-of-day-container
               // or refetch the news after a toggle. The functionality still works.

             } else {
                 console.log("Game of the Day not found in games list:", gameOfTheDayName);
                  gameOfTheDayContainer.innerHTML = `
                     <h3>Game of the Day</h3>
                     <p style="color: var(--text-muted);">Game "${escapeHtml(gameOfTheDayName)}" not found.</p>
                  `;
             }
           } else {
             console.log("No {Game name} found in news text.");
               gameOfTheDayContainer.innerHTML = `
                  <h3>Game of the Day</h3>
                  <p style="color: var(--text-muted);">No Game of the Day selected.</p>
               `;
           }

           // Process and display the remaining news text
           const processedNewsText = processLinkedText(rawNewsText);
           newsBox.innerHTML = processedNewsText;

         })
         .catch(err => {
           console.error("Failed to load news:", err);
           newsBox.textContent = "Failed to load news.";
           gameOfTheDayContainer.innerHTML = `
               <h3>Game of the Day</h3>
               <p style="color: var(--text-muted);">Failed to load Game of the Day.</p>
           `;
         });
     }


    function openChangelogModal() {
      const modal = document.getElementById("changelogModal");
      const content = document.getElementById("changelogContent");
      if (!modal || !content) return;
      modal.style.display = "flex";
      content.textContent = "Loading...";
      fetch('https://hostfilez.glitch.me/changelog.txt')
        .then(response => response.text())
        .then(text => {
          const processedText = processLinkedText(text);
          content.innerHTML = processedText;
        })
        .catch(err => {
          console.error("Failed to load changelog:", err);
          content.textContent = "Failed to load changelog.";
        });
    }

    function closeChangelogModal() {
      console.log('Closing changelog modal.');
      const modal = document.getElementById("changelogModal");
      if (modal) {
        modal.style.display = "none";
      }
    }


// --- About:Blank Startup Toggle ---
    function toggleAboutBlankStartup() {
        const toggle = document.getElementById('aboutBlankToggle');
        if (toggle) {
            const isEnabled = toggle.checked;
            localStorage.setItem('aboutBlankOnStartup', isEnabled);
            console.log('About:Blank on startup set to:', isEnabled);
            // Optional: Add user feedback like a small notification/alert
            // alert(`About:Blank on startup ${isEnabled ? 'enabled' : 'disabled'}.`);
        } else {
            console.error("About:Blank toggle element not found.");
        }
    }

    // --- Modified loadData function ---
function loadData() {
        console.log('Loading data from localStorage...');
        // Load theme name first
        const savedThemeName = localStorage.getItem('theme') || 'default'; // Default to 'default'
        currentThemeName = savedThemeName; // Set the state variable

        // Apply the theme using the new setTheme function
        // Call setTheme here to apply the variables from the themes array
        setTheme(currentThemeName);

        console.log('Theme data loaded. Initial theme:', currentThemeName);

        // --- Check and apply About:Blank on Startup preference ---
        const aboutBlankPref = localStorage.getItem('aboutBlankOnStartup');
        // Default to true (enabled) if not explicitly set to false
        const shouldOpenInAboutBlank = aboutBlankPref !== 'false';
        if (shouldOpenInAboutBlank) {
             // You might want to gate this behind a check to ensure it only happens
             // when the page is *initially* loaded, not on subsequent calls to loadData.
             // A simple flag or checking the window location could work.
             // For simplicity here, we'll assume it's checked elsewhere or desired on every loadData call.
             // openAppInAboutBlank(); // Consider the implications of calling this here.
             console.log('About:Blank on startup is enabled (logic placeholder).');
        } else {
             console.log('About:Blank on startup is disabled.');
        }
         // Ensure the toggle reflects the saved state when the Settings page loads
         const toggle = document.getElementById('aboutBlankToggle');
         if (toggle) {
             toggle.checked = shouldOpenInAboutBlank;
         }
        // --- End About:Blank Check ---


        const defaultGames = [
             { name: "Agar.io", url: "https://fluxaga.glitch.me", icon: "https://static.wikia.nocookie.net/yogscast/images/1/19/Agar.io_appstore_logo.png", proxiedUrl: "https://flux.englishd.workers.dev/", proxied: false },
             { name: "Slither.io", url: "https://slither.io", icon: "https://pbs.twimg.com/profile_images/1854966120509267968/gUTLTAMd_400x400.jpg", proxiedUrl: "place", proxied: false }, // Placeholder for proxiedUrl
             { name: "n-gon", url: "https://landgreen.github.io/n-gon/", icon: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSIiXBQof9-UTot6CA0A-X9Ntyp0pNALernmg&s", proxiedUrl: "https://skibidi.global.fastly.net/uv/service/hvtrs8%2F-lcnfgpegn%2Cgktju%60.ko-n%2Fgmn-", proxied: false },
             { name: "FreeRiderHD", url: "https://freeriderhd.com", icon: "https://cdn.freeriderhd.com/free_rider_hd/sprites/youtube_poster_art.png", proxiedUrl: "https://skibidi.global.fastly.net/uv/service/hvtrs8%2F-wuw%2Cfpegrkdgrjd%2Ccmm-", proxied: false },
             { name: "Shell Shockers", url: "https://shellshock.io/", icon: "https://rocketgames.imgix.net/uploads/games/s/shell-shockers/shell-shockers.jpg", proxiedUrl: "none", proxied: false },
             { name: "Happy Wheels", url: "https://totaljerkface.com/happy_wheels.tjf", icon: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR8ZZNe14xfg_CvlBFQRnl2Boj4GIEuiyVqYw&s", proxiedUrl: "https://nyx-2b7o.onrender.com/active/go/hvtrs8%2F-tmtclhepkdaae%2Ccmm-hcpry%5Dwjeglq.vjd", proxied: false }
        ];

        const savedGames = localStorage.getItem('games');
        const userGames = savedGames ? JSON.parse(savedGames) : [];

        games = [...defaultGames];
        const gameNames = new Set(defaultGames.map(g => g.name));
        userGames.forEach(g => {
            if (!gameNames.has(g.name)) {
                games.push(g);
                gameNames.add(g.name);
            }
        });
        console.log('Games loaded:', games.length);

        const savedLibrary = localStorage.getItem('library');
        library = savedLibrary ? JSON.parse(savedLibrary) : [];
        console.log('Library loaded:', library.length);


        const savedFavoriteGames = localStorage.getItem('favoriteGames');
        favoriteGames = savedFavoriteGames ? JSON.parse(savedFavoriteGames) : [];
        console.log('Favorite games loaded:', favoriteGames.length);

        // --- Load App Appearance Settings ---
        const savedAppSettings = localStorage.getItem('appSettings');
        if (savedAppSettings) {
            const appSettings = JSON.parse(savedAppSettings);
            applyAppSettings(appSettings); // applyAppSettings updates the UI inputs as well
            console.log('Loaded and applied saved app settings.');
        } else {
            // If no saved settings, apply defaults and update UI inputs to show defaults
            applyAppSettings({
                tabTitle: 'Underground',
                faviconUrl: ''
            });
            console.log('No saved app settings found, applying defaults.');
        }

        console.log('Theme selector UI update logic is handled by setTheme.');

         console.log('Data loading complete.');
    }

    function applyAppSettings(settings) {
    console.log('Applying app settings:', settings);
    // Apply Tab Title
    if (settings.tabTitle !== undefined) { // Check if setting exists
        document.title = settings.tabTitle;
        console.log('Applied app tab title:', settings.tabTitle);
    }

    // Apply Favicon
    let link = document.querySelector("link[rel~='icon']");
    if (settings.faviconUrl) { // Check if a URL is provided
        if (!link) {
            link = document.createElement('link');
            link.rel = 'icon';
            document.getElementsByTagName('head')[0].appendChild(link);
             console.log('Created favicon link element.');
        }
        link.href = settings.faviconUrl;
        console.log('Applied app favicon URL:', settings.faviconUrl);
    } else {
         // If no favicon URL is provided, remove the link element to use browser default
        if (link) {
             link.remove(); // Remove the custom favicon link
             console.log('Removed custom favicon, using browser default.');
        }
    }

    // Update the UI elements on the Settings page if they exist
    const appTabTitleInput = document.getElementById('appTabTitleInput');
    const appFaviconUrlInput = document.getElementById('appFaviconUrlInput');

    if (appTabTitleInput && settings.tabTitle !== undefined) {
         appTabTitleInput.value = settings.tabTitle;
    }
     if (appFaviconUrlInput && settings.faviconUrl !== undefined) {
        appFaviconUrlInput.value = settings.faviconUrl;
     }
     console.log('Updated app settings page UI elements.');
}

    function saveAppSettings() {
    console.log('Saving app settings...');
    const appTabTitleInput = document.getElementById('appTabTitleInput');
    const appFaviconUrlInput = document.getElementById('appFaviconUrlInput');

    if (!appTabTitleInput || !appFaviconUrlInput) {
        console.error("App settings input elements not found, cannot save.");
        alert("Error: App Settings page elements not found.");
        return;
    }

    const appSettingsToSave = {
        tabTitle: appTabTitleInput.value.trim(),
        faviconUrl: appFaviconUrlInput.value.trim()
    };

    localStorage.setItem('appSettings', JSON.stringify(appSettingsToSave)); // Use 'appSettings' key
    console.log('App settings saved to localStorage:', appSettingsToSave);

    // Apply the newly saved settings immediately
    applyAppSettings(appSettingsToSave);

    alert('App Settings saved!');
}

function openAppInAboutBlank() {
        console.log('Attempting to open app in about:blank window by getting current document HTML and writing, setting opener to null.');
        // Get the full HTML content of the current page
        const htmlContent = document.documentElement.outerHTML;
        const currentAppUrl = window.location.href; // Still useful context, though not fetched

        const newWindow = window.open('about:blank', '_blank');

        if (newWindow) {
            console.log('Opened new about:blank window.');

            // Set opener to null immediately to try and break the link
            try {
                newWindow.opener = null;
                console.log('Set new window opener to null.');
            } catch (e) {
                console.warn('Failed to set new window opener to null:', e);
            }


            // Use setTimeout to allow the window document to be ready for writing
            setTimeout(() => {
                try {
                    // Write the obtained HTML content into the new window's document
                    newWindow.document.open();
                    newWindow.document.write(htmlContent);
                    newWindow.document.close();

                    console.log('Successfully wrote current document HTML to about:blank window.');

                    // Optional: You might want to set the new window's history or URL to the original URL
                    // This can sometimes help with relative paths but might re-introduce detection issues
                    try {
                         // Setting history.pushState is cleaner than changing location.href directly if you want to spoof the URL
                         newWindow.history.pushState({}, '', currentAppUrl);
                         console.log('Attempted to set new window history state URL.');
                    } catch (e) {
                         console.warn('Failed to set new window history state URL:', e);
                    }


                } catch (e) {
                    console.error('Failed to write HTML content to about:blank window:', e);
                     // This alert indicates that writing to the document itself failed
                     alert("Could not write app content to about:blank window.");
                }
            }, 50); // Small delay

        } else {
            alert('Could not open a new window. Please check your browser popup blocker.');
            console.warn('Failed to open new window for about:blank.');
        }
    }


    function handleReloadSiteClick() {
            console.log("Reload Site button clicked. Reloading page.");
            location.reload(); // Reload the current page
        }
      
    function handleDownloadOfflineClick() {
        if (updateDownloadUrl) {
            console.log("Download Offline button clicked. Downloading from:", updateDownloadUrl);
            // Create a temporary anchor element
            const link = document.createElement('a');
            link.href = updateDownloadUrl;
            // Set the download attribute with an optional filename
            link.setAttribute('download', 'Underground_Update.html'); // You can change the filename
            // Append to the body, trigger click, and remove
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            // Optionally close the update overlay after initiating download
            // document.getElementById("updateOverlay").style.display = 'none';

        } else {
            console.warn("Download Offline button clicked, but no download URL is available.");
            alert("Download link not found. Please try again or reload.");
        }
    }

    function hideUpdateOverlay() {
        const updateOverlay = document.getElementById("updateOverlay");
         if (updateOverlay) {
             updateOverlay.style.display = 'none';
             // Optionally reset the overlay content back to its initial state
             // (Less critical with the single overlay structure, but good practice)
             // document.getElementById("updateTitle").textContent = "New Update Available!";
             // document.getElementById("updateMessage").textContent = "A new version (vX.Y.Z) is available.";
             // const downloadButton = document.getElementById("downloadOfflineButton");
             // if (downloadButton) {
             //     downloadButton.disabled = false; // Reset disabled state
             //     downloadButton.title = ""; // Clear title
             // }
             updateDownloadUrl = null; // Clear the stored URL
             console.log("Update overlay hidden.");
         }
    }

let updateDownloadUrl = null; // Variable to store the fetched download URL

    async function handleUpdateNowClick() {
        const updateInitialButtonDiv = document.getElementById("updateInitialButton");
        const updateOptionsDiv = document.getElementById("updateOptions");
        const updateNowButton = document.getElementById("updateNowButton");
        const updateTitle = document.getElementById("updateTitle");
        const updateMessage = document.getElementById("updateMessage");


        if (!updateInitialButtonDiv || !updateOptionsDiv || !updateNowButton || !updateTitle || !updateMessage) {
             console.error("Update overlay elements not found for handling click.");
             return;
        }

        updateNowButton.textContent = "Fetching link...";
        updateNowButton.disabled = true;

        const versionURL = "https://hostfilez.glitch.me/version.txt";
        console.log("Fetching update link from:", versionURL);

        try {
            const versionResponse = await fetch(versionURL, { cache: "no-store" });
            if (!versionResponse.ok) throw new Error(`HTTP error! status: ${versionResponse.status}`);
            const latestVersionText = (await versionResponse.text()).trim();

            // Use regex to find the URL within parentheses ()
            const urlMatch = latestVersionText.match(/\((.*?)\)/);

            if (urlMatch && urlMatch[1]) {
                updateDownloadUrl = urlMatch[1].trim(); // Store the fetched URL
                console.log("Found update download URL:", updateDownloadUrl);

                // Hide the initial button and show the options
                updateInitialButtonDiv.style.display = 'none';
                updateOptionsDiv.style.display = 'block';
                updateTitle.textContent = "Update Options";
                updateMessage.textContent = "Choose how to update:";


            } else {
                alert("Update link not found in version file. Cannot provide download option.");
                console.warn("No URL found in parentheses in version file.");
                 // Optionally revert the button or provide only reload option
                 updateNowButton.textContent = "Update Now"; // Reset button text
                 updateNowButton.disabled = false;
                 // Or show only reload: updateInitialButtonDiv.style.display = 'none'; updateOptionsDiv.innerHTML = '<p style="margin-bottom: 1rem;">Cannot find download link.</p><button id="reloadSiteButton">Reload Site</button>'; setupReloadSiteListener();
            }

        } catch (err) {
            alert("Failed to fetch update link.");
            console.error("Error fetching update link:", err);
            updateNowButton.textContent = "Update Now"; // Reset button text
            updateNowButton.disabled = false;
            // Optionally hide the overlay or show error state
             updateTitle.textContent = "Update Error";
             updateMessage.textContent = "Could not fetch update details.";
             updateInitialButtonDiv.style.display = 'none'; // Hide the button div
             updateOptionsDiv.style.display = 'none'; // Hide the options div
        }
    }

// Variable to store the fetched download URL

    async function checkVersion() {
       console.log("Checking for latest version (triggered by interval or Home page switch)...");

       // Define the installed version here
       const installedVersion = "v1.0.0"; // <-- Set your installed version here

       const versionURL = "https://hostfilez.glitch.me/version.txt";
       let latestVersion = null;
       let fetchedDownloadUrl = null;
       let checkError = false;

       // --- Fetch Version and Extract Data ---
       try {
         const versionResponse = await fetch(versionURL, { cache: "no-store" }); // Avoid cache
         if (!versionResponse.ok) throw new Error(`HTTP error! status: ${versionResponse.status}`);
         const latestVersionText = (await versionResponse.text()).trim();

         // Extract just the version string (assuming it's the first part before any '(' or whitespace)
         const latestVersionMatch = latestVersionText.match(/^([^(\s]+)/);
         latestVersion = latestVersionMatch ? latestVersionMatch[1] : latestVersionText;

         // Extract the URL within parentheses
         const urlMatch = latestVersionText.match(/\((.*?)\)/);
         fetchedDownloadUrl = urlMatch && urlMatch[1] ? urlMatch[1].trim() : null;

         console.log("Fetched latest version text:", latestVersionText);
         console.log("Extracted latest version:", latestVersion);
         console.log("Extracted download URL:", fetchedDownloadUrl);

         updateDownloadUrl = fetchedDownloadUrl; // Store in the global variable

       } catch (err) {
         console.error("Failed to fetch or parse version:", err);
         checkError = true;
         latestVersion = "Error"; // Indicate error in UI if elements exist
         updateDownloadUrl = null; // Clear URL on error
       }

       // --- Update Home Page Elements (Only if they exist) ---
       // Do this AFTER fetching the version to minimize impact on fetch
       const homeVersionEl = document.getElementById("home-installed-version");
       const latestVersionEl = document.getElementById("home-latest-version");

       if (homeVersionEl) {
           homeVersionEl.textContent = installedVersion;
       }
       if (latestVersionEl) {
           latestVersionEl.textContent = latestVersion; // Will show version or "Error"
       }


       // --- Display/Hide Update Overlay (Independent of Home Page) ---
       // Get the update overlay elements
       const updateOverlay = document.getElementById("updateOverlay");
       const updateMessageEl = document.getElementById("updateMessage");
       const updateTitleEl = document.getElementById("updateTitle");
       const downloadButton = document.getElementById('downloadOfflineButton');

       // Check if overlay elements were successfully found before trying to manipulate them
       const canDisplayOverlay = updateOverlay && updateMessageEl && updateTitleEl && downloadButton;

       if (!canDisplayOverlay) {
            console.warn("Update overlay elements not found. Cannot display update notification.");
            // We can stop here if the overlay itself can't be shown
            return;
       }

       // Now that we know overlay elements exist, proceed with display logic
       if (latestVersion && latestVersion !== "Error" && latestVersion !== installedVersion) {
            console.log("New update available detected:", latestVersion);
            updateOverlay.style.display = 'flex'; // Show the update overlay
            updateTitleEl.textContent = "New Update Available!";
            updateMessageEl.textContent = `A new version (${latestVersion}) is available.`;

            // Enable or disable download button based on whether a URL was found
            downloadButton.disabled = !updateDownloadUrl;
            if (!updateDownloadUrl) {
                downloadButton.title = "Download link not found in version file.";
            } else {
                downloadButton.title = "";
            }

       } else {
           console.log("App is up to date or check failed, ensuring overlay is hidden.");
           updateOverlay.style.display = 'none'; // Ensure overlay is hidden
       }

       // If there was a fetch/parse error, the overlay will be hidden,
       // and the Home page status will show "Error".
       if (checkError) {
            console.log("Update check finished with errors.");
       } else if (latestVersion === installedVersion) {
            console.log("Update check finished: App is up to date.");
       } else if (latestVersion !== installedVersion && latestVersion !== "Error") {
            console.log("Update check finished: Update available.");
       }
     }

    function saveGames() {
      localStorage.setItem('games', JSON.stringify(games));
       console.log('Games data saved.');
    }

    function generateGamesHTML() {
       console.log('Generating Games HTML. Showing favorites:', isShowingFavoriteGames());
       const gamesToDisplay = isShowingFavoriteGames() ?
         games.filter(game => favoriteGames.some(fav => fav.name === game.name)) :
         games;

       // Generate the cards first
       const gameCardsHTML = gamesToDisplay.map((game, index) => {
         // Find original index to use for actions (like remove/favorite/proxy)
         const originalIndex = games.findIndex(g => g.name === game.name);
         // Ensure the index is valid before generating the card
         if (originalIndex === -1) return ''; // Skip if game not found in main list

         return `
           <div class="game-card" draggable="true" data-index="${originalIndex}">
             <div class="remove-icon" onclick="removeGame(event, ${originalIndex})" title="Remove Game">
               <i class="fas fa-times"></i>
             </div>
             <img src="${escapeHtml(game.icon)}" alt="${escapeHtml(game.name)}"
                  onerror="this.src='https://via.placeholder.com/150?text=No+Image'"
                  onclick="loadGame('${escapeHtml(game.name)}', '${escapeHtml(game.url)}')">
             <p onclick="loadGame('${escapeHtml(game.name)}', '${escapeHtml(game.url)}')">${escapeHtml(game.name)}</p>
             <div style="display: flex; flex-direction: column; gap: 5px; align-items: center; margin-top: 5px;">
               <button class="favorite-button" onclick="event.stopPropagation(); toggleFavoriteGame(${originalIndex})">
                 <i class="fas ${isFavoriteGame(game) ? 'fa-solid' : 'fa-regular'} fa-star" style="${isFavoriteGame(game) ? 'color: var(--accent);' : ''}"></i>
                 <span>${isFavoriteGame(game) ? 'Favorited' : 'Favorite'}</span>
               </button>
               ${game.proxiedUrl && game.proxiedUrl !== 'none' ? // Only show proxy toggle if proxy URL exists
                 `<button class="favorite-button" onclick="event.stopPropagation(); toggleProxied(${originalIndex})">
                   <i class="fas fa-shield-alt"></i>
                   <span>Proxy: ${game.proxied ? 'On' : 'Off'}</span>
                 </button>`
                 : ''
               }
             </div>
           </div>`;
         }).join('');


       // Return the full container HTML
       return `
         <input type="text" id="gameSearch" placeholder="Search Games..." oninput="filterGames()" style="width: 90%; max-width: 400px; margin: 0 auto 1.5rem auto; display: block;">
         <div class="games-header">
           <div class="action-card" onclick="showAddGameModal()">
             <i class="fas fa-plus"></i>
             <p>Add Game</p>
           </div>
           <div class="action-card" onclick="toggleFavoriteGamesView()">
             <i class="fas fa-star" style="${isShowingFavoriteGames() ? 'color: var(--accent);' : ''}"></i>
             <p>${isShowingFavoriteGames() ? 'All Games' : 'Favorites'}</p>
           </div>
         </div>
         <div class="games-container" id="gamesContainerInner">
             ${gameCardsHTML || '<p class="no-games-message" style="color: var(--text-muted); width: 100%; text-align: center;">No games found.</p>'}
         </div>`;
     }


    function toggleProxied(index) {
      console.log('Toggling proxy for game index:', index);
      if (games[index] && games[index].proxiedUrl && games[index].proxiedUrl !== 'none') {
         games[index].proxied = !games[index].proxied;
         saveGames();
         console.log('Proxy toggled.');
    
         // Update UI immediately for the specific card
          // Check if the clicked button is within the Game of the Day container
         const gameOfTheDayContainer = document.getElementById('game-of-day-container');
         let button = null;
    
         if (gameOfTheDayContainer && gameOfTheDayContainer.contains(event.target)) {
             // If the clicked element is inside the Game of the Day container,
             // find the proxy button relative to the container.
             // This assumes there's only one proxy button within the game-of-day-container's .game-card
             button = gameOfTheDayContainer.querySelector('.favorite-button i.fa-shield-alt').closest('button'); // Find button by icon
             console.log('Updating proxy button in Game of the Day container.');
    
         } else {
             // Otherwise, assume it's a button on the main Games page
              button = document.querySelector(`.game-card[data-index="${index}"] .favorite-button i.fa-shield-alt`).closest('button'); // Find button by icon
              console.log('Updating proxy button on Games page.');
         }
    
    
         if (button) {
           const span = button.querySelector('span');
           if (span) {
             span.textContent = `Proxy: ${games[index].proxied ? 'On' : 'Off'}`;
              console.log('Proxy button text updated.');
           }
         } else {
            console.warn('Proxy button not found for index:', index);
         }
    
         // If currently showing all games or favorites on Games page, re-render (optional but good for consistency)
         // updateGamesPage(); // Decided not to re-render the whole games page on proxy toggle unless necessary
      } else {
         alert("This game does not have a proxy URL configured.");
         console.warn('Attempted to toggle proxy for game without proxiedUrl.');
      }
    }

    function escapeHtml(unsafe) {
        if (typeof unsafe !== 'string') return '';
        return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    function loadViewerFromLibrary(url = '', customTitle = 'Viewer', displayUrl = url, updateRecents = true) {
      console.log('Loading viewer with URL:', url, 'Custom title:', customTitle);
      // Allow launching with no URL to show the input box immediately
      // if (!url) return; // Removed this check

      // Basic URL validation (only if a URL is provided)
      if (url && !url.startsWith('http://') && !url.startsWith('https://') && !url.startsWith('about:')) {
          url = 'https://' + url; // Attempt to prepend https
          displayUrl = url; // Update display URL as well
          console.log('Prepended https to URL:', url);
      }
       // If no URL is provided initially, the iframe src will be empty or about:blank

      try {
        if (url && !url.startsWith('about:')) { // Only validate if it's not about:blank
           new URL(url); // Validate if it's a proper URL now
        }
      } catch (e) {
        // If still invalid, try searching it
        console.warn("Invalid URL, attempting search:", url, e);
        url = `https://www.google.com/search?q=${encodeURIComponent(url)}`;
        displayUrl = url;
        customTitle = `Search Results for "${customTitle}"`;
        // Don't add search results to recents/library typically
        updateRecents = false;
      }

      // Hide sidebar and main content container for iframe view
       document.querySelector('.sidebar').style.display = 'none';
       pageContent.style.display = 'none';
       pageTitle.style.display = 'none'; // Hide main title

      // Create or get iframe container
      let iframeContainer = document.getElementById('iframe-viewer-container');
      if (!iframeContainer) {
         iframeContainer = document.createElement('div');
         iframeContainer.id = 'iframe-viewer-container';
         iframeContainer.className = 'iframe-container'; // Use existing class for styling
         document.body.appendChild(iframeContainer); // Append directly to body
         console.log('Created iframe container.');
      }

      iframeContainer.style.display = 'flex'; // Ensure it's visible
      iframeContainer.innerHTML = `
        <iframe src="${escapeHtml(url)}" frameborder="0" allowfullscreen></iframe>
        <div class="bottom-controls" id="iframe-bottom-controls">
          <button onclick="goBackToAppView()" title="Back to App"><i class="fas fa-arrow-left"></i></button>
          <input type="text" id="urlSearch" placeholder="Enter URL or Search" value="${escapeHtml(displayUrl)}" onkeydown="if(event.key==='Enter') goToUrl()">
          <button class="go-button" onclick="goToUrl()" title="Go"><i class="fas fa-check"></i></button>
          <button class="fullscreen-button" onclick="openFullscreen('${escapeHtml(url)}')" title="Open Fullscreen"><i class="fas fa-expand"></i></button>
          ${updateRecents ? `<button onclick="addToLibraryFromViewer('${escapeHtml(url)}')" title="Add to Library"><i class="fas fa-bookmark"></i></button>` : ''}
        </div>`;

      console.log('Set iframe source to:', url);

      if (updateRecents && url && url !== 'about:blank') {
         updateRecentlyViewed(url); // Only update recents if a valid URL was loaded
         console.log('Updated recently viewed.');
      }
    }

    function goBackToAppView() {
        console.log('Going back to app view.');
        // Hide iframe container
        const iframeContainer = document.getElementById('iframe-viewer-container');
        if (iframeContainer) {
            iframeContainer.style.display = 'none';
            iframeContainer.innerHTML = ''; // Clear content
            console.log('Hid and cleared iframe container.');
        }

        // Show sidebar and content again
        document.querySelector('.sidebar').style.display = 'flex'; // Or original display value
        pageContent.style.display = 'flex'; // Or original display value
        console.log('Showed sidebar and content.');


        // Restore the page title display based on the current page
        const currentPageKey = localStorage.getItem('lastActivePage') || 'Home';
         if (currentPageKey !== 'Home') {
              pageTitle.style.display = 'block';
              pageTitle.textContent = localStorage.getItem('lastActivePageTitle') || currentPageKey;
              console.log('Restored page title:', pageTitle.textContent);
         } else {
              pageTitle.style.display = 'none'; // Ensure title is hidden on Home
               console.log('Hid page title on Home page.');
         }


        // Optionally switch back to the last active page
        // switchPage(localStorage.getItem('lastActivePage') || 'Home'); // Decided against automatic page switch for simplicity
    }


    // This function is now less relevant as Viewer launches overlay directly
    // Leaving it in case it's called from other places, but updated to use the overlay logic
    function loadViewer() {
        console.log('loadViewer() called.');
        const urlInput = document.getElementById('homeSearchInput'); // Get input from Home/Viewer page
        const url = urlInput ? urlInput.value.trim() : ''; // Get value, default to empty
        console.log('URL from home search input:', url);

        loadViewerFromLibrary(url, url, url); // Load the URL in the overlay
    }

    function updateRecentlyViewed(url) {
      console.log('Updating recently viewed with URL:', url);
      let recentlyViewed = JSON.parse(localStorage.getItem('recentlyViewed')) || [];
      // Remove existing entry if present to move it to the top
      recentlyViewed = recentlyViewed.filter(item => item !== url);
      recentlyViewed.unshift(url); // Add to the beginning
      localStorage.setItem('recentlyViewed', JSON.stringify(recentlyViewed.slice(0, 10))); // Keep latest 10
       console.log('Recently viewed updated:', recentlyViewed.slice(0, 10));
       // Don't update library page here, it happens when Library page is switched to
    }

    function goToUrl() {
      console.log('goToUrl() called.');
      const urlInput = document.getElementById('urlSearch'); // In the iframe controls
      const url = urlInput ? urlInput.value.trim() : ''; // Get value, default to empty
      const iframe = document.querySelector('#iframe-viewer-container iframe');

      if (url) {
        let finalUrl = url;
         // Simple validation and prepend https if missing
         if (!finalUrl.startsWith('http://') && !finalUrl.startsWith('https://') && !finalUrl.startsWith('about:')) {
             finalUrl = 'https://' + finalUrl;
             console.log('Prepended https to input URL:', finalUrl);
         }

        try {
            if (!finalUrl.startsWith('about:')) {
                new URL(finalUrl); // Validate
            }
             // If valid or about:blank, set the iframe src
            if (iframe) {
               iframe.src = escapeHtml(finalUrl);
               updateRecentlyViewed(finalUrl); // Update recents for valid URLs
                // Update the input box to show the cleaned URL
               urlInput.value = escapeHtml(finalUrl);
               console.log('Navigated iframe to:', finalUrl);
            }
        } catch (e) {
             // If still invalid, attempt search
             console.warn("Invalid URL, attempting search:", finalUrl, e);
             const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(finalUrl)}`;
             if (iframe) {
                 iframe.src = escapeHtml(searchUrl);
                 // Don't add search results to recents
                 // Update input box to show the search query
                 urlInput.value = `Search: ${escapeHtml(finalUrl)}`;
                 console.log('Navigated iframe to search results for:', finalUrl);
             }
        }


      } else {
        // If input is empty, load about:blank
         if (iframe) {
             iframe.src = 'about:blank';
              // Clear input box value when blank
             urlInput.value = '';
             console.log('Navigated iframe to about:blank.');
         }
      }
    }

    function openFullscreen(url) {
        console.log('Attempting fullscreen for URL:', url);
        const iframe = document.querySelector('#iframe-viewer-container iframe');
        if (iframe && iframe.requestFullscreen) {
            iframe.requestFullscreen().catch(err => {
                console.error("Fullscreen failed:", err);
                // Fallback: open in new tab if fullscreen API fails
                if (iframe.src && iframe.src !== 'about:blank') {
                    window.open(iframe.src, '_blank');
                     console.log('Fullscreen failed, opening in new tab as fallback.');
                }
            });
        } else {
             // Fallback for browsers not supporting requestFullscreen on iframe directly
             if (iframe && iframe.src && iframe.src !== 'about:blank') {
                 window.open(iframe.src, '_blank');
                 console.log('Browser does not support iframe fullscreen, opening in new tab.');
             } else {
                 console.warn('Cannot open fullscreen: iframe or iframe source is not available.');
             }
        }
    }

    function showAddGameModal() {
      console.log('Showing add game modal.');
      addGameModal.style.display = 'flex';
      document.getElementById('gameName').focus();
    }

    function closeModal() {
      console.log('Closing add game modal.');
      addGameModal.style.display = 'none';
       // Clear fields
       document.getElementById('gameName').value = '';
       document.getElementById('gameUrl').value = '';
       document.getElementById('gameIcon').value = '';
    }

    function addGame() {
      console.log('Attempting to add game.');
      const nameInput = document.getElementById('gameName');
      const urlInput = document.getElementById('gameUrl');
      const iconInput = document.getElementById('gameIcon');

      const name = nameInput.value.trim();
      const url = urlInput.value.trim();
      const icon = iconInput.value.trim();

      if (!name || !url) {
        alert('Please provide both a name and URL for the game');
        console.warn('Add game failed: Name or URL missing.');
        return;
      }

      // Simple URL validation
      if (!url.includes('.') || url.includes(' ')) {
         alert('Please enter a valid URL.');
          console.warn('Add game failed: Invalid URL format.');
         return;
      }
      let finalUrl = url;
       if (!url.startsWith('http://') && !url.startsWith('https://')) {
         finalUrl = 'https://' + url;
         console.log('Prepended https to game URL:', finalUrl);
       }


      games.push({
        name: name,
        url: finalUrl,
        icon: icon || 'https://via.placeholder.com/150?text=No+Image',
        proxied: false, // Default to not proxied
        proxiedUrl: 'none' // Default proxy URL
      });

      saveGames(); // Save immediately
      updateGamesPage(); // Refresh the view
      closeModal();
      console.log('Game added successfully:', name);
    }

    function removeGame(event, index) {
      event.stopPropagation(); // Prevent card click
      console.log('Attempting to remove game index:', index);
      if (index >= 0 && index < games.length) {
         const gameName = games[index].name;
         if (confirm(`Are you sure you want to remove ${gameName}?`)) {
           // Also remove from favorites if it's there
           favoriteGames = favoriteGames.filter(fav => fav.name !== gameName);
           localStorage.setItem('favoriteGames', JSON.stringify(favoriteGames));
            console.log('Removed game from favorites if present.');

           games.splice(index, 1);
           saveGames();
           updateGamesPage();
           console.log('Game removed successfully:', gameName);
         }
      } else {
         console.error("Invalid index for removeGame:", index);
      }
    }

    // --- Drag and Drop (Games) ---
     function setupDragAndDrop() {
         console.log('Setting up drag and drop.');
         // Use event delegation on the container
         const container = document.getElementById('gamesContainerInner'); // Target the inner container
         if (!container) {
            console.log('Games container not found, skipping drag and drop setup.');
            return;
         }

         // Remove previous listeners if re-setting up
         container.removeEventListener('dragstart', handleDragStart);
         container.removeEventListener('dragover', handleDragOver);
         container.removeEventListener('dragenter', handleDragEnter);
         container.removeEventListener('dragleave', handleDragLeave);
         container.removeEventListener('drop', handleDrop);
         container.removeEventListener('dragend', handleDragEnd);

         // Add new listeners
         container.addEventListener('dragstart', handleDragStart);
         container.addEventListener('dragover', handleDragOver);
         container.addEventListener('dragenter', handleDragEnter);
         container.addEventListener('dragleave', handleDragLeave);
         container.addEventListener('drop', handleDrop);
         container.addEventListener('dragend', handleDragEnd);
          console.log('Drag and drop event listeners added.');
     }

     function handleDragStart(e) {
         // Only allow dragging on .game-card elements
         if (e.target.classList.contains('game-card')) {
             draggedItem = e.target;
             draggedIndex = parseInt(draggedItem.getAttribute('data-index'));
             console.log('Drag started for index:', draggedIndex);
             // Use setTimeout to allow the browser to render the drag image before hiding/styling
             setTimeout(() => {
                 if (draggedItem) draggedItem.classList.add('dragging');
             }, 0);
             e.dataTransfer.effectAllowed = 'move';
             // Set dummy data for Firefox compatibility
             e.dataTransfer.setData('text/plain', draggedIndex);
         } else {
             e.preventDefault(); // Prevent dragging other elements within the container
         }
     }

     function handleDragOver(e) {
         e.preventDefault(); // Necessary to allow dropping
         e.dataTransfer.dropEffect = 'move';
         // Optional: Visual feedback for where the drop will occur
         const target = e.target.closest('.game-card');
         if (target && target !== draggedItem) {
             // Simple placeholder logic (can be improved)
             document.querySelectorAll('.game-card-placeholder').forEach(p => p.classList.remove('game-card-placeholder'));
             target.classList.add('game-card-placeholder');
         }
         return false;
     }


    function handleDragEnter(e) {
       // Added check to ensure we're entering a game card and not the dragged item itself
       const targetCard = e.target.closest('.game-card');
       if (targetCard && targetCard !== draggedItem) {
          targetCard.classList.add('game-card-placeholder');
       }
    }

    function handleDragLeave(e) {
       // Added check to ensure we're leaving a game card
        const targetCard = e.target.closest('.game-card');
        if (targetCard) {
           targetCard.classList.remove('game-card-placeholder');
        }
        // Also remove if leaving the container entirely but over an empty space
        if (!e.target.closest('.game-card') && e.relatedTarget && !e.relatedTarget.closest('.game-card')) {
           document.querySelectorAll('.game-card-placeholder').forEach(p => p.classList.remove('game-card-placeholder'));
        }
    }


    function handleDrop(e) {
       e.preventDefault(); // Prevent default drop behavior
       e.stopPropagation(); // Prevent drop event from bubbling up
       console.log('Drop handled.');

       const dropTarget = e.target.closest('.game-card');
       if (dropTarget && draggedItem && dropTarget !== draggedItem) {
          const dropIndex = parseInt(dropTarget.getAttribute('data-index'));

          // Reorder the 'games' array
          if (draggedIndex !== null && dropIndex !== null && draggedIndex !== dropIndex) {
             const itemToMove = games.splice(draggedIndex, 1)[0];
             games.splice(dropIndex, 0, itemToMove);
             saveGames(); // Save the new order
             updateGamesPage(); // Refresh the display
             console.log(`Dropped item from index ${draggedIndex} to ${dropIndex}. Games array reordered.`);
          }
       }
       // Clean up placeholder classes even if drop wasn't on a valid target
       document.querySelectorAll('.game-card-placeholder').forEach(p => p.classList.remove('game-card-placeholder'));
        console.log('Drag and drop cleanup complete.');

       return false;
    }


     function handleDragEnd(e) {
         console.log('Drag ended.');
         // Use setTimeout to ensure cleanup happens after potential drop event processing
         setTimeout(() => {
             if (draggedItem) {
                 draggedItem.classList.remove('dragging');
             }
             document.querySelectorAll('.game-card-placeholder').forEach(p => p.classList.remove('game-card-placeholder'));
             draggedItem = null; // Reset dragged item
             draggedIndex = null;
             console.log('Drag end cleanup complete.');
         }, 0);
     }


    // --- Theme Handling ---
    function setTheme(themeName) {
      console.log('Attempting to set theme:', themeName);
    
      const selectedTheme = themes.find(theme => theme.name === themeName);
    
      if (!selectedTheme) {
        console.error('Theme not found:', themeName);
        return;
      }
    
      // Apply CSS variables from the selected theme to the document root
      for (const [variable, value] of Object.entries(selectedTheme.variables)) {
        document.documentElement.style.setProperty(variable, value);
      }
    
      currentThemeName = themeName; // Update the current theme name state
      localStorage.setItem('theme', themeName);
      console.log('Theme applied and saved to localStorage:', themeName);
    
      // Update theme selector UI
      document.querySelectorAll('.theme-option').forEach(option => {
        option.classList.remove('selected');
        // Find the option element that corresponds to the selected theme's previewClass
        if (option.classList.contains(selectedTheme.previewClass)) {
          option.classList.add('selected');
        }
      });
      console.log('Theme selector UI updated.');
    
       // Update Vanta.js colors and parameters - Keep this logic as it is,
       // it reads computed styles after they are applied.
        if (vantaEffect) {
            console.log('Vanta.js effect exists, updating options...');
             // Use document.documentElement to get computed styles from :root
             setTimeout(() => { // Small delay to ensure styles are computed
                 const computedStyle = getComputedStyle(document.documentElement);
                 const themeBgDark = computedStyle.getPropertyValue('--bg-dark').trim();
                 console.log(`Computed --bg-dark for theme ${themeName} during setOptions:`, themeBgDark);
                 const newThemeBaseColor = colorToVantaFormat(themeBgDark);
                 console.log(`Converted Vanta.js baseColor for theme ${themeName} during setOptions:`, '0x' + newThemeBaseColor.toString(16));
    
                 vantaEffect.setOptions({
                   highlightColor: 0x0,
                   midtoneColor: 0x0,
                   lowlightColor: 0x0,
                   baseColor: newThemeBaseColor,
                   blurFactor: 0.56,
                   speed: 1.10,
                   zoom: 1.20
                 });
                 console.log('Vanta.js options updated.');
             }, 50);
           } else {
               console.log('Vanta.js effect not initialized (null) when setTheme was called. Skipping setOptions.');
           }
    }

    // --- Game Filtering & Display ---
    function filterGames() {
       const query = document.getElementById('gameSearch').value.toLowerCase();
       const container = document.getElementById('gamesContainerInner'); // Target inner container
       if (!container) {
         console.log('Games container not found for filtering.');
         return;
       }
       console.log('Filtering games with query:', query);


       const allCards = container.querySelectorAll('.game-card');
       let foundMatch = false;

       allCards.forEach(card => {
          const name = card.querySelector('p')?.textContent.toLowerCase();
          const matches = name ? name.includes(query) : false;
          card.style.display = matches ? '' : 'none';
          if (matches) foundMatch = true;
       });

        // Show "No games found" message if needed
        let noGamesMessage = container.querySelector('.no-games-message');
        const gamesToConsider = isShowingFavoriteGames() ? games.filter(game => favoriteGames.some(fav => fav.name === game.name)) : games;

        if (!foundMatch && gamesToConsider.length > 0 && !noGamesMessage && query) {
            // Filter active, no matches, but games exist
             noGamesMessage = document.createElement('p');
             noGamesMessage.className = 'no-games-message';
             noGamesMessage.style.color = 'var(--text-muted)';
             noGamesMessage.style.width = '100%';
             noGamesMessage.style.textAlign = 'center';
             container.appendChild(noGamesMessage);
        } else if ((foundMatch || !query) && noGamesMessage) {
             // Filter not active or matches found, remove message
             noGamesMessage.remove();
             noGamesMessage = null; // Reset variable
        }

        // Update message text based on state
        if (!foundMatch && noGamesMessage) {
             noGamesMessage.textContent = isShowingFavoriteGames() ? 'No favorite games match your search.' : 'No games match your search.';
        } else if (!foundMatch && !query && !noGamesMessage && gamesToConsider.length === 0) {
             // No filter, no games, no message exists yet - create it
              noGamesMessage = document.createElement('p');
              noGamesMessage.className = 'no-games-message';
              noGamesMessage.style.color = 'var(--text-muted)';
              noGamesMessage.style.width = '100%';
              noGamesMessage.style.textAlign = 'center';
              container.appendChild(noGamesMessage);
             noGamesMessage.textContent = isShowingFavoriteGames() ? 'No favorite games found.' : 'No games found.';
        }
        console.log('Game filtering complete. Found matches:', foundMatch);

    }

    function updateGamesPage() {
           console.log('Updating Games page content. Showing favorites:', isShowingFavoriteGames());
           const gamesToDisplay = isShowingFavoriteGames() ?
             games.filter(game => favoriteGames.some(fav => fav.name === game.name)) :
             games;
    
           // Generate the cards first
           const gameCardsHTML = gamesToDisplay.map((game, index) => {
             // Find original index to use for actions (like remove/favorite/proxy)
             const originalIndex = games.findIndex(g => g.name === game.name);
             // Ensure the index is valid before generating the card
             if (originalIndex === -1) return ''; // Skip if game not found in main list
    
             return `
               <div class="game-card" draggable="true" data-index="${originalIndex}">
                 <div class="remove-icon" onclick="removeGame(event, ${originalIndex})" title="Remove Game">
                   <i class="fas fa-times"></i>
                 </div>
                 <img src="${escapeHtml(game.icon)}" alt="${escapeHtml(game.name)}"
                      onerror="this.src='https://via.placeholder.com/150?text=No+Image'"
                      onclick="loadGame('${escapeHtml(game.name)}', '${escapeHtml(game.url)}')">
                 <p onclick="loadGame('${escapeHtml(game.name)}', '${escapeHtml(game.url)}')">${escapeHtml(game.name)}</p>
                 <div style="display: flex; flex-direction: column; gap: 5px; align-items: center; margin-top: 5px;">
                   <button class="favorite-button" onclick="event.stopPropagation(); toggleFavoriteGame(${originalIndex})">
                     <i class="fas ${isFavoriteGame(game) ? 'fa-solid' : 'fa-regular'} fa-star" style="${isFavoriteGame(game) ? 'color: var(--accent);' : ''}"></i>
                     <span>${isFavoriteGame(game) ? 'Favorited' : 'Favorite'}</span>
                   </button>
                   ${game.proxiedUrl && game.proxiedUrl !== 'none' ? // Only show proxy toggle if proxy URL exists
                     `<button class="favorite-button" onclick="event.stopPropagation(); toggleProxied(${originalIndex})">
                       <i class="fas fa-shield-alt"></i>
                       <span>Proxy: ${game.proxied ? 'On' : 'Off'}</span>
                     </button>`
                     : ''
                   }
                 </div>
               </div>`;
             }).join('');
    
    
           // Return the full container HTML
           const gamesContent = `
             <input type="text" id="gameSearch" placeholder="Search Games..." oninput="filterGames()" style="width: 90%; max-width: 400px; margin: 0 auto 1.5rem auto; display: block;">
             <div class="games-header">
               <div class="action-card" onclick="showAddGameModal()">
                 <i class="fas fa-plus"></i>
                 <p>Add Game</p>
               </div>
               <div class="action-card" onclick="toggleFavoriteGamesView()">
                 <i class="fas fa-star" style="${isShowingFavoriteGames() ? 'color: var(--accent);' : ''}"></i>
                 <p>${isShowingFavoriteGames() ? 'All Games' : 'Favorites'}</p>
               </div>
             </div>
             <div class="games-container" id="gamesContainerInner">
                 ${gameCardsHTML || '<p class="no-games-message" style="color: var(--text-muted); width: 100%; text-align: center;">No games found.</p>'}
             </div>`;
    
    
          // Update the page content ONLY if we are currently displaying the Games or Favorite Games view
           // Check the actual pageTitle text to know if we are *conceptually* on the games page view
          if (pageTitle.textContent === 'Games' || pageTitle.textContent === 'Favorite Games') {
             pageContent.innerHTML = gamesContent; // Set the innerHTML
             console.log('Games page HTML updated.');
             // Re-run setup for drag/drop as elements were replaced
             setupDragAndDrop();
             // Restore search term if it exists
             const searchInput = document.getElementById('gameSearch');
             if (searchInput && searchInput.value) {
                filterGames(); // Re-apply filter
             } else {
                 // If no search term, ensure initial "No games found" message is correct
                 const container = document.getElementById('gamesContainerInner');
                  const gamesToConsider = isShowingFavoriteGames() ? games.filter(game => favoriteGames.some(fav => fav.name === game.name)) : games;
                 if (container && gamesToConsider.length === 0 && !container.querySelector('.no-games-message')) {
                     let noGamesMessage = document.createElement('p');
                     noGamesMessage.className = 'no-games-message';
                     noGamesMessage.style.color = 'var(--text-muted)'; // This line was potentially the issue or nearby
                     noGamesMessage.style.width = '100%';
                     noGamesMessage.style.textAlign = 'center';
                     noGamesMessage.textContent = isShowingFavoriteGames() ? 'No favorite games found.' : 'No games found.';
                     container.appendChild(noGamesMessage);
                      console.log('Displayed initial "No games found" message.');
                 } else if (container && gamesToConsider.length > 0 && container.querySelector('.no-games-message') && !searchInput.value) {
                     // Games now exist, and no filter is active, remove the "No games found" message
                     container.querySelector('.no-games-message').remove();
                      console.log('Removed "No games found" message as games are present.');
                 }
    
             }
          } else {
              console.log('Not on Games or Favorite Games page, skipping content update.');
          }
          // Updating pages.Games might not be necessary if content is always generated
          // pages.Games = gamesContent;
        }


    // --- Library Page ---
     function updateLibraryPage() {
       console.log('Updating Library page content.');
       const favoritedWebsitesContainer = document.getElementById('favoritedWebsites');
       const recentlyViewedContainer = document.getElementById('recentlyViewed');

       if (!favoritedWebsitesContainer || !recentlyViewedContainer) {
         console.log('Library containers not found, skipping update.');
         return;
       }

       const favoritedWebsites = library; // Already loaded in loadData
       const recentlyViewed = JSON.parse(localStorage.getItem('recentlyViewed')) || [];

       favoritedWebsitesContainer.innerHTML = favoritedWebsites.length > 0 ? favoritedWebsites.map((item, index) => `
         <div class="library-item" data-url="${escapeHtml(item)}">
           <div class="remove-icon" onclick="removeLibraryItem(event, ${index})" title="Remove Favorite">
             <i class="fas fa-times"></i>
           </div>
           <div class="library-item-content" onclick="loadViewerFromLibrary('${escapeHtml(item)}', '${escapeHtml(item)}')">
             ${escapeHtml(item)}
           </div>
         </div>
       `).join('') : '<p class="no-results-message" style="color: var(--text-muted); text-align: center;">No favorites added yet.</p>'; // Added class here

       recentlyViewedContainer.innerHTML = recentlyViewed.length > 0 ? recentlyViewed.slice(0, 10).map(item => `
         <div class="library-item">
           <div class="library-item-content" onclick="loadViewerFromLibrary('${escapeHtml(item)}', '${escapeHtml(item)}')">
             ${escapeHtml(item)}
           </div>
         </div>
       `).join('') : '<p style="color: var(--text-muted); text-align: center;">No recently viewed sites.</p>';

        console.log('Library HTML updated.');

       // Re-apply filter if search box has value
       const searchInput = document.getElementById('librarySearch');
       if (searchInput && searchInput.value) {
          filterLibrary();
       }
     }


function loadGame(name, url) {
      console.log('loadGame() called for:', name, url);
      const game = games.find(g => g.name === name);
      const useProxy = game && game.proxied && game.proxiedUrl && game.proxiedUrl !== 'none';
      const targetUrl = useProxy ? game.proxiedUrl : url;
      const displayUrl = useProxy ? "Proxy Active" : url;

      if (useProxy) {
        console.log('Proxy mode active. Loading proxied game in viewer:', game.proxiedUrl);
        // Removed the window.open and setInterval logic
        loadViewerFromLibrary(game.proxiedUrl, name, displayUrl, true); // Pass true to update recents
      } else {
        console.log('Direct game load:', url);
        loadViewerFromLibrary(url, name, displayUrl, true); // Pass true to update recents
      }
    }



    // --- Favorites ---
    function toggleFavoriteGame(index) {
      console.log('Toggling favorite for game index:', index);
      if (index < 0 || index >= games.length) {
        console.error("Invalid index for toggleFavoriteGame:", index);
        return; // Index check
      }
    
      const game = games[index];
      const gameName = game.name; // Use name for consistency
      const isCurrentlyFavorite = favoriteGames.some(favGame => favGame.name === gameName);
    
      if (isCurrentlyFavorite) {
        favoriteGames = favoriteGames.filter(favGame => favGame.name !== gameName);
        console.log('Removed game from favorites.');
      } else {
        // Add a minimal representation to favorites if not already there
         if (!favoriteGames.some(fav => fav.name === gameName)) {
           favoriteGames.push({ name: gameName }); // Store only name or minimal needed data
           console.log('Added game to favorites.');
         } else {
            console.log('Game was already in favorites list (check logic).');
         }
      }
      localStorage.setItem('favoriteGames', JSON.stringify(favoriteGames));
       console.log('Favorite games saved:', favoriteGames.length);
    
    
      // Update UI immediately for the specific card
      // Check if the clicked button is within the Game of the Day container
      const gameOfTheDayContainer = document.getElementById('game-of-day-container');
      let button = null;
    
      if (gameOfTheDayContainer && gameOfTheDayContainer.contains(event.target)) {
          // If the clicked element is inside the Game of the Day container,
          // find the favorite button relative to the container.
          // This assumes there's only one favorite button within the game-of-day-container's .game-card
          button = gameOfTheDayContainer.querySelector('.favorite-button');
          console.log('Updating favorite button in Game of the Day container.');
    
      } else {
          // Otherwise, assume it's a button on the main Games page
           button = document.querySelector(`.game-card[data-index="${index}"] .favorite-button`);
           console.log('Updating favorite button on Games page.');
      }
    
    
      if (button) {
        const icon = button.querySelector('i.fa-star');
        const span = button.querySelector('span');
        const isFavoriteNow = isFavoriteGame(game); // Check the state again after toggling
        if (isFavoriteNow) {
           if(icon) {
             icon.classList.remove('fa-regular');
             icon.classList.add('fa-solid'); // Add solid class for filled
             icon.style.color = 'var(--accent)'; // Accent color for filled star
           }
           if(span) span.textContent = 'Favorited';
        } else {
           if(icon) {
             icon.classList.remove('fa-solid');
             icon.classList.add('fa-regular'); // Add regular class for outline
             icon.style.color = ''; // Reset color
           }
           if(span) span.textContent = 'Favorite';
        }
         console.log('Favorite button UI updated.');
      } else {
         console.warn('Favorite button not found for index:', index);
      }
    
    
      // If currently showing favorites view on the Games page, re-render
       if (isShowingFavoriteGames() && pageTitle.textContent === 'Favorite Games') { // Check state and current page title
          console.log('Currently showing favorites view on Games page, re-rendering.');
          updateGamesPage(); // Re-render the list based on the updated favoriteGames array
       } else {
           console.log('Not on Favorite Games page or showing all games, skipping full re-render.');
       }
    }


    function isFavoriteGame(game) {
       // Check against the favoriteGames array (which might store just names or full objects)
       return favoriteGames.some(fav => fav.name === game.name);
    }

    function isShowingFavoriteGames() {
      return showingFavorites; // Check the state variable
    }

    function toggleFavoriteGamesView() {
      showingFavorites = !showingFavorites; // Flip state
      console.log('Toggling favorite games view. showingFavorites:', showingFavorites);

      // Update the action card's appearance (Favorites/All Games button)
      const favActionCard = document.querySelector('.games-header .action-card:nth-child(2)'); // Target the Favorites/All Games action card

      if (favActionCard) {
          const icon = favActionCard.querySelector('i.fa-star');
          const textP = favActionCard.querySelector('p');

          if (showingFavorites) {
               if (icon) {
                   icon.classList.remove('fa-regular');
                   icon.classList.add('fa-solid'); // Use fa-solid for filled star
                   icon.style.color = 'var(--accent)'; // Apply accent color
               }
               if (textP) textP.textContent = 'All Games';
               console.log('Updated action card to show All Games.');
          } else {
               if (icon) {
                   icon.classList.remove('fa-solid');
                   icon.classList.add('fa-regular'); // Use fa-regular for outline star
                    icon.style.color = ''; // Remove accent color
               }
               if (textP) textP.textContent = 'Favorites';
                console.log('Updated action card to show Favorites.');
          }
      } else {
         console.warn('Favorite games action card not found.');
      }


      // Update the page title based on the new state - HIDE for Home page
       if (pageTitle.textContent !== 'Home') {
         pageTitle.textContent = showingFavorites ? 'Favorite Games' : 'Games';
         pageTitle.style.display = 'block'; // Show title for Games/Favorites page
         console.log('Updated page title:', pageTitle.textContent);
       } else {
          pageTitle.style.display = 'none';
          console.log('Hid page title on Home.');
       }


      // Re-render the games list based on the new state
      updateGamesPage();
    }
    const cloakPresets = {
        goguardian: { title: 'GoGuardian Admin', favicon: 'https://www.goguardian.com/favicon.ico' },
        drive: { title: 'My Drive - Google Drive', favicon: 'https://ssl.gstatic.com/images/branding/product/1x/drive_2020q4_32dp.png' },
        classroom: { title: 'Classes', favicon: 'https://ssl.gstatic.com/classroom/favicon.png' },
        // 'custom' will use the values saved via 'App Appearance'
        custom: { title: null, favicon: null } // Placeholder
    };

    function applyPresetCloak() {
        const select = document.getElementById('tabCloakSelect');
        if (!select) {
            console.error("Tab cloak select element not found.");
            alert("Error: Could not find tab cloak dropdown.");
            return;
        }
        const selectedValue = select.value;
        let settingsToApply;

        if (selectedValue === 'custom') {
            // Load custom settings from localStorage
            const savedAppSettings = localStorage.getItem('appSettings');
            settingsToApply = savedAppSettings ? JSON.parse(savedAppSettings) : { title: 'Underground', favicon: '' }; // Default if no custom saved
             console.log('Applying custom cloak settings from App Appearance.');
        } else if (cloakPresets[selectedValue]) {
            settingsToApply = {
                tabTitle: cloakPresets[selectedValue].title,
                faviconUrl: cloakPresets[selectedValue].favicon
            };
             console.log(`Applying preset cloak: ${selectedValue}`);
        } else {
             console.error(`Invalid cloak preset selected: ${selectedValue}`);
             alert("Invalid cloak option selected.");
             return;
        }

        // Apply the settings
        applyAppSettings(settingsToApply);

        // Save the *choice* of preset (or 'custom') so it can be re-selected on load
        localStorage.setItem('currentCloakPreset', selectedValue);

        alert(`Tab cloak applied: ${select.options[select.selectedIndex].text}`);
    }

    function resetCloak() {
        console.log('Resetting tab cloak to default (Underground).');
        // Reset to the application's default title and potentially remove favicon
        const defaultSettings = {
            tabTitle: 'Underground', // Your app's default name
            faviconUrl: '' // Default (no favicon)
        };
        applyAppSettings(defaultSettings);

        // Remove the saved preset choice and custom settings
        localStorage.removeItem('currentCloakPreset');
        // Optionally, you might want to keep custom settings but just un-apply the cloak:
        // localStorage.setItem('currentCloakPreset', 'custom'); // Revert selection to custom
        // const savedAppSettings = localStorage.getItem('appSettings');
        // if (savedAppSettings) applyAppSettings(JSON.parse(savedAppSettings));

        // Update the dropdown selection
        const select = document.getElementById('tabCloakSelect');
        if (select) {
            select.value = 'custom'; // Set dropdown to custom after reset
        }

        alert("Tab cloak reset to default.");
    }

    // Function to load and apply the saved cloak state when settings page loads
    function loadTabCloakSettings() {
        const savedPreset = localStorage.getItem('currentCloakPreset');
        const select = document.getElementById('tabCloakSelect');

        if (select && savedPreset) {
            select.value = savedPreset;
            console.log(`Loaded saved cloak preset selection: ${savedPreset}`);
            // Optional: Automatically re-apply the cloak based on saved preset?
            // applyPresetCloak(); // Be cautious if this has side effects on initial load
        } else if (select) {
             select.value = 'custom'; // Default to custom if nothing saved
              console.log('No saved cloak preset found, defaulting select to custom.');
        }
    }
      
    // --- Page Definitions & Switching ---
const pages = {
        Home: `
            <div class="home-layout">
                <div class="home-header">
                    <div class="home-logo">undergr0und</div>
                </div>
                <div class="home-main-section">
                     <button class="changelog-button" onclick="openChangelogModal()" title="View Changelog"><i class="fas fa-list-alt"></i> Changelog</button>
                     <div class="home-search-container">
                         <i class="fas fa-search search-icon"></i>
                         <input type="text" id="homeSearchInput" placeholder="Search or type a URL" onkeydown="if(event.key==='Enter') loadViewer()">
                     </div>
                     <div class="home-status">
                        <p>Hidden: <span style="color: green;">True</span></p>
                        <p>Installed: <span id="home-installed-version">v1.0.0</span></p>
                        <p>Latest: <span id="home-latest-version">Checking...</span></p>
                    </div>
                </div>

                <div class="home-bottom-section">
                    <div class="panel home-news-panel">
                        <h2>News</h2>
                        <pre id="news-content" style="white-space: pre-wrap; font-family: inherit; text-align: left;"></pre>
                    </div>
                    <div class="game-of-day-container" id="game-of-day-container">
                        </div>
                </div>
            </div>
        `,
        Library: `
            <div class="panel" style="width: 95%; max-width: 900px;">
              <h2>Library</h2>
              <input type="text" id="librarySearch" placeholder="Search Favorites..." oninput="filterLibrary()">
              <div class="library-columns">
                <div class="library-column">
                  <h3><i class="fas fa-star" style="color:var(--accent); margin-right: 5px;"></i>Favorites</h3>
                  <div id="favoritedWebsites" style="max-height: 60vh; overflow-y: auto;"></div>
                </div>
                <div class="library-column">
                  <h3><i class="fas fa-history" style="color:var(--accent); margin-right: 5px;"></i>Recents</h3>
                  <div id="recentlyViewed" style="max-height: 60vh; overflow-y: auto;"></div>
                </div>
              </div>
            </div>`,
        Viewer: `<div class="panel"><h2>Viewer</h2><p>Click the globe icon or use the search bar on the Home page to launch the viewer.</p></div>`, // Simplified Viewer page, main viewing happens in iframe overlay
        Games: ``, // Placeholder - content is dynamically generated
        Music: `
          <div class="music-player-grid">
              <div class="music-box">
                  <h2>Add Music</h2>
                  <p>Select audio files or a folder (requires folder permission for persistence).</p>
                  <button onclick="mp_selectMusicDirectory()">Select Folder</button>
                  <input type="file" id="mp_fileInput" multiple accept="audio/*" webkitdirectory directory style="display: none;">
                  <div style="height: 10px;"></div> <button class="secondary" onclick="mp_openRemoveSongsModal()">Remove Songs</button>
              </div>

              <div class="music-box">
                  <h2>Songs</h2>
                  <input type="search" id="mp_songSearch" placeholder="Search all songs...">
                  <div class="scrollable-list" id="mp_songsList">
                      <p class="placeholder-text">Upload songs to see your library</p>
                  </div>
              </div>

              <div class="music-box">
                  <h2>Recently Played</h2>
                  <div class="scrollable-list" id="mp_recentlyPlayedList">
                       <p class="placeholder-text">Play a song to see it here</p>
                  </div>
              </div>

              <div class="music-box">
                  <h2>Playlists</h2>
                  <button onclick="mp_openCreatePlaylistModal()">Create New Playlist</button>
                  <div class="scrollable-list" id="mp_playlistsList">
                       <p class="placeholder-text">Create a playlist to see it here</p>
                  </div>
              </div>
          </div>
        `,
        Updater: `
            <div class="panel">
              <h2>Updater</h2>
              <p>This section is for future update functionality.</p>
              <button onclick="checkForUpdatesManual()">Check Manually</button>
              <p id="update-status-message" style="color: var(--text-muted); margin-top: 1rem;">Status: Idle</p>
               <button onclick="openChangelogModal()" style="margin-top: 1rem;">View Changelog</button> </div>`,
        Settings: `
        <div class="settings-grid-container">
          <div class="settings-grid-item">
             <h2>Theme</h2>
             <h3>Theme Selection</h3>
              <div class="theme-selector" id="themeSelector">
                  ${themes.map(theme => `
                      <div class="theme-option ${theme.previewClass}"
                           onclick="setTheme('${theme.name}')"
                           title="${theme.name.charAt(0).toUpperCase() + theme.name.slice(1)}">
                      </div>
                  `).join('')}
              </div>
               <button class="setting-reset-button" onclick="resetThemeSettings()" title="Reset Theme to Default">
                   <i class="fas fa-undo"></i> Reset
               </button>
          </div>

          <div class="settings-grid-item">
            <h2>About:Blank</h2>
            <p>Cloak the site in an about:blank page and toggle about:blank on startup.</p>
            <div style="display: flex; align-items: center; gap: 10px; justify-content: center; flex-direction: column; height: 100%;">
                <div style="display: flex; align-items: center; gap: 10px;">
                     <label class="switch">
                       <input type="checkbox" id="aboutBlankToggle" onclick="toggleAboutBlankStartup()" checked>
                       <span class="slider round"></span>
                     </label>
                     <span>Enabled on Startup</span>
                </div>
                <button onclick="openAppInAboutBlank()">Open Popup Now</button>
            </div>
               <button class="setting-reset-button" onclick="resetAboutBlankSettings()" title="Reset About:Blank Setting">
                   <i class="fas fa-undo"></i> Reset
               </button>
          </div>

          <div class="settings-grid-item">
            <h2>Panic Key</h2>
             <p>Quick open another site with one press.</p>
             <input type="text" id="panicKeyInput" placeholder="Enter Key (e.g., Escape, Alt+Q)">
             <input type="text" id="panicUrlInput" placeholder="Redirect URL (e.g., https://google.com)">
             <button onclick="savePanicKeySettings()">Save Panic Key</button>
               <button class="setting-reset-button" onclick="resetPanicKeySettings()" title="Reset Panic Key">
                   <i class="fas fa-undo"></i> Reset
               </button>
          </div>

          <div class="settings-grid-item">
            <h2>Presets</h2>
            <p>Change the title and icon using presets.</p>
             <select id="tabCloakSelect">
              <option value="goguardian">GoGuardian Admin Block</option>
              <option value="drive">Google Drive</option>
              <option value="classroom">Google Classroom</option>
              <option value="custom">Custom (Use App Appearance)</option>
            </select>
            <button onclick="applyPresetCloak()">Apply Cloak</button>
            <button class="setting-reset-button" onclick="resetCloak()" title="Reset Tab Cloak to Default">
                <i class="fas fa-undo"></i> Reset
            </button>
             </div>

          <div class="settings-grid-item">
               <h2>App Appearance</h2>
               <p>Set a custom title and icon (favicon). Used by 'Custom' cloak.</p>
               <input type="text" id="appTabTitleInput" placeholder="Custom Tab Title">
               <input type="text" id="appFaviconUrlInput" placeholder="Custom Favicon URL">
               <button onclick="saveAppSettings()">Save App Appearance</button>
               <button class="setting-reset-button" onclick="resetAppAppearanceSettings()" title="Reset App Appearance to Default">
                   <i class="fas fa-undo"></i> Reset
               </button>
          </div>


           <div class="settings-grid-item">
            <h2>Reset All Data
                </h2>
            <p>This deletes all saved data (games, library, all settings).</p>
            <button class="reset-button" onclick="resetApp()">
              <i class="fas fa-trash-alt"></i> Reset App Data
            </button>
           </div>

           </div>
    `,
       About: `
            <div class="panel" style="max-width: 500px; text-align: left;">
              <h2>About Underground</h2>
              <p>Underground is a fully custom game launcher and viewer focused on providing a simple, user-friendly interface for accessing online games and websites to circumvent internet censorship</p>
              <p>Version: <span id="about-version">1.0.0</span></p>
              <p>Created by: Zerone</p>
              <p>
                <a href="#" onclick="openChangelogModal(); return false;" style="color: var(--accent); text-decoration: none;">View Changelog</a> |
                <a href="https://github.com/ZeroneV1" style="color: var(--accent); text-decoration: none;">Contact</a>
              </p>
              <h3 style="margin-top: 1rem;">Credits:</h3>
              <p style="font-size: 0.9rem;">
                Uses: Vanta.js, Three.js, Font Awesome.<br>
              </p>
              <h3 style="margin-top: 1rem;">Disclaimer:</h3>
              <p style="font-size: 0.8rem; color: var(--text-muted);">
                Underground is a third-party application. We are not affiliated with external websites or games. Use responsibly.
              </p>
            </div>
        `,
    };

    function checkForUpdatesManual() {
        console.log('Manual update check requested.');
        const statusEl = document.getElementById('update-status-message');
        if(statusEl) statusEl.textContent = "Status: Checking for updates...";
        // Add actual update check logic here if needed
        setTimeout(() => {
             if(statusEl) statusEl.textContent = "Status: No updates found (manual check).";
             console.log('Manual update check simulation complete.');
        }, 2000);
    }


    // --- Replace your existing switchPage function with this ---
    function switchPage(pageKey) {
       console.log('Switching to page:', pageKey);

       // Update page title visibility and content based on the target page
       if (pageKey === 'Games') {
           showingFavorites = false; // Reset view to 'All Games' when entering Games page
           pageTitle.textContent = 'Games'; // Set title
           pageTitle.style.display = 'block'; // Show title
           console.log('Switched to Games page. Resetting favorites view state.');
       } else if (pageKey === 'Home') {
           pageTitle.style.display = 'none'; // Hide title on Home page
           console.log('Switched to Home page. Hiding page title.');
            // Reset favorite view state if coming from Games page
            if (showingFavorites) {
                 showingFavorites = false;
                 console.log('Came from favorites view, resetting showingFavorites state.');
            }
       } else { // For all other pages (Library, Music, Settings, About, etc.)
            pageTitle.textContent = pageKey; // Use the key as the title
            pageTitle.style.display = 'block'; // Show title
            console.log('Switched to page:', pageKey, 'Showing page title.');
           // Reset favorite view state if coming from Games page
           if (showingFavorites) {
               showingFavorites = false;
                console.log('Came from favorites view on another page, resetting showingFavorites state.');
           }
       }

       // Fade out current content
       pageContent.classList.add('fade-out');
       console.log('Adding fade-out class to content.');

       // Wait for fade-out transition, then update content and fade in
       setTimeout(() => {
         console.log('Timeout before content switch complete.');
         // Set new page content from the 'pages' object
         pageContent.innerHTML = pages[pageKey] || `<div class="panel"><p>Content for ${pageKey} not found.</p></div>`; // Added default panel
         console.log(`Content set for page: ${pageKey}. Content found: ${!!pages[pageKey]}`);

         // --- Page-Specific Initialization ---
         if (pageKey === 'Music') {
             console.log("MP: Initializing Music page content via switchPage.");
             // This function will now handle getting elements and calling render internally
             mp_initializeMusicPlayerPage();

             // REMOVED the redundant setTimeout block with rendering calls here.
             // Rendering is now handled within mp_initializeMusicPlayerPage after element refs are obtained.

             // Ensure playback bar is visible if music has ever been loaded/played or library exists
             if (mp_playbackControlsBar && (mp_currentSong || mp_musicLibrary.length > 0)) {
                 mp_playbackControlsBar.style.display = 'flex';
             } else {
                 // If navigating *away* from Music and playback bar should hide, handle that here
                 // Although the initial CSS display: none and the check above should suffice
             }
         } else {
              // Hide the music playback bar when switching away from the Music page
              if (mp_playbackControlsBar) {
                  mp_playbackControlsBar.style.display = 'none';
              }
              // Optional: You could add logic here if you need to *clean up* music player listeners
              // when navigating away, but it's often not necessary if handled correctly on init.
         }

         // Handle initialization/updates for other pages
         if (pageKey === 'Games') {
            updateGamesPage(); // This generates HTML and calls setupDragAndDrop
            // Note: setupDragAndDrop() should be called within updateGamesPage()
         } else if (pageKey === 'Library') {
           updateLibraryPage(); // Updates library lists and handles filtering
         } else if (pageKey === 'Home') {
           checkVersion(); // Check/display version info
           fetchNews();    // Fetch news and Game of the Day
           console.log('Home page specific actions (checkVersion, fetchNews) triggered.');
         } else if (pageKey === 'Settings') {
             // Load and apply specific settings UI states
             loadTabCloakSettings(); // Set the cloak dropdown correctly
             // Ensure theme selector reflects current theme (setTheme handles this visually if called)
             setTheme(currentThemeName); // Re-apply to ensure selection marks are correct
             // Load panic key values into inputs
             const keyInput = document.getElementById('panicKeyInput');
             const urlInput = document.getElementById('panicUrlInput');
             if (keyInput && panicKey) keyInput.value = panicKey;
             if (urlInput && panicUrl) urlInput.value = panicUrl;
              // Load App Appearance values into inputs
             const appTitleInput = document.getElementById('appTabTitleInput');
             const appIconInput = document.getElementById('appFaviconUrlInput');
             const currentAppSettings = JSON.parse(localStorage.getItem('appSettings') || '{}');
             if (appTitleInput) appTitleInput.value = currentAppSettings.tabTitle || 'Underground';
             if (appIconInput) appIconInput.value = currentAppSettings.faviconUrl || '';
              // Load About:Blank toggle state
             const aboutBlankToggle = document.getElementById('aboutBlankToggle');
             const aboutBlankPref = localStorage.getItem('aboutBlankOnStartup');
             if (aboutBlankToggle) aboutBlankToggle.checked = aboutBlankPref !== 'false';

             console.log('Settings page specific UI states loaded.');
         } else if (pageKey === 'About') {
             // Update version number on About page if needed
             const aboutVersionEl = document.getElementById('about-version');
             if (aboutVersionEl) aboutVersionEl.textContent = "v1.0.0"; // Replace with dynamic version if available
             console.log('About page loaded.');
         }

         // Fade in new content
         pageContent.classList.remove('fade-out');
         console.log('Removing fade-out class, content should fade in.');

         // Update active icon in the sidebar
         icons.forEach(i => {
             i.classList.remove('active');
             // Activate icon if its data-page matches the current pageKey AND it's not the Viewer icon
             // (Viewer icon click doesn't change the main page, it opens an overlay)
             if (i.getAttribute('data-page') === pageKey && pageKey !== 'Viewer') {
                 i.classList.add('active');
             }
         });
         console.log('Active sidebar icon updated.');

         // Save the last active page to localStorage (optional but good for remembering state)
         localStorage.setItem('lastActivePage', pageKey);
         localStorage.setItem('lastActivePageTitle', pageTitle.textContent); // Save the displayed title too

       }, 150); // Match this delay to your CSS transition duration for fade-out
     }

    function handleIconClick() {
      const page = this.getAttribute('data-page');
      console.log('Sidebar icon clicked for page:', page);


      if (page === 'Viewer') {
          // Clicking the Viewer icon now launches the overlay directly
          // Call loadViewerFromLibrary with no URL to open the controls only
          loadViewerFromLibrary();
          console.log('Viewer icon clicked, launching viewer overlay.');
          // Do NOT call switchPage here, as we are staying on the current background page
          // No need to change active icon as the overlay covers everything
      } else {
          // For all other icons, perform normal page switching
          switchPage(page);
           console.log('Non-Viewer icon clicked, calling switchPage.');
      }
    }

    function handleTooltipShow(e) {
       // Debounce or throttle tooltip updates if performance becomes an issue
       tooltip.style.left = `${e.clientX + 15}px`; // Use clientX for fixed sidebar
       tooltip.style.top = `${e.clientY}px`;   // Use clientY
       tooltip.textContent = this.getAttribute('title');
       tooltip.style.display = 'block';
    }


    function handleTooltipHide() {
      tooltip.style.display = 'none';
    }

    // --- Library Management ---
    function addToLibraryFromHome() {
        console.log('addToLibraryFromHome() called.');
        const urlInput = document.getElementById('homeSearchInput'); // Get input from Home page
        const url = urlInput ? urlInput.value.trim() : null;
        addToLibrary(url);
        // Keep the text in the input box on the Home page
    }

    function addToLibraryFromViewer(url) {
         console.log('addToLibraryFromViewer() called with URL:', url);
         addToLibrary(url); // Add the URL currently in the viewer
    }


    function addToLibrary(url) {
      console.log('addToLibrary() called with URL:', url);
      if (!url) {
        alert('Please enter a URL first.');
        console.warn('addToLibrary failed: No URL provided.');
        return;
      }
       let finalUrl = url;
        if (!url.startsWith('http://') && !url.startsWith('https://')) {
         finalUrl = 'https://' + url;
         console.log('Prepended https to URL for library:', finalUrl);
       }

      if (!library.includes(finalUrl)) {
          library.push(finalUrl);
          localStorage.setItem('library', JSON.stringify(library));
          alert('Added to Library favorites!');
          console.log('Added to library:', finalUrl);
          // Update library view if currently visible
          if (pageTitle.textContent === 'Library') {
              updateLibraryPage();
               console.log('Library page is active, updating view.');
          }
      } else {
          alert('This URL is already in your Library favorites.');
          console.log('URL already in library:', finalUrl);
      }
    }


    function removeLibraryItem(event, index) {
      event.stopPropagation(); // Prevent triggering item click
      console.log('Attempting to remove library item at index:', index);
      if (index >= 0 && index < library.length) {
         const itemToRemove = library[index];
         if (confirm(`Remove "${itemToRemove}" from favorites?`)) {
            library.splice(index, 1);
            localStorage.setItem('library', JSON.stringify(library));
            updateLibraryPage(); // Refresh the library view
            console.log('Library item removed:', itemToRemove);
         }
      } else {
          console.error("Invalid index for removeLibraryItem:", index);
      }
    }


    function filterLibrary() {
       const query = document.getElementById('librarySearch').value.toLowerCase();
       const container = document.getElementById('favoritedWebsites'); // Target only favorites for filtering
       if (!container) {
         console.log('Favorited websites container not found for filtering.');
         return;
       }
        console.log('Filtering library favorites with query:', query);


       const allItems = container.querySelectorAll('.library-item');
       let foundMatch = false;

       allItems.forEach(item => {
          const url = item.getAttribute('data-url')?.toLowerCase(); // Use data-url
          const matches = url ? url.includes(query) : false;
          item.style.display = matches ? 'flex' : 'none'; // Use 'flex' as display type
          if (matches) foundMatch = true;
       });

        // Add/remove 'no results' message
        let noResultsMessage = container.querySelector('.no-results-message');
        const itemsToConsider = library; // Filtering the entire library list


        if (!foundMatch && itemsToConsider.length > 0 && !noResultsMessage && query) {
             // Filter active, no matches, but items exist
             noResultsMessage = document.createElement('p');
             noResultsMessage.className = 'no-results-message';
             noResultsMessage.style.color = 'var(--text-muted)';
             noResultsMessage.style.textAlign = 'center';
             noResultsMessage.style.width = '100%';
             container.appendChild(noResultsMessage);
             console.log('Created no-results message for filter.');
        } else if ((foundMatch || !query) && noResultsMessage) {
            // Filter not active or matches found, remove message
            noResultsMessage.remove();
            noResultsMessage = null; // Reset variable
             console.log('Removed no-results message.');
        }

        // Update message text based on state
        if (!foundMatch && noResultsMessage) {
             noResultsMessage.textContent = 'No favorites match your search.';
        } else if (!foundMatch && !query && !noResultsMessage && itemsToConsider.length === 0) {
             // No filter, no items, no message exists yet - create it
              noResultsMessage = document.createElement('p');
              noResultsMessage.className = 'no-results-message';
              noResultsMessage.style.color = 'var(--text-muted)';
              noResultsMessage.style.textAlign = 'center';
              noResultsMessage.style.width = '100%';
              container.appendChild(noResultsMessage);
             noResultsMessage.textContent = 'No favorites added yet.';
              console.log('Created initial no-favorites message.');
        }
        console.log('Library filtering complete. Found matches:', foundMatch);
    }


    // --- App Reset ---
    function resetApp() {
      console.log('Reset App requested.');
      if (confirm("Reset App? This deletes all custom games, library favorites, viewed history, and settings.")) {
        console.log('Reset confirmed.');
        // Clear localStorage
        localStorage.clear();
        console.log('localStorage cleared.');

        // Reset state variables
        games = []; // Will be repopulated by loadData
        library = [];
        favoriteGames = [];
        currentTheme = 'default';
        localStorage.setItem('theme', 'default'); // Set default theme immediately
        showingFavorites = false; // Reset favorite view state
        console.log('App state variables reset.');

        // Reload data (which includes defaults) and re-initialize UI
        loadData(); // This will set the default theme class
        setTheme('default'); // Explicitly call setTheme to update Vanta.js etc.
        initializeVanta(); // Re-initialize Vanta with default theme (although setTheme should handle this after init)
        switchPage('Home'); // Go to home page

        alert("App has been reset.");
        console.log('App reset complete.');
      } else {
          console.log('Reset cancelled.');
      }
    }
// --- Panic Key ---
    let panicKey = null;
    let panicUrl = null;

    function savePanicKeySettings() {
        const keyInput = document.getElementById('panicKeyInput');
        const urlInput = document.getElementById('panicUrlInput');

        if (keyInput && urlInput) {
            const key = keyInput.value.trim();
            const url = urlInput.value.trim();

            if (!key || !url) {
                alert("Please enter both a key and a URL for the panic key.");
                return;
            }
             // Basic URL validation (add https:// if missing)
             let finalUrl = url;
             if (!finalUrl.startsWith('http://') && !finalUrl.startsWith('https://')) {
                 finalUrl = 'https://' + finalUrl;
             }

            // Save to localStorage and update global variables
            localStorage.setItem('panicKey', key);
            localStorage.setItem('panicUrl', finalUrl);
            panicKey = key;
            panicUrl = finalUrl;

            alert(`Panic key set to '${key}' redirecting to '${finalUrl}'.`);
            console.log('Panic key settings saved:', { key: panicKey, url: panicUrl });

        } else {
            console.error("Panic key input elements not found.");
            alert("Error: Could not find panic key input elements.");
        }
    }

    function loadPanicKeySettings() {
        panicKey = localStorage.getItem('panicKey');
        panicUrl = localStorage.getItem('panicUrl');
        console.log('Loaded panic key settings:', { key: panicKey, url: panicUrl });

        // Update input fields if on settings page
        if (pageTitle.textContent === 'Settings') { // Check if settings page is active
             const keyInput = document.getElementById('panicKeyInput');
             const urlInput = document.getElementById('panicUrlInput');
             if (keyInput && panicKey) keyInput.value = panicKey;
             if (urlInput && panicUrl) urlInput.value = panicUrl;
        }
    }

function checkPanicKey(event) {
        const targetElement = event.target;
        // Log the tag name of the element that received the keydown event
        console.log(`Keydown event target: ${targetElement ? targetElement.tagName : 'null'}, Type: ${targetElement ? targetElement.type : 'N/A'}`);

        // Check if the event originated from an input field or textarea
        if (targetElement && (targetElement.tagName.toLowerCase() === 'input' || targetElement.tagName.toLowerCase() === 'textarea')) {
            // Specifically log if we are skipping because it's an input/textarea
            console.log('Target is input/textarea. Panic key check skipped.');
            return; // Stop execution if typing in these fields
        } else {
             // Log if we are proceeding because it's *not* an input/textarea
            console.log('Target is NOT input/textarea. Proceeding with panic key check.');
        }

        // --- Original panic key check logic ---
        if (!panicKey || !panicUrl) {
             // Log if the key/URL isn't set up
             console.log('Panic key or URL not set in variables. Aborting check.');
             return;
        }

        // Construct the key identifier string from the event
        let pressedKey = '';
        if (event.altKey) pressedKey += 'Alt+';
        if (event.ctrlKey) pressedKey += 'Control+'; // Note: Might be intercepted by OS/browser shortcuts
        if (event.shiftKey) pressedKey += 'Shift+';
        // Use event.key for character keys and specific names like 'Escape', 'Enter'
        pressedKey += event.key;
        // Log the keys being compared
        console.log(`Constructed pressedKey: "${pressedKey}", Comparing (case-insensitive) against panicKey: "${panicKey}"`);


        // Case-insensitive comparison
        if (pressedKey.toLowerCase() === panicKey.toLowerCase()) {
            // Log the successful match before redirecting
            console.log(`Panic key MATCHED: "${pressedKey}". Redirecting to: ${panicUrl}`);
            event.preventDefault(); // Prevent default action just in case
            window.location.href = panicUrl;
        } else {
             // Log if the keys didn't match
             console.log('Panic key did NOT match.');
        }
    }

    // --- Modify setupEventListeners to add panic key listener ---
function setupEventListeners() {
      // Get sidebar element once
      const sidebar = document.querySelector('.sidebar'); // Ensure this exists

      // Sidebar Icon Click Listeners
      // Ensure 'icons' variable (NodeList of sidebar icons) is defined globally or accessible
      if (typeof icons !== 'undefined' && icons) {
           icons.forEach(icon => {
             icon.addEventListener('click', handleIconClick);
             // Tooltip Listeners
             icon.addEventListener('mousemove', handleTooltipShow);
             icon.addEventListener('mouseleave', handleTooltipHide);
           });
           console.log('Sidebar icon and tooltip event listeners set up.');
      } else {
           console.warn('Sidebar icons (variable "icons") not found. Sidebar listeners not fully set up.');
      }


      // Modal Click-outside-content Listeners
      const addGameModal = document.getElementById('addGameModal'); // Ensure this exists in your HTML
      if (addGameModal) {
           addGameModal.addEventListener('click', (e) => {
               // Assuming closeModal() is your function to hide addGameModal
             if (e.target === addGameModal) closeModal();
           });
           console.log('Add Game Modal click listener set up.');
      } else {
           console.warn('Add Game Modal element not found.');
      }

      // --- Include Changelog Modal Listener from Function 1 if you still use it ---
      // If you removed the changelogModal HTML, you can remove this block.
      const changelogModal = document.getElementById('changelogModal'); // Ensure this exists if used
      if (changelogModal) {
           changelogModal.addEventListener('click', (e) => {
               // Assuming closeChangelogModal() hides this modal
              if (e.target === changelogModal) closeChangelogModal(); // Make sure closeChangelogModal is defined
           });
           console.log('Changelog Modal click listener set up.');
      } else {
           console.log('Changelog Modal element not found or not used.'); // Log info if not present
      }


      // Global Keydown Listener (for Escape key and Panic Key)
      document.addEventListener('keydown', (e) => {
        // --- Handle Escape Key for Modals/Overlays/Notifications ---
        if (e.key === 'Escape') {
            // Close the add game modal if open
            const currentAddGameModal = document.getElementById('addGameModal');
            if (currentAddGameModal && currentAddGameModal.style.display === 'flex') {
                closeModal(); // Assuming closeModal() hides addGameModal
                 console.log('Escape pressed: Closed Add Game Modal.');
                 return; // Consume the event if a modal was closed
            }

            // If you use the changelog modal, add check here
             const currentChangelogModal = document.getElementById('changelogModal');
             if (currentChangelogModal && currentChangelogModal.style.display === 'flex') {
                 closeChangelogModal(); // Assuming closeChangelogModal hides your changelog modal
                 console.log('Escape pressed: Closed Changelog Modal.');
                  return;
             }

            // Hide the sliding notification if it's visible
            const slidingNotification = document.getElementById('slidingNotification'); // Ensure this exists
             if (slidingNotification && slidingNotification.classList.contains('show')) {
                 hideSlidingNotification(); // Call the function to hide the sliding notification
                  console.log('Escape pressed: Hid Sliding Notification.');
                  return; // Consume the event
             }


            // Hide the update overlay if it's visible
             const updateOverlay = document.getElementById("updateOverlay"); // Ensure this exists
             if (updateOverlay && updateOverlay.style.display === 'flex') {
                hideUpdateOverlay(); // Assuming hideUpdateOverlay hides the update overlay
                 console.log('Escape pressed: Hid Update Overlay.');
                 return; // Consume the event
             }

            // Add checks for other full-screen elements you might want Escape to close

             console.log('Escape pressed: No modals/overlays were open.'); // Log if no relevant element was closed

        } // End of Escape key handling

        // Check for panic key on any keydown event (keep this if you have panic key logic)
         // Make sure checkPanicKey is defined elsewhere
         if (typeof checkPanicKey === 'function') {
            checkPanicKey(e);
         } else {
             // console.warn('checkPanicKey function not found.'); // Avoid excessive warnings
         }
      });
       console.log('Global keydown listener set up (Escape, Panic Key).');


       // Update Overlay Button Listeners
       // These buttons exist in the HTML from the start, so listeners can be added here.
       const reloadSiteButton = document.getElementById('reloadSiteButton'); // Ensure exists
       const downloadOfflineButton = document.getElementById('downloadOfflineButton'); // Ensure exists
       const updateCloseButton = document.getElementById('updateCloseButton'); // Ensure exists

       if (reloadSiteButton) {
           // handleReloadSiteClick() should be defined elsewhere
            if (typeof handleReloadSiteClick === 'function') {
               reloadSiteButton.addEventListener('click', handleReloadSiteClick);
               console.log('Reload Site button event listener added.');
            } else {
               console.warn('handleReloadSiteClick function not found.');
            }
       } else {
            console.warn('Reload Site button not found during setup.');
       }

       if (downloadOfflineButton) {
            // handleDownloadOfflineClick() should be defined elsewhere
             if (typeof handleDownloadOfflineClick === 'function') {
                downloadOfflineButton.addEventListener('click', handleDownloadOfflineClick);
                console.log('Download Offline button event listener added.');
             } else {
                 console.warn('handleDownloadOfflineClick function not found.');
             }
       } else {
            console.warn('Download Offline button not found during setup.');
       }

        if (updateCloseButton) {
             // hideUpdateOverlay() should be defined elsewhere
             if (typeof hideUpdateOverlay === 'function') {
                updateCloseButton.addEventListener('click', hideUpdateOverlay);
                console.log('Update Close button event listener added.');
             } else {
                 console.warn('hideUpdateOverlay function not found.');
             }
        } else {
             console.warn('Update Close button not found during setup.');
        }
         console.log('Update Overlay button listeners set up.');


       // Sidebar Auto-open/close on mouse movement near left edge
       if (sidebar) { // Check if sidebar element was found at the beginning
            document.addEventListener('mousemove', (e) => {
                // Open sidebar if mouse is near the left edge and sidebar is closed
                if (e.clientX < 10 && !sidebar.classList.contains('open')) {
                    sidebar.classList.add('open');
                }
                // Close sidebar if mouse moves away from the left edge and sidebar is open
                else if (e.clientX > 70 && sidebar.classList.contains('open')) {
                    sidebar.classList.remove('open');
                }
            });
             // Close sidebar if mouse leaves the entire document area while sidebar is open
            document.documentElement.addEventListener('mouseleave', (e) => {
               if (sidebar.classList.contains('open')) {
                 sidebar.classList.remove('open');
               }
            });
            console.log('Sidebar auto-open/close listeners set up.');
       } else {
            console.warn('Sidebar element not found, auto-open/close listeners not set up.');
       }


      console.log('All event listeners setup function completed.');
    }

    // --- Replace your existing DOMContentLoaded listener with this ---
    window.addEventListener('DOMContentLoaded', async () => {
      console.log('DOMContentLoaded fired. Starting application initialization...');
    
      // Load saved data from localStorage (theme, app settings, games, library, favorites)
      loadData();
      console.log('Data loaded from localStorage (theme, app, games, library, favorites).');
    
      // Load music player data (must happen before initializing playback bar)
      mp_loadDataFromLocalStorage();
      console.log('Music Player data loaded from localStorage.');
    
      // Load panic key settings from localStorage
      loadPanicKeySettings();
      console.log('Panic key settings loaded.');
    
      // Initialize Vanta.js background effect
      setTimeout(() => {
          console.log('Attempting to initialize Vanta.js...');
          initializeVanta();
          console.log('initializeVanta() called. Vanta effect:', vantaEffect);
    
          if (vantaEffect) {
              console.log('Calling setTheme with currentThemeName after Vanta initialization.');
              setTheme(currentThemeName);
          } else {
              console.warn('Vanta effect is null after initialization, cannot call setTheme to update Vanta options.');
          }
      }, 50); // Short delay
    
      // Initialize the Music Player Playback Bar (needs audioPlayer element)
      mp_initializePlaybackBar(); // Initialize the music controls bar listeners
      console.log('Music Player playback bar initialization called.');
    
      // Set up all general event listeners for user interactions
      setupEventListeners();
      console.log('Event listeners set up.');
    
      // Update the games page UI based on loaded data (content defined in 'pages')
      // updateGamesPage(); // This will be handled by switchPage
    
      // Setup drag and drop functionality for games (elements created by updateGamesPage)
      // setupDragAndDrop(); // This should be called within switchPage or updateGamesPage
    
      // Switch to the initial page (usually Home)
      // This also triggers the first call to checkVersion() for Home page status display
      // and mp_initializeMusicPlayerPage if starting on Music page (unlikely)
    
      // --- Setup Periodic Checks ---
      setInterval(checkVersion, 60000); // Check every 60 seconds
      console.log("Periodic update check started (every 60 seconds).");
    
      setInterval(checkNotifications, 15000); // Check every 15 seconds
      console.log("Periodic notification check started (every 15 seconds).");
      checkNotifications(); // Initial check
    
      console.log('Application initialization completed.');
    });
    // --- End of DOMContentLoaded listener ---

    // --- Individual Settings Reset Functions ---

    function resetThemeSettings() {
        console.log("Resetting theme to default.");
        setTheme('default'); // This already updates localStorage and UI
        alert("Theme reset to Default.");
    }

    function resetAboutBlankSettings() {
        console.log("Resetting About:Blank settings.");
        const toggle = document.getElementById('aboutBlankToggle');
        if (toggle) {
            toggle.checked = true; // Set to default state (checked/enabled)
        }
        localStorage.removeItem('aboutBlankOnStartup'); // Remove saved preference
        console.log("Removed aboutBlankOnStartup from localStorage.");
        alert("About:Blank setting reset to default (Enabled on Startup).");
    }

    function resetPanicKeySettings() {
        console.log("Resetting Panic Key settings.");
        const keyInput = document.getElementById('panicKeyInput');
        const urlInput = document.getElementById('panicUrlInput');

        // Clear UI
        if (keyInput) keyInput.value = '';
        if (urlInput) urlInput.value = '';

        // Clear variables and localStorage
        panicKey = null;
        panicUrl = null;
        localStorage.removeItem('panicKey');
        localStorage.removeItem('panicUrl');
        console.log("Removed panicKey and panicUrl from localStorage.");
        alert("Panic Key settings cleared.");
    }

    // For Tab Cloaker, the existing resetCloak() function works, so we just call that
    // from the new button. No new JS function needed here unless you want different behavior.

    function resetAppAppearanceSettings() {
        console.log("Resetting App Appearance settings.");
        const titleInput = document.getElementById('appTabTitleInput');
        const iconInput = document.getElementById('appFaviconUrlInput');

        // Clear UI
        if (titleInput) titleInput.value = '';
        if (iconInput) iconInput.value = '';

        // Clear localStorage
        localStorage.removeItem('appSettings');
        console.log("Removed appSettings from localStorage.");

        // Apply default appearance
        applyAppSettings({
            tabTitle: 'Underground', // Your app's default name
            faviconUrl: ''
        });
        alert("App Appearance reset to default.");
    }

    // Function to display the sliding notification
// --- Individual Notification Management ---
    function showIndividualNotification(title, body, duration = 8000) { // Default duration 8 seconds
        const container = document.getElementById('notificationContainer');
        if (!container) {
            console.error("Notification container not found. Cannot show notification.");
            return;
        }

        // Create the notification element
        const notificationElement = document.createElement('div');
        notificationElement.classList.add('sliding-notification');
        const notificationId = `notification-${Date.now()}-${Math.random().toString(36).substring(7)}`;
        notificationElement.id = notificationId;
        notificationElement.setAttribute('data-hide-timeout-id', ''); // Placeholder for timeout ID
        notificationElement.style.display = 'block'; // Make it a block element to trigger layout


        // Add content (including close button and progress bar)
        notificationElement.innerHTML = `
            <button class="notification-close-button" onclick="hideIndividualNotification('${notificationId}')" title="Dismiss">&times;</button>
            <h3>${escapeHtml(title)}</h3>
            <div>${processLinkedText(body)}</div>
            <div class="notification-progress-bar"></div>
        `;

        // Append to the container
        container.appendChild(notificationElement);
        console.log(`Created and appended new notification: ${notificationId}`);

        // --- Start Show Animation and Progress Bar ---
         // Use a minimal timeout to allow the element to be added to the DOM before animating
         setTimeout(() => {
             notificationElement.classList.add('show');

             // Start progress bar animation after a slight delay
             const progressBarElement = notificationElement.querySelector('.notification-progress-bar');
             if (progressBarElement) {
                 // Ensure initial state is set before transition
                 progressBarElement.style.transitionDuration = '0ms';
                 progressBarElement.style.width = '100%';
                  // Delay applying the transition and new width
                 setTimeout(() => {
                      progressBarElement.style.transitionDuration = `${duration}ms`;
                      progressBarElement.style.width = '0%';
                 }, 50); // Small delay
             }

             // Set the hide timeout
             const hideTimeoutId = setTimeout(() => {
                 hideIndividualNotification(notificationId);
             }, duration);

             // Store the timeout ID and element reference
             notificationElement.setAttribute('data-hide-timeout-id', hideTimeoutId);
             activeNotifications[notificationId] = hideTimeoutId;
             console.log(`Notification ${notificationId} set to hide in ${duration}ms.`);

         }, 20); // Small delay to allow element to appear in DOM

        return notificationElement; // Return the created element
    }

    function hideIndividualNotification(notificationId, immediate = false) {
        const notificationElement = document.getElementById(notificationId);
        if (!notificationElement) {
            console.warn(`Notification element with ID "${notificationId}" not found or already removed.`);
            // Clean up activeNotifications state even if element is missing
            if (activeNotifications[notificationId]) {
                clearTimeout(activeNotifications[notificationId]);
                delete activeNotifications[notificationId];
                console.log(`Cleaned up activeNotifications state for ID "${notificationId}".`);
            }
            return;
        }

        console.log(`Attempting to hide notification: ${notificationId} (immediate: ${immediate})`);

        // Clear the hide timeout associated with this specific notification
        const hideTimeoutId = parseInt(notificationElement.getAttribute('data-hide-timeout-id'));
        if (!isNaN(hideTimeoutId)) {
            clearTimeout(hideTimeoutId);
            console.log(`Cleared hide timeout ${hideTimeoutId} for notification ${notificationId}.`);
        }
         // Also clear from activeNotifications state
        if (activeNotifications[notificationId]) {
            delete activeNotifications[notificationId];
             console.log(`Removed notification ${notificationId} from activeNotifications state.`);
        }


        // Start the slide-out animation
        notificationElement.classList.remove('show');

        const transitionDuration = 500; // Must match your CSS transition duration
        const delay = immediate ? 0 : transitionDuration;

         // Clear any previously set display:none timeout for this element
         if (notificationElement.hideDisplayTimeout) {
             clearTimeout(notificationElement.hideDisplayTimeout);
             notificationElement.hideDisplayTimeout = null;
         }


        // Set a timeout to remove the element from the DOM after the CSS transition completes
        notificationElement.hideDisplayTimeout = setTimeout(() => {
            // Check if the element is still attached before removing
            if (notificationElement.parentNode) {
                 notificationElement.parentNode.removeChild(notificationElement);
                 console.log(`Removed notification element ${notificationId} from DOM.`);
            }
        }, delay);
    }

    function hideAllNotifications() {
        console.log("Hiding all active notifications.");
        // Iterate through all currently managed notification IDs
        for (const id in activeNotifications) {
            // Use Object.prototype.hasOwnProperty.call for safer iteration
            if (Object.prototype.hasOwnProperty.call(activeNotifications, id)) {
                // Pass immediate=true to hide them instantly on user action
                hideIndividualNotification(id, true);
            }
        }
         // The hideIndividualNotification function already removes from activeNotifications
         // So, we don't need to clear the activeNotifications object here.
        console.log("All notifications cleared from activeNotifications state.");
    }

    async function checkNotifications() {
            console.log("Checking for multiple notifications from notification.txt...");
    
            const notificationURL = "https://hostfilez.glitch.me/notification.txt";
            const container = document.getElementById('notificationContainer');
    
            if (!container) {
                console.error("Notification container element not found. Cannot check notifications.");
                return; // Cannot proceed if container is missing
            }
    
             // Note: We no longer clear all notifications *before* checking the file.
             // We now hide them if they disappear from the file or if their content changes.
             // The 'shownNotificationContentSet' prevents duplicates from the same file content.
    
    
            try {
                const response = await fetch(notificationURL, { cache: "no-store" });
    
                // Get the raw text, even on error, to handle cases where the file might become empty or return 404
                const notificationText = response.ok ? (await response.text()).trim() : '';
    
                if (!response.ok || !notificationText) {
                    // If file is unreachable or empty, hide all existing notifications
                    console.log("Notification file unreachable or empty. Hiding any active notifications.");
                    hideAllNotifications(); // Hide any notifications currently displayed
                    // We do NOT clear shownNotificationContentSet here, so previously seen notifications don't reappear
                    return; // Stop processing
                }
    
                console.log("Fetched raw notification text:", notificationText);
    
                // Split the text into potential notification blocks
                // Filter out any empty strings resulting from leading/trailing underscores or multiple underscores
                const notificationBlocks = notificationText.split('_').map(block => block.trim()).filter(block => block.length > 0);
                console.log(`Split into ${notificationBlocks.length} non-empty block(s).`);
    
                // --- Logic to remove notifications that are no longer in the file ---
                const currentNotificationBlocksContent = new Set(notificationBlocks);
                const activeNotificationElements = container.querySelectorAll('.sliding-notification');
    
                activeNotificationElements.forEach(element => {
                    // We need to somehow link the displayed element back to the original block content
                    // A simple way is to store the original content as a data attribute when creating the element
                    const originalContent = element.getAttribute('data-original-content');
                    if (originalContent && !currentNotificationBlocksContent.has(originalContent)) {
                         console.log(`Notification with original content no longer in file. Hiding:`, originalContent);
                         hideIndividualNotification(element.id, true); // Hide immediately
                    }
                     // If original content attribute is missing, we can't check if it's still in the file,
                     // so we'll leave it unless it times out or the whole file disappears.
                });
                 console.log("Finished checking for notifications to remove.");
    
    
                // --- Logic to add/display new notifications ---
                notificationBlocks.forEach(trimmedBlock => {
                    // Check for the ~true~ trigger within this block
                    const hasTrueTrigger = trimmedBlock.includes('~true~');
    
                    if (hasTrueTrigger) {
                        // Check if this specific notification block content has already been shown in this session
                        // This prevents reappearing if the file is checked again but the content hasn't changed
                        if (shownNotificationContentSet.has(trimmedBlock)) {
                            console.log("Notification block already shown in this session. Skipping display:", trimmedBlock.substring(0, 50) + '...'); // Log start of content
                            return; // Skip the rest of the forEach iteration for this block
                        }
    
                        // If not already shown, add it to the set so it won't show again this session
                        shownNotificationContentSet.add(trimmedBlock);
                        console.log("Notification block is new or not yet shown. Proceeding to display:", trimmedBlock.substring(0, 50) + '...'); // Log start of content
    
    
                        let notificationTitle = "Notification"; // Default title if not found
                        let notificationBody = trimmedBlock; // Start with the whole block as body
    
                        // Remove the ~true~ trigger and any ~false~ trigger before parsing title/body
                        let contentAfterTrigger = trimmedBlock.replace('~true~', '').replace('~false~', '').trim();
    
                        // Attempt to extract title between backticks after the trigger content
                        const titleRegex = /`([^`]+)`/; // Non-greedy match for content inside backticks
                        const titleMatch = contentAfterTrigger.match(titleRegex);
    
                        if (titleMatch && titleMatch[1]) {
                            notificationTitle = titleMatch[1].trim();
                            // Get the text * after * the matched title block (including backticks) for the body
                            notificationBody = contentAfterTrigger.substring(contentAfterTrigger.indexOf(titleMatch[0]) + titleMatch[0].length).trim();
                            // console.log("Extracted Title:", notificationTitle, "Extracted Body (after title block):", notificationBody); // Avoid excessive logging of full body
    
                        } else {
                            // If no title found in backticks after triggers, the remaining content is the body
                            notificationBody = contentAfterTrigger; // Use the content after removing triggers as body
                             // console.log("No title found in backticks after triggers. Body is remaining content:", notificationBody); // Avoid excessive logging
                        }
    
                        // If after parsing, the body is empty, use a default message
                        if (!notificationBody) {
                             notificationBody = "No message provided.";
                             console.log("Body was empty after parsing, using default message.");
                        }
    
                        // Show this individual notification
                        const displayDuration = Math.max(6000, notificationBody.split(/\s+/).filter(word => word.length > 0).length * 400); // Minimum 6 seconds
                        // When creating the element, store the original trimmedBlock content
                        const newNotificationElement = showIndividualNotification(notificationTitle, notificationBody, displayDuration);
                        if (newNotificationElement) {
                             newNotificationElement.setAttribute('data-original-content', trimmedBlock);
                             console.log("Set data-original-content attribute for new notification.");
                        }
    
    
                    } else {
                        // If a block doesn't have ~true~ (e.g., has ~false~ or neither),
                        // we already handled hiding notifications that are no longer in the file.
                        console.log("Block does not contain ~true~ trigger. Skipping display.");
                    }
                });
                 console.log("Finished checking for notifications to add/display.");
    
    
            } catch (err) {
                console.error("Failed to check or parse notifications:", err);
                // On any error during fetch or parsing, hide the notification and clear state
                hideAllNotifications(); // Hide existing notifications on error
                // Again, do NOT clear shownNotificationContentSet here
            }
             console.log("Notification check complete.");
        }


    // --- START IndexedDB Helpers ---
    
    const MP_DB_NAME = 'underground_music_db';
    const MP_DB_VERSION = 1;
    const MP_STORE_HANDLES = 'fileHandles';
    const MP_STORE_METADATA = 'metadata';
    const MP_KEY_DIR_HANDLE = 'mainDirectoryHandle';
    const MP_KEY_LIBRARY = 'musicLibrary';
    const MP_KEY_PLAYLISTS = 'playlists';
    const MP_KEY_RECENTS = 'recentlyPlayed';
    
    let mp_db = null; // Variable to hold the DB connection
    
    function mp_openDB() {
        return new Promise((resolve, reject) => {
            if (mp_db) {
                resolve(mp_db); // Return existing connection if available
                return;
            }
            console.log(`MP_IDB: Opening database ${MP_DB_NAME} version ${MP_DB_VERSION}`);
            const request = indexedDB.open(MP_DB_NAME, MP_DB_VERSION);
    
            request.onerror = (event) => {
                console.error("MP_IDB: Database error:", event.target.error);
                reject("Error opening IndexedDB.");
            };
    
            request.onsuccess = (event) => {
                mp_db = event.target.result;
                console.log("MP_IDB: Database opened successfully.");
                resolve(mp_db);
            };
    
            request.onupgradeneeded = (event) => {
                console.log("MP_IDB: Database upgrade needed.");
                const db = event.target.result;
                if (!db.objectStoreNames.contains(MP_STORE_HANDLES)) {
                    db.createObjectStore(MP_STORE_HANDLES); // Simple key/value store
                    console.log(`MP_IDB: Object store ${MP_STORE_HANDLES} created.`);
                }
                if (!db.objectStoreNames.contains(MP_STORE_METADATA)) {
                    db.createObjectStore(MP_STORE_METADATA); // Simple key/value store
                     console.log(`MP_IDB: Object store ${MP_STORE_METADATA} created.`);
                }
            };
        });
    }
    
    // Generic function to put data into a store
    function mp_dbPut(storeName, key, value) {
        return new Promise(async (resolve, reject) => {
            try {
                const db = await mp_openDB();
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(value, key);
    
                request.onsuccess = () => {
                    // console.log(`MP_IDB: Successfully put value with key "${key}" into store "${storeName}".`);
                    resolve();
                };
                request.onerror = (event) => {
                    console.error(`MP_IDB: Error putting value with key "${key}" into store "${storeName}":`, event.target.error);
                    reject(event.target.error);
                };
            } catch (error) {
                console.error(`MP_IDB: Transaction error in mp_dbPut for store "${storeName}":`, error);
                reject(error);
            }
        });
    }
    
    // Generic function to get data from a store
    function mp_dbGet(storeName, key) {
        return new Promise(async (resolve, reject) => {
            try {
                const db = await mp_openDB();
                const transaction = db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);
    
                request.onsuccess = () => {
                    // console.log(`MP_IDB: Successfully got value with key "${key}" from store "${storeName}".`);
                    resolve(request.result); // Returns undefined if key not found
                };
                request.onerror = (event) => {
                    console.error(`MP_IDB: Error getting value with key "${key}" from store "${storeName}":`, event.target.error);
                    reject(event.target.error);
                };
            } catch (error) {
                console.error(`MP_IDB: Transaction error in mp_dbGet for store "${storeName}":`, error);
                reject(error);
            }
        });
    }
    
    // Generic function to delete data from a store
    function mp_dbDelete(storeName, key) {
        return new Promise(async (resolve, reject) => {
            try {
                const db = await mp_openDB();
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(key);
    
                request.onsuccess = () => {
                    // console.log(`MP_IDB: Successfully deleted value with key "${key}" from store "${storeName}".`);
                    resolve();
                };
                request.onerror = (event) => {
                    console.error(`MP_IDB: Error deleting value with key "${key}" from store "${storeName}":`, event.target.error);
                    reject(event.target.error);
                };
            } catch (error) {
                console.error(`MP_IDB: Transaction error in mp_dbDelete for store "${storeName}":`, error);
                reject(error);
            }
        });
    }
    
    
    // --- END IndexedDB Helpers ---
      

    // --- START OF MUSIC PLAYER JAVASCRIPT ---
    // Prefix functions and IDs with 'mp_' to avoid conflicts

    
    // --- Music Player State ---
    let mp_musicLibrary = []; // Array of song objects { id, artist, title, fileName, fileSize }
    let mp_recentlyPlayed = []; // Array of song IDs
    let mp_playlists = {}; // Object: { "Playlist Name": [songId1, songId2] }
    let mp_currentSong = null; // The song object currently loaded/playing (includes tempUrl)
    let mp_currentSongIndex = -1; // Index in the currently playing list
    let mp_isPlaying = false;
    let mp_currentQueue = []; // Holds the IDs of songs being played
    let mp_currentPlaylistNameForView = null; // To know which playlist is open in the modal
    let mp_currentDirectoryHandle = null; // Holds the File System Access API handle
    const MP_MAX_RECENTLY_PLAYED = 20;
    let mp_isInitialized = false; // Flag to check if player UI is set up
    let mp_playbackBarInitialized = false; // Flag for playback bar listeners
    
    // --- Music Player DOM Element References (Filled by mp_initializeMusicPlayerPage or mp_initializePlaybackBar) ---
    let mp_fileInput = null;
    let mp_songsList = null;
    let mp_recentlyPlayedList = null;
    let mp_playlistsList = null;
    let mp_songSearch = null;
    const mp_audioPlayer = document.getElementById('mp_audioPlayer'); // Get early
    const mp_playbackControlsBar = document.getElementById('mp_playback_controls'); // Get early
    let mp_playPauseButton = null;
    let mp_prevButton = null;
    let mp_nextButton = null;
    let mp_seekBar = null;
    let mp_currentTime = null;
    let mp_totalDuration = null;
    let mp_currentSongInfo = null;
    let mp_volumeSlider = null;
    let mp_muteButton = null;
    let mp_volumePercentage = null;
    
    
    // --- Core Music Player Functions ---
    
    // Loads metadata from IndexedDB.
    async function mp_loadDataFromDB() {
        console.log("MP: Loading data from IndexedDB.");
        try {
            // Load metadata first
            const libraryData = await mp_dbGet(MP_STORE_METADATA, MP_KEY_LIBRARY);
            const recentlyPlayedData = await mp_dbGet(MP_STORE_METADATA, MP_KEY_RECENTS);
            const playlistsData = await mp_dbGet(MP_STORE_METADATA, MP_KEY_PLAYLISTS);
    
            mp_musicLibrary = libraryData || [];
            mp_recentlyPlayed = recentlyPlayedData || [];
            mp_playlists = playlistsData || {};
    
            console.log(`MP: Loaded Metadata: ${mp_musicLibrary.length} songs, ${mp_recentlyPlayed.length} recents, ${Object.keys(mp_playlists).length} playlists`);
    
            // Then, attempt to load the directory handle
            const savedHandle = await mp_dbGet(MP_STORE_HANDLES, MP_KEY_DIR_HANDLE);
            if (savedHandle) {
                console.log("MP: Found saved directory handle in IDB.");
                // IMPORTANT: Verify permission before assigning. Permission might have been revoked.
                if (await savedHandle.queryPermission({ mode: 'read' }) === 'granted') {
                    mp_currentDirectoryHandle = savedHandle;
                    console.log("MP: Read permission for saved handle is still granted.");
                } else {
                    console.log("MP: Read permission for saved handle NOT granted. Attempting to re-request...");
                    // Try to request permission again. If granted, use the handle.
                    if (await savedHandle.requestPermission({ mode: 'read' }) === 'granted') {
                         mp_currentDirectoryHandle = savedHandle;
                         console.log("MP: Read permission re-granted for saved handle.");
                    } else {
                         console.warn("MP: Could not re-obtain read permission for the saved handle. User may need to re-select the folder.");
                         // Optionally, remove the stale handle from IDB
                         await mp_dbDelete(MP_STORE_HANDLES, MP_KEY_DIR_HANDLE);
                         mp_currentDirectoryHandle = null;
                    }
                }
            } else {
                 console.log("MP: No saved directory handle found in IDB.");
                 mp_currentDirectoryHandle = null;
            }
        } catch (error) {
            console.error("MP: Failed to load data from IndexedDB:", error);
            // Reset to defaults in case of error
            mp_musicLibrary = [];
            mp_recentlyPlayed = [];
            mp_playlists = {};
            mp_currentDirectoryHandle = null;
        }
    }
    
    // Saves metadata and handle to IndexedDB.
    async function mp_saveDataToDB() {
        console.log("MP: Saving data to IndexedDB.");
        try {
            // Save metadata
             const libraryToStore = mp_musicLibrary.map(song => ({
                 id: song.id, artist: song.artist, title: song.title,
                 fileName: song.fileName, fileSize: song.fileSize // Don't store tempUrl or fileHandle here
             }));
            await mp_dbPut(MP_STORE_METADATA, MP_KEY_LIBRARY, libraryToStore);
            await mp_dbPut(MP_STORE_METADATA, MP_KEY_PLAYLISTS, mp_playlists);
            await mp_dbPut(MP_STORE_METADATA, MP_KEY_RECENTS, mp_recentlyPlayed);
            console.log("MP_IDB: Metadata saved.");
    
            // Save directory handle if it exists
            if (mp_currentDirectoryHandle) {
                 await mp_dbPut(MP_STORE_HANDLES, MP_KEY_DIR_HANDLE, mp_currentDirectoryHandle);
                 console.log("MP_IDB: Directory handle saved.");
            } else {
                 // If handle is null (e.g., user used file input), ensure it's removed from DB
                 await mp_dbDelete(MP_STORE_HANDLES, MP_KEY_DIR_HANDLE);
                  console.log("MP_IDB: No current directory handle, ensured it's removed from DB.");
            }
        } catch (error) {
            console.error("MP: Failed to save data to IndexedDB:", error);
        }
    }
    
    // Called by the "Select Folder" button
    async function mp_selectMusicDirectory() {
        console.log("MP: Select Music Directory button clicked.");
        // Clear existing library and handle before selecting a new one
        // This prevents merging old scan results with new ones if the user selects a different folder
        console.log("MP: Clearing existing library and handle before new selection.");
        mp_musicLibrary = [];
        mp_currentDirectoryHandle = null;
        await mp_saveDataToDB(); // Save the cleared state (especially the null handle)
        if (typeof mp_renderSongsList === 'function') mp_renderSongsList(); // Update UI immediately
    
        const dirHandle = await mp_requestDirectoryAccess();
        if (dirHandle) {
            mp_currentDirectoryHandle = dirHandle; // Store for this session
            // Save the NEW handle to IDB immediately after getting it
            await mp_saveDataToDB();
            // Now process the newly selected directory
            await mp_processDirectoryHandle(dirHandle);
        } else {
             console.log("MP: Directory selection cancelled or failed, library remains empty.");
              // Ensure UI reflects the empty state if selection failed/cancelled
              if (typeof mp_renderSongsList === 'function') mp_renderSongsList();
        }
    }

    // Requests directory access using File System Access API
    async function mp_requestDirectoryAccess() {
        console.log("MP: Requesting directory access.");
        const fileInputFallback = document.getElementById('mp_fileInput'); // Get fallback input
    
        if (!window.showDirectoryPicker) {
            alert('MP: Your browser does not support the File System Access API required for folder selection persistence. Falling back to temporary file selection. Files will need to be re-selected after reloading.');
            // Trigger the hidden file input as a fallback
            if (fileInputFallback) {
                fileInputFallback.click();
                console.log("MP: Triggered fallback file input.");
            } else {
                 console.error("MP: Fallback file input element ('mp_fileInput') not found!");
                 alert("MP: Critical error - Fallback file input not found.");
            }
            return null; // Indicate failure to get directory handle
        }
    
        try {
            // This line triggers the browser's folder selection prompt
            const dirHandle = await window.showDirectoryPicker({ mode: 'read' });
            console.log("MP: Directory access granted by user for:", dirHandle.name);
            // NOTE: We don't save the handle here; mp_selectMusicDirectory does that after calling this.
            return dirHandle;
        } catch (err) {
            // Ignore AbortError which means the user cancelled the picker
            if (err.name !== 'AbortError') {
                console.error('MP: Error requesting directory access via showDirectoryPicker:', err);
                alert(`MP: Error accessing directory: ${err.message}. Please ensure you are using HTTPS or localhost.`);
            } else {
                console.log("MP: User cancelled directory selection prompt.");
            }
            // Do NOT trigger the fallback input here if showDirectoryPicker exists but failed/was cancelled.
            // The user explicitly interacted with the modern API prompt.
            return null; // Indicate failure or cancellation
        }
    }
        
    // Processes files from the directory handle (recursive)
    async function mp_processDirectoryHandle(dirHandle) {
        console.log(`MP: Processing directory: ${dirHandle.name}`);
        const processingPromises = [];
        let fileCount = 0;
        const processedPaths = new Set(); // To avoid processing duplicates if structure is odd
    
        async function processEntry(entryHandle, currentPath = '') {
             const entryPath = currentPath ? `${currentPath}/${entryHandle.name}` : entryHandle.name;
             if (processedPaths.has(entryPath)) return; // Skip if already processed
             processedPaths.add(entryPath);
    
             try {
                 if (entryHandle.kind === 'file') {
                     const file = await entryHandle.getFile();
                     if (file.type.startsWith('audio/')) {
                         fileCount++;
                         processingPromises.push(mp_processPersistentSongFile(file, entryHandle));
                     }
                 } else if (entryHandle.kind === 'directory') {
                      if (await entryHandle.queryPermission({ mode: 'read' }) === 'granted') {
                           // console.log(`MP: Entering subdirectory: ${entryPath}`); // Optional verbose log
                           for await (const subEntryHandle of entryHandle.values()) {
                               await processEntry(subEntryHandle, entryPath);
                           }
                      } else {
                           console.warn(`MP: Read permission not granted for subdirectory: ${entryPath}`);
                      }
                 }
              } catch (err) {
                  console.error(`MP: Error processing entry ${entryPath}:`, err);
              }
         }
    
        await processEntry(dirHandle); // Start processing from root handle
        await Promise.all(processingPromises);
        console.log(`MP: Directory processing complete. ${processingPromises.length} audio files potentially added.`);
        mp_saveDataToLocalStorage();
        if (typeof mp_renderSongsList === 'function') mp_renderSongsList(); // Render if function exists
        else console.log("MP: mp_renderSongsList not ready.");
    }
    
    
    // Processes a single file, stores metadata
    async function mp_processPersistentSongFile(file, fileHandle = null) {
        const songId = `mp-song-${Date.now()}-${Math.random().toString(16).slice(2)}`;
        let { artist, title } = mp_parseFileName(file.name);
    
        if (mp_musicLibrary.some(s => s.fileName === file.name && s.fileSize === file.size)) {
            // console.log(`MP: Song "${file.name}" seems to already exist by name/size. Skipping.`);
            return;
        }
    
        const song = {
            id: songId, artist: artist, title: title,
            fileName: file.name, fileSize: file.size,
        };
        mp_musicLibrary.push(song);
        // console.log(`MP: Added metadata: ${artist} - ${title}`); // Optional verbose log
    }
    
    // Fallback for standard file input
    async function mp_handleFileSelect(event) {
        console.log("MP: Using file input fallback.");
        mp_currentDirectoryHandle = null; // Not using directory handle here
        const files = event.target.files;
        if (!files || files.length === 0) return;
        console.log(`MP: Processing ${files.length} files from input...`);
        const processingPromises = [];
        Array.from(files).forEach(file => {
            if (file.type.startsWith('audio/')) {
                processingPromises.push(mp_processPersistentSongFile(file, null));
            } else {
                console.warn(`MP: Skipping non-audio file: ${file.name}`);
            }
        });
        await Promise.all(processingPromises);
        console.log("MP: File input processing complete.");
        mp_saveDataToLocalStorage();
        if (typeof mp_renderSongsList === 'function') mp_renderSongsList(); // Render if function exists
         else console.log("MP: mp_renderSongsList not ready.");
        event.target.value = null;
    }
    
    // Parses filename "Artist - Title.mp3"
    function mp_parseFileName(fileName) {
        let baseName = fileName.substring(0, fileName.lastIndexOf('.')) || fileName;
        const separator = ' - ';
        let artist = 'Unknown Artist';
        let title = baseName;
        if (baseName.includes(separator)) {
            const parts = baseName.split(separator);
            if (parts.length >= 2) {
                artist = parts[0].trim();
                title = parts.slice(1).join(separator).trim();
            }
        }
        return { artist, title };
    }
    
    // Finds song metadata by ID
    function mp_findSongById(songId) {
        return mp_musicLibrary.find(song => song.id === songId);
    }
    
    // Inside function mp_renderSongsList(filter = '') { ... }
    function mp_renderSongsList(filter = '') {
        console.log("MP: Entering mp_renderSongsList. Filter:", filter); // Added log
        if (!mp_songsList) {
            console.error("MP: mp_songsList element not found for rendering."); // Added error log
            return; // Check if element exists
        }
        mp_songsList.innerHTML = '';
        const lowerFilter = filter.toLowerCase();
        const filteredLibrary = mp_musicLibrary.filter(song =>
            song.title.toLowerCase().includes(lowerFilter) ||
            song.artist.toLowerCase().includes(lowerFilter) ||
            song.fileName.toLowerCase().includes(lowerFilter)
        ).sort((a, b) => `${a.artist} - ${a.title}`.localeCompare(`${b.artist} - ${b.title}`));

        console.log("MP: Filtered library. Found", filteredLibrary.length, "songs to display."); // Added log

        if (filteredLibrary.length === 0) {
            mp_songsList.innerHTML = `<p class="placeholder-text">${mp_musicLibrary.length === 0 ? 'Upload songs to see your library' : (filter ? 'No songs match search' : 'Library empty?')}</p>`;
            console.log("MP: Songs list is empty after filtering, displaying placeholder."); // Added log
            return;
        }
        filteredLibrary.forEach(song => {
            // console.log("MP: Creating list item for song:", song.title); // Optional: very verbose log
            const listItem = mp_createListItem(song, () => mp_playSongFromLibrary(song.id));
            mp_songsList.appendChild(listItem);
            // console.log("MP: Appended list item for", song.title); // Optional: very verbose log
        });
        console.log("MP: Finished appending song list items. Total children:", mp_songsList.children.length); // Added log
        mp_updatePlayingIndicator();
        console.log("MP: Exiting mp_renderSongsList."); // Added log
    }

    
    // Inside function mp_renderRecentlyPlayed() { ... }
   function mp_renderRecentlyPlayed() {
        console.log("MP: Entering mp_renderRecentlyPlayed."); // Added log
        if (!mp_recentlyPlayedList) {
            console.error("MP: mp_recentlyPlayedList element not found for rendering."); // Added error log
            return; // Check if element exists
        }
        mp_recentlyPlayedList.innerHTML = '';
         if (mp_recentlyPlayed.length === 0) {
             mp_recentlyPlayedList.innerHTML = '<p class="placeholder-text">Play a song to see it here</p>';
             console.log("MP: Recently played list is empty, displaying placeholder."); // Added log
             return;
         }
        mp_recentlyPlayed.forEach(songId => {
            const song = mp_findSongById(songId);
            if (song) {
                // console.log("MP: Creating list item for recently played song:", song.title); // Optional: very verbose
                const listItem = mp_createListItem(song, () => mp_playSongFromLibrary(song.id));
                mp_recentlyPlayedList.appendChild(listItem);
                // console.log("MP: Appended list item for recently played", song.title); // Optional: very verbose
            } else {
                 console.warn("MP: Recently played song ID not found in library:", songId); // Added warn
            }
        });
        console.log("MP: Finished appending recently played items. Total children:", mp_recentlyPlayedList.children.length); // Added log
        mp_updatePlayingIndicator();
        console.log("MP: Exiting mp_renderRecentlyPlayed."); // Added log
    }

    // Inside function mp_renderPlaylists() { ... }
    function mp_renderPlaylists() {
        console.log("MP: Entering mp_renderPlaylists."); // Added log
        if (!mp_playlistsList) {
             console.error("MP: mp_playlistsList element not found for rendering."); // Added error log
             return; // Check if element exists
        }
        mp_playlistsList.innerHTML = '';
        const playlistNames = Object.keys(mp_playlists).sort((a, b) => a.localeCompare(b));

        console.log("MP: Found", playlistNames.length, "playlists."); // Added log

        if (playlistNames.length === 0) {
            mp_playlistsList.innerHTML = '<p class="placeholder-text">Create a playlist to see it here</p>';
             console.log("MP: No playlists found, displaying placeholder."); // Added log
            return;
        }
        playlistNames.forEach(name => {
            const songCount = mp_playlists[name]?.length || 0;
            const listItem = document.createElement('div');
            listItem.className = 'list-item';
            listItem.style.cursor = 'default';
            listItem.innerHTML = `
                <div class="playlist-info">
                    <span style="cursor: pointer;" onclick="mp_openViewPlaylistModal('${escapeHtml(name)}')">${escapeHtml(name)} (${songCount} songs)</span>
                    <div class="playlist-controls">
                        <button onclick="event.stopPropagation(); mp_playPlaylist('${escapeHtml(name)}')" title="Play ${escapeHtml(name)}"><i class="fas fa-play"></i></button>
                    </div>
                </div>`;
            mp_playlistsList.appendChild(listItem);
            // console.log("MP: Appended list item for playlist", name); // Optional: very verbose
        });
         console.log("MP: Finished appending playlist items. Total children:", mp_playlistsList.children.length); // Added log
        console.log("MP: Exiting mp_renderPlaylists."); // Added log
    }
    
    // Helper to create list items
    function mp_createListItem(song, onClickCallback) {
        const listItem = document.createElement('div');
        listItem.className = 'list-item';
        listItem.textContent = `${song.artist} - ${song.title}`;
        listItem.title = `${song.artist} - ${song.title} (${song.fileName})`;
        listItem.dataset.songId = song.id;
        listItem.onclick = onClickCallback;
        return listItem;
    }
    
    // Updates playing indicator across all lists
    function mp_updatePlayingIndicator() {
        // Use querySelectorAll on the document to find all potential list items
        document.querySelectorAll('.list-item[data-song-id]').forEach(item => {
            item.classList.remove('playing');
            if (mp_currentSong && mp_isPlaying && item.dataset.songId === mp_currentSong.id) {
                item.classList.add('playing');
            }
        });
    }
    
    // --- Playback Logic ---
    
    // Stops playback, revokes URL, clears UI
    function mp_stopPlaybackAndClearUI() {
        console.log("MP: Stopping playback and clearing UI.");
        if (mp_currentSong && mp_currentSong.tempUrl) {
            URL.revokeObjectURL(mp_currentSong.tempUrl);
            console.log("MP: Revoked temporary URL.");
        }
        if (mp_audioPlayer) mp_audioPlayer.pause();
        if (mp_audioPlayer) mp_audioPlayer.src = '';
        mp_currentSong = null;
        mp_currentSongIndex = -1;
        mp_currentQueue = [];
        mp_isPlaying = false;
        mp_updatePlaybackControls(); // Update buttons etc.
        if (mp_currentSongInfo) mp_currentSongInfo.textContent = "No Song Playing";
        if (mp_currentSongInfo) mp_currentSongInfo.title = "";
        if (mp_seekBar) mp_seekBar.value = 0;
        if (mp_currentTime) mp_currentTime.textContent = mp_formatTime(0);
        if (mp_totalDuration) mp_totalDuration.textContent = mp_formatTime(0);
        mp_updatePlayingIndicator(); // Clear playing indicators
    }
    
    // Loads song metadata, gets file handle from the persistent directory handle, creates temp URL, loads player
    async function mp_loadSong(songMetaData) {
        console.log("MP: loadSong called for:", songMetaData?.fileName);
        if (!songMetaData || !songMetaData.fileName) {
            console.error("MP: Invalid song metadata.");
            mp_stopPlaybackAndClearUI();
            return;
        }
        // Show playback bar when loading a song
        if (mp_playbackControlsBar) mp_playbackControlsBar.style.display = 'flex';
    
        // --- Ensure Directory Handle is Available and Permission Granted ---
        if (!mp_currentDirectoryHandle) {
             console.warn("MP: Directory handle not available. Attempting to load from DB...");
             await mp_loadDataFromDB(); // Try loading handle and verifying permission
             if (!mp_currentDirectoryHandle) {
                  alert("MP: Music directory access required. Please select the folder again via the 'Select Folder' button.");
                  mp_stopPlaybackAndClearUI();
                  return;
             }
        } else {
            // If handle exists, double-check permission in case it was revoked since load
            console.log("MP: Verifying permission for existing directory handle...");
            if (await mp_currentDirectoryHandle.queryPermission({ mode: 'read' }) !== 'granted') {
                 console.warn("MP: Permission for existing handle was revoked. Requesting again...");
                 if (await mp_currentDirectoryHandle.requestPermission({ mode: 'read' }) !== 'granted') {
                      alert(`MP: Read permission denied for directory "${mp_currentDirectoryHandle.name}". Cannot play song.`);
                       mp_stopPlaybackAndClearUI();
                      // Maybe clear the handle?
                      // mp_currentDirectoryHandle = null;
                      // await mp_dbDelete(MP_STORE_HANDLES, MP_KEY_DIR_HANDLE);
                      return;
                 }
                 console.log("MP: Permission re-granted.");
            } else {
                // console.log("MP: Permission still granted."); // Verbose
            }
        }
    
        // --- Find File Handle within the Directory & Get File ---
        let fileToPlay = null;
        try {
             console.log(`MP: Attempting to find file handle for "${songMetaData.fileName}" within directory "${mp_currentDirectoryHandle.name}"`);
             // Recursive helper function to find the file handle
             async function findFileHandleRecursive(dirHandle, fileNameToFind, currentPath = '') {
                  const pathDesc = currentPath ? `${currentPath}/` : '';
                 // console.log(`MP_IDB: Searching in ${pathDesc}${dirHandle.name}`); // Very verbose
                 try {
                      for await (const entryHandle of dirHandle.values()) {
                         if (entryHandle.kind === 'file' && entryHandle.name === fileNameToFind) {
                             // console.log(`MP_IDB: Found file handle: ${pathDesc}${entryHandle.name}`); // Very verbose
                             return entryHandle;
                         } else if (entryHandle.kind === 'directory') {
                              // Don't need permission check here, getFile later will handle it implicitly if needed
                              // We assume if we have dir handle permission, we can iterate
                               const found = await findFileHandleRecursive(entryHandle, fileNameToFind, `${pathDesc}${entryHandle.name}`);
                               if (found) return found;
                         }
                     }
                 } catch(innerErr) {
                      console.warn(`MP: Error iterating directory ${dirHandle.name} during search: ${innerErr.message}`);
                      // May indicate permission issues deeper in the structure
                 }
                 return null; // Not found in this branch
             }
    
            const fileHandle = await findFileHandleRecursive(mp_currentDirectoryHandle, songMetaData.fileName);
    
            if (!fileHandle) {
                throw new Error(`File "${songMetaData.fileName}" not found within the selected directory.`);
            }
    
            // Get the actual File object (this implicitly checks read permission for the specific file)
            fileToPlay = await fileHandle.getFile();
            console.log(`MP: Retrieved file object for: ${fileToPlay.name} (Size: ${fileToPlay.size})`);
    
             // Optional: Verify size matches metadata if needed
             if (fileToPlay.size !== songMetaData.fileSize) {
                 console.warn(`MP: File size mismatch for ${fileToPlay.name}. Metadata: ${songMetaData.fileSize}, Actual: ${fileToPlay.size}. Proceeding anyway.`);
                 // Update metadata if desired:
                 // songMetaData.fileSize = fileToPlay.size;
                 // mp_musicLibrary = mp_musicLibrary.map(s => s.id === songMetaData.id ? {...s, fileSize: fileToPlay.size} : s);
                 // await mp_saveDataToDB(); // Save updated size
             }
    
        } catch (err) {
            console.error("MP: Error getting file for playback:", err);
            alert(`MP: Error loading "${songMetaData.title}": ${err.message}. Ensure the file exists in the selected folder and the site has permission.`);
            mp_stopPlaybackAndClearUI();
            return;
        }
    
        // --- Create Temporary URL ---
        if (mp_currentSong && mp_currentSong.tempUrl) {
            URL.revokeObjectURL(mp_currentSong.tempUrl);
        }
        const tempUrl = URL.createObjectURL(fileToPlay);
        console.log(`MP: Created temp URL for ${songMetaData.fileName}`);
    
        // --- Load Player ---
        mp_currentSong = { ...songMetaData, tempUrl: tempUrl }; // Store metadata and URL
        if (mp_audioPlayer) {
            mp_audioPlayer.src = tempUrl;
            mp_audioPlayer.load(); // Important to load the new source
        }
        if (mp_seekBar) mp_seekBar.value = 0;
        if (mp_currentTime) mp_currentTime.textContent = mp_formatTime(0);
        if (mp_totalDuration) mp_totalDuration.textContent = mp_formatTime(0); // Reset duration until loadedmetadata fires
        if (mp_currentSongInfo) {
            mp_currentSongInfo.textContent = `${songMetaData.artist} - ${songMetaData.title}`;
            mp_currentSongInfo.title = `${songMetaData.artist} - ${songMetaData.title}`;
        }
    
        // Don't auto-play immediately here, wait for 'canplay' or 'loadedmetadata' maybe?
        // For simplicity, we still call mp_playAudio which handles the promise.
        mp_playAudio();
        mp_addToRecentlyPlayed(songMetaData.id); // This now calls mp_saveDataToDB
        mp_updatePlayingIndicator();
    }
    
    // Plays a song from the library view
    function mp_playSongFromLibrary(songId) {
        console.log("MP: playSongFromLibrary, ID:", songId);
        const songMeta = mp_findSongById(songId);
        if (!songMeta) return;
    
        const currentFilter = mp_songSearch ? mp_songSearch.value.toLowerCase() : '';
        mp_currentQueue = mp_musicLibrary
            .filter(s => s.title.toLowerCase().includes(currentFilter) || s.artist.toLowerCase().includes(currentFilter) || s.fileName.toLowerCase().includes(currentFilter))
            .map(s => s.id);
        mp_currentSongIndex = mp_currentQueue.findIndex(id => id === songId);
        mp_loadSong(songMeta);
    }
    
    // Starts playback of a specific playlist
    function mp_playPlaylist(playlistName) {
        console.log("MP: playPlaylist:", playlistName);
        const playlistSongIds = mp_playlists[playlistName];
        if (!playlistSongIds || playlistSongIds.length === 0) {
            alert(`MP: Playlist "${playlistName}" is empty.`);
            return;
        }
        mp_currentQueue = [...playlistSongIds];
        mp_currentSongIndex = 0;
        const firstSongMeta = mp_findSongById(mp_currentQueue[0]);
        if (firstSongMeta) {
            mp_loadSong(firstSongMeta);
        } else {
            console.error("MP: First song in playlist not found, ID:", mp_currentQueue[0]);
            mp_playNextSong(); // Try next
        }
    }
    
    // Starts audio playback
    function mp_playAudio() {
        if (!mp_currentSong || !mp_audioPlayer || !mp_audioPlayer.src) return;
        mp_audioPlayer.play()
            .then(() => { mp_isPlaying = true; mp_updatePlaybackControls(); console.log("MP: Playback started."); })
            .catch(error => {
                console.error("MP: Playback failed:", error); mp_isPlaying = false; mp_updatePlaybackControls();
                alert(`MP: Playback Error - ${error.name}: ${error.message}`);
            });
    }
    
    // Pauses audio playback
    function mp_pauseAudio() {
        if(mp_audioPlayer) mp_audioPlayer.pause();
        mp_isPlaying = false;
        mp_updatePlaybackControls();
        console.log("MP: Playback paused.");
    }
    
    // Toggles play/pause state
    function mp_togglePlayPause() {
        if (!mp_currentSong) {
            if (mp_musicLibrary.length > 0) mp_playSongFromLibrary(mp_musicLibrary[0].id);
            return;
        }
        if (mp_isPlaying) mp_pauseAudio();
        else mp_playAudio();
    }
    
    // Plays the next song in the current queue
    function mp_playNextSong() {
        if (mp_currentQueue.length === 0) { mp_stopPlaybackAndClearUI(); return; }
        let nextIndex = mp_currentSongIndex + 1;
        if (nextIndex >= mp_currentQueue.length) nextIndex = 0;
        const nextSongId = mp_currentQueue[nextIndex];
        const nextSongMeta = mp_findSongById(nextSongId);
        if (nextSongMeta) {
            mp_currentSongIndex = nextIndex;
            mp_loadSong(nextSongMeta);
        } else {
            console.warn("MP: Next song ID not found, removing from queue:", nextSongId);
            mp_currentQueue.splice(nextIndex, 1);
            if (mp_currentQueue.length > 0) mp_playNextSong(); // Recursive call
            else mp_stopPlaybackAndClearUI();
        }
    }
    
    // Plays the previous song or restarts current
    function mp_playPrevSong() {
        if (mp_currentQueue.length === 0) return;
        if (mp_audioPlayer && mp_audioPlayer.currentTime > 3) {
            mp_audioPlayer.currentTime = 0; mp_playAudio(); return;
        }
        let prevIndex = mp_currentSongIndex - 1;
        if (prevIndex < 0) prevIndex = mp_currentQueue.length - 1;
        const prevSongId = mp_currentQueue[prevIndex];
        const prevSongMeta = mp_findSongById(prevSongId);
        if (prevSongMeta) {
            mp_currentSongIndex = prevIndex;
            mp_loadSong(prevSongMeta);
        } else {
            console.warn("MP: Previous song ID not found, removing from queue:", prevSongId);
            mp_currentQueue.splice(prevIndex, 1);
            if (prevIndex < mp_currentSongIndex) mp_currentSongIndex--;
            if (mp_currentQueue.length > 0) mp_playPrevSong(); // Recursive call
            else mp_stopPlaybackAndClearUI();
        }
    }
    
    // Updates playback control buttons/UI state
    function mp_updatePlaybackControls() {
        if (!mp_playbackBarInitialized) return; // Don't update if bar isn't set up
        if (mp_playPauseButton) {
            mp_playPauseButton.innerHTML = mp_isPlaying ? '<i class="fas fa-pause"></i>' : '<i class="fas fa-play"></i>';
            mp_playPauseButton.title = mp_isPlaying ? 'Pause' : 'Play';
        }
        const canNavigate = mp_currentQueue.length > 1;
        if (mp_prevButton) mp_prevButton.disabled = !canNavigate;
        if (mp_nextButton) mp_nextButton.disabled = !canNavigate;
        mp_updatePlayingIndicator(); // Ensure list indicators are updated
    }
    
    // Formats time in seconds to M:SS
    function mp_formatTime(totalSeconds) {
        if (isNaN(totalSeconds) || totalSeconds < 0) return '0:00';
        const minutes = Math.floor(totalSeconds / 60);
        const secs = Math.floor(totalSeconds % 60);
        return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
    }
    
    // Updates seek bar progress and time display
    function mp_updateSeekBar() {
        if (!mp_audioPlayer || !mp_audioPlayer.duration || isNaN(mp_audioPlayer.duration) || !mp_seekBar) return;
        const percentage = (mp_audioPlayer.currentTime / mp_audioPlayer.duration) * 100;
        mp_seekBar.value = isNaN(percentage) ? 0 : percentage;
        if (mp_currentTime) mp_currentTime.textContent = mp_formatTime(mp_audioPlayer.currentTime);
        if (mp_totalDuration && (mp_totalDuration.textContent === '0:00' || mp_totalDuration.textContent === 'NaN:NaN')) {
             mp_totalDuration.textContent = mp_formatTime(mp_audioPlayer.duration);
        }
    }
    
    // Updates volume slider and mute button UI
    function mp_updateVolumeControls() {
        if (!mp_playbackBarInitialized || !mp_audioPlayer) return; // Check initialization
        if (mp_audioPlayer.muted || mp_audioPlayer.volume === 0) {
            if (mp_muteButton) {
                mp_muteButton.innerHTML = '<i class="fas fa-volume-mute"></i>';
                mp_muteButton.title = 'Unmute';
            }
            if (mp_volumePercentage) mp_volumePercentage.textContent = `0%`;
        } else {
            if (mp_muteButton) {
                mp_muteButton.innerHTML = '<i class="fas fa-volume-up"></i>';
                mp_muteButton.title = 'Mute';
            }
            if (mp_volumePercentage) mp_volumePercentage.textContent = `${Math.round(mp_audioPlayer.volume * 100)}%`;
        }
        if (mp_volumeSlider && !mp_audioPlayer.muted) {
            mp_volumeSlider.value = mp_audioPlayer.volume;
        }
    }
    
    // --- Recently Played Logic ---
    function mp_addToRecentlyPlayed(songId) {
        mp_recentlyPlayed = mp_recentlyPlayed.filter(id => id !== songId);
        mp_recentlyPlayed.unshift(songId);
        if (mp_recentlyPlayed.length > MP_MAX_RECENTLY_PLAYED) {
            mp_recentlyPlayed = mp_recentlyPlayed.slice(0, MP_MAX_RECENTLY_PLAYED);
        }
        mp_saveDataToLocalStorage(); // Save metadata
        if (typeof mp_renderRecentlyPlayed === 'function') mp_renderRecentlyPlayed(); // Render if available
    }
    
    // --- Playlist Management ---
    function mp_populateCreatePlaylistModalSongs() {
        const modalList = document.getElementById('mp_createPlaylistSongList');
        if (!modalList) return;
        modalList.innerHTML = '';
        if (mp_musicLibrary.length === 0) {
            modalList.innerHTML = '<p class="placeholder-text">No songs in library.</p>';
        } else {
            const sortedLibrary = [...mp_musicLibrary].sort((a, b) => `${a.artist} - ${a.title}`.localeCompare(`${b.artist} - ${b.title}`));
            sortedLibrary.forEach(song => {
                const div = document.createElement('div');
                div.className = 'list-item';
                div.style.cursor = 'default';
                div.innerHTML = `
                    <input type="checkbox" id="mp_createpl_${song.id}" value="${song.id}">
                    <label for="mp_createpl_${song.id}" title="${escapeHtml(song.artist)} - ${escapeHtml(song.title)}">${escapeHtml(song.artist)} - ${escapeHtml(song.title)}</label>`;
                modalList.appendChild(div);
            });
        }
    }
    
    function mp_openCreatePlaylistModal() {
        const nameInput = document.getElementById('mp_newPlaylistName');
        if (nameInput) nameInput.value = '';
        mp_populateCreatePlaylistModalSongs();
        mp_openModal('mp_createPlaylistModal');
    }
    
    function mp_createNewPlaylist() {
        const nameInput = document.getElementById('mp_newPlaylistName');
        const name = nameInput ? nameInput.value.trim() : '';
        if (!name) { alert("MP: Please enter a playlist name."); return; }
        if (mp_playlists[name]) { alert(`MP: Playlist "${name}" already exists.`); return; }
        const checkboxes = document.querySelectorAll('#mp_createPlaylistSongList input[type="checkbox"]:checked');
        const initialSongIds = Array.from(checkboxes).map(cb => cb.value);
        mp_playlists[name] = initialSongIds;
        mp_saveDataToLocalStorage();
        if(typeof mp_renderPlaylists === 'function') mp_renderPlaylists();
        mp_closeModal('mp_createPlaylistModal');
        console.log(`MP: Playlist "${name}" created with ${initialSongIds.length} songs.`);
    }
    
    function mp_deleteCurrentPlaylist() {
        if (!mp_currentPlaylistNameForView) return;
        if (confirm(`MP: Delete playlist "${mp_currentPlaylistNameForView}"?`)) {
            delete mp_playlists[mp_currentPlaylistNameForView];
            mp_saveDataToLocalStorage();
            if(typeof mp_renderPlaylists === 'function') mp_renderPlaylists();
            mp_closeModal('mp_viewPlaylistModal');
            console.log(`MP: Playlist "${mp_currentPlaylistNameForView}" deleted.`);
            mp_currentPlaylistNameForView = null;
        }
    }
    
    function mp_removeSongFromPlaylist(playlistName, songId) {
        if (!mp_playlists[playlistName]) return;
        mp_playlists[playlistName] = mp_playlists[playlistName].filter(id => id !== songId);
        mp_saveDataToLocalStorage();
        if (typeof mp_renderPlaylists === 'function') mp_renderPlaylists(); // Update counts
        if (document.getElementById('mp_viewPlaylistModal')?.style.display === 'flex' && mp_currentPlaylistNameForView === playlistName) {
            mp_populateViewPlaylistModal(playlistName); // Refresh modal if open
        }
    }
    
    function mp_populateViewPlaylistModal(playlistName) {
        const modalList = document.getElementById('mp_viewPlaylistModalList');
        if (!modalList) return;
        modalList.innerHTML = '';
        const songIds = mp_playlists[playlistName];
        if (!songIds || songIds.length === 0) {
            modalList.innerHTML = '<p class="placeholder-text">This playlist is empty.</p>'; return;
        }
        const songsInPlaylist = songIds.map(id => mp_findSongById(id)).filter(song => song)
                               .sort((a, b) => `${a.artist} - ${a.title}`.localeCompare(`${b.artist} - ${b.title}`));
        songsInPlaylist.forEach(song => {
            const div = document.createElement('div');
            div.className = 'list-item';
            div.style.cursor = 'default';
            div.innerHTML = `
                <span>${escapeHtml(song.artist)} - ${escapeHtml(song.title)}</span>
                <button onclick="mp_removeSongFromPlaylist('${escapeHtml(playlistName)}', '${song.id}')" title="Remove from Playlist">Remove</button>`;
            modalList.appendChild(div);
        });
    }
    
    function mp_openViewPlaylistModal(playlistName) {
        const nameEl = document.getElementById('mp_viewPlaylistName');
        if (nameEl) nameEl.textContent = `Playlist: ${playlistName}`;
        mp_currentPlaylistNameForView = playlistName;
        mp_populateViewPlaylistModal(playlistName);
        mp_openModal('mp_viewPlaylistModal');
    }
    
    
    // --- Modal Handling ---
    function mp_openModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) modal.style.display = 'flex';
    }
    
    function mp_closeModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) modal.style.display = 'none';
        // Clear specific modal content on close
        if (modalId === 'mp_viewPlaylistModal') {
            mp_currentPlaylistNameForView = null;
            const list = document.getElementById('mp_viewPlaylistModalList');
            if(list) list.innerHTML = '';
        } else if (modalId === 'mp_removeSongsModal') {
            const list = document.getElementById('mp_removeSongsModalList');
             if(list) list.innerHTML = '';
        } else if (modalId === 'mp_createPlaylistModal') {
            const list = document.getElementById('mp_createPlaylistSongList');
            if(list) list.innerHTML = '';
        }
    }
    
    function mp_openRemoveSongsModal() {
        const modalList = document.getElementById('mp_removeSongsModalList');
        if (!modalList) return;
        modalList.innerHTML = '';
        if (mp_musicLibrary.length === 0) {
            modalList.innerHTML = '<p class="placeholder-text">No songs in library.</p>';
        } else {
            const sortedLibrary = [...mp_musicLibrary].sort((a, b) => `${a.artist} - ${a.title}`.localeCompare(`${b.artist} - ${b.title}`));
            sortedLibrary.forEach(song => {
                const div = document.createElement('div');
                div.className = 'list-item';
                div.style.cursor = 'default';
                div.innerHTML = `
                    <input type="checkbox" id="mp_remove_${song.id}" value="${song.id}">
                    <label for="mp_remove_${song.id}" title="${escapeHtml(song.artist)} - ${escapeHtml(song.title)}">${escapeHtml(song.artist)} - ${escapeHtml(song.title)}</label>`;
                modalList.appendChild(div);
            });
        }
        mp_openModal('mp_removeSongsModal');
    }
    
    function mp_removeSelectedSongs() {
        const checkboxes = document.querySelectorAll('#mp_removeSongsModalList input[type="checkbox"]:checked');
        const idsToRemove = Array.from(checkboxes).map(cb => cb.value);
        if (idsToRemove.length === 0) { alert("MP: No songs selected."); return; }
    
        if (confirm(`MP: Remove ${idsToRemove.length} song(s)? This cannot be undone.`)) {
            // Check if playing song is being removed
            if (mp_currentSong && idsToRemove.includes(mp_currentSong.id)) {
                 mp_stopPlaybackAndClearUI(); // Stop playback and revoke URL
             }
            // Remove from library
            mp_musicLibrary = mp_musicLibrary.filter(song => !idsToRemove.includes(song.id));
            // Remove from recently played
            mp_recentlyPlayed = mp_recentlyPlayed.filter(id => !idsToRemove.includes(id));
            // Remove from all playlists
            Object.keys(mp_playlists).forEach(pName => {
                mp_playlists[pName] = mp_playlists[pName].filter(id => !idsToRemove.includes(id));
            });
            mp_saveDataToLocalStorage(); // Save changes
            // Re-render lists if they are currently displayed
            if (typeof mp_renderSongsList === 'function') mp_renderSongsList();
            if (typeof mp_renderRecentlyPlayed === 'function') mp_renderRecentlyPlayed();
            if (typeof mp_renderPlaylists === 'function') mp_renderPlaylists();
            mp_closeModal('mp_removeSongsModal');
            console.log(`MP: Removed ${idsToRemove.length} songs.`);
        }
    }
    
    
    // --- Initialization and Event Listeners ---
    
    // Sets up listeners for the persistent playback bar
    function mp_initializePlaybackBar() {
         if (mp_playbackBarInitialized) return; // Run only once
         console.log("MP: Initializing Playback Bar Listeners...");
    
         // Get references AFTER DOM is loaded
         mp_playPauseButton = document.getElementById('mp_playPauseButton');
         mp_prevButton = document.getElementById('mp_prevButton');
         mp_nextButton = document.getElementById('mp_nextButton');
         mp_seekBar = document.getElementById('mp_seekBar');
         mp_currentTime = document.getElementById('mp_currentTime');
         mp_totalDuration = document.getElementById('mp_totalDuration');
         mp_currentSongInfo = document.getElementById('mp_currentSongInfo');
         mp_volumeSlider = document.getElementById('mp_volumeSlider');
         mp_muteButton = document.getElementById('mp_muteButton');
         mp_volumePercentage = document.getElementById('mp_volumePercentage');
    
         // Check if all elements were found
         if (!mp_playPauseButton || !mp_prevButton || !mp_nextButton || !mp_seekBar || !mp_volumeSlider || !mp_muteButton || !mp_audioPlayer) {
             console.error("MP: Failed to find one or more essential playback control elements. Cannot initialize.");
             return;
         }
    
         // Attach listeners
         mp_playPauseButton.addEventListener('click', mp_togglePlayPause);
         mp_nextButton.addEventListener('click', mp_playNextSong);
         mp_prevButton.addEventListener('click', mp_playPrevSong);
    
         mp_seekBar.addEventListener('input', () => {
             if (!mp_audioPlayer || !mp_audioPlayer.duration || isNaN(mp_audioPlayer.duration)) return;
             const seekTime = (mp_seekBar.value / 100) * mp_audioPlayer.duration;
             if (!isNaN(seekTime)) mp_audioPlayer.currentTime = seekTime;
         });
    
         mp_volumeSlider.addEventListener('input', () => {
             if (!mp_audioPlayer) return;
             mp_audioPlayer.volume = mp_volumeSlider.value;
             mp_audioPlayer.muted = false;
             mp_updateVolumeControls();
         });
    
         mp_muteButton.addEventListener('click', () => {
              if (!mp_audioPlayer) return;
              mp_audioPlayer.muted = !mp_audioPlayer.muted;
              mp_updateVolumeControls();
         });
    
         // Audio element listeners
         mp_audioPlayer.addEventListener('timeupdate', mp_updateSeekBar);
         mp_audioPlayer.addEventListener('loadedmetadata', () => {
             if (!isNaN(mp_audioPlayer.duration)) {
                if(mp_totalDuration) mp_totalDuration.textContent = mp_formatTime(mp_audioPlayer.duration);
             }
             mp_updateSeekBar(); // Update current time immediately
         });
         mp_audioPlayer.addEventListener('ended', mp_playNextSong);
         mp_audioPlayer.addEventListener('error', (e) => {
             console.error("MP: Audio Player Error:", e);
             if(mp_currentSongInfo) mp_currentSongInfo.textContent = `Error playing ${mp_currentSong?.title || 'song'}`;
             alert(`MP: Error playing ${mp_currentSong?.title || 'song'}. Check file/permissions.`);
             mp_stopPlaybackAndClearUI();
         });
         mp_audioPlayer.addEventListener('play', mp_updatePlayingIndicator);
         mp_audioPlayer.addEventListener('pause', mp_updatePlayingIndicator);
         mp_audioPlayer.addEventListener('volumechange', mp_updateVolumeControls);
    
         mp_updateVolumeControls(); // Initial volume UI setup
         mp_updatePlaybackControls(); // Initial button state
         mp_playbackBarInitialized = true;
         console.log("MP: Playback Bar Initialized.");
     }
    
    // Initializes elements and listeners specific to the Music page content
    function mp_initializeMusicPlayerPage() {
        // Get elements specific to the music page grid - DO THIS EVERY TIME
        mp_fileInput = document.getElementById('mp_fileInput');
        mp_songsList = document.getElementById('mp_songsList');
        mp_recentlyPlayedList = document.getElementById('mp_recentlyPlayedList');
        mp_playlistsList = document.getElementById('mp_playlistsList');
        mp_songSearch = document.getElementById('mp_songSearch');

         // Check if elements were found - If not, stop and report
         if (!mp_fileInput || !mp_songsList || !mp_recentlyPlayedList || !mp_playlistsList || !mp_songSearch) {
              console.error("MP: Failed to find one or more music page elements. Cannot initialize page fully.");
              mp_isInitialized = false; // Ensure flag is false if elements are missing
              return;
         }

        if (mp_isInitialized) {
             console.log("MP: Music Player page already initialized. Re-rendering lists.");
             // Re-render lists using the newly obtained element references
             // Add a small delay here to ensure elements are fully in the DOM before rendering
             setTimeout(() => {
                 console.log("MP: Re-rendering music lists after slight delay (initialized page)...");
                 mp_renderSongsList(mp_songSearch ? mp_songSearch.value : '');
                 mp_renderRecentlyPlayed();
                 mp_renderPlaylists();
                 console.log("MP: Re-rendering complete.");
             }, 10); // Small delay, adjust if needed
             return; // Exit since initialization is complete
        }
        console.log("MP: Initializing Music Player Page Content (first time)...");

        // Attach listeners for page-specific elements - DO THIS ONLY ON FIRST INITIALIZATION
        mp_fileInput.addEventListener('change', mp_handleFileSelect);
        mp_songSearch.addEventListener('input', () => {
            mp_renderSongsList(mp_songSearch.value);
        });

        // Initial rendering of lists - DO THIS ONLY ON FIRST INITIALIZATION
         // Also add a small delay here for the very first render after page content is set
         setTimeout(() => {
            console.log("MP: Initial rendering of music lists after slight delay (first time)...");
            mp_renderSongsList();
            mp_renderRecentlyPlayed();
            mp_renderPlaylists();
            console.log("MP: Initial rendering complete.");
         }, 10); // Small delay, adjust if needed


        mp_isInitialized = true;
        console.log("MP: Music Player Page Content Initialized.");
    }


      
  </script>
</body>
</html>
