<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Underground</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <style>
    :root { /* Apply variables to the root element */
      --bg-dark: #1c1c1e;
      --sidebar-dark: #2c2c2e;
      --text-light: #fff;
      --text-muted: #aaa;
      --card-bg: #1a1a1a;
      --accent: #00ff84;
      --transition-speed: 0.3s;
      --border-radius: 8px;
      --icon-size: 1.2rem;
      --search-height: 40px; /* Added for consistent search bar height */
    }


    .reset-button {
        background-color: #ff4444;
        color: white;
        width: 100%;
        margin-top: auto !important;
    }

    .reset-button:hover {
      background-color: #cc0000;
    }


    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      display: flex;
      /* Background color is now primarily handled by Vanta.js */
      /* background-color: var(--bg-dark); */
      color: var(--text-light); /* Use variable */
      height: 100vh;
      overflow: hidden;
      position: relative; /* Needed for z-index stacking */
    }

    /* Ensure Vanta canvas is behind everything else */
    .vanta-canvas {
       z-index: -1 !important; /* Important might be needed depending on Vanta's internal styles */
       position: absolute !important;
       top: 0;
       left: 0;
       width: 100% !important;
       height: 100% !important;
    }


    .sidebar {
      width: 60px;
      position: fixed; /* Use fixed for positioning relative to viewport */
      top: 0;
      left: -60px;
      height: 100%;
      background-color: var(--sidebar-dark); /* Use variable */
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem 0;
      gap: 1.5rem;
      transition: left var(--transition-speed) ease;
      z-index: 10; /* Sidebar needs to be above Vanta */
    }

    .sidebar.open {
      left: 0;
    }

    .icon {
      color: var(--text-muted); /* Use variable */
      font-size: var(--icon-size);
      padding: 10px;
      border-radius: var(--border-radius);
      transition: background 0.2s;
      cursor: pointer;
      position: relative;
    }

    .icon:hover, .icon.active {
      background-color: var(--accent); /* Use variable */
      color: white; /* Or var(--text-light) if you want icon hover color to change */
    }

    .tooltip {
      position: fixed;
      background-color: var(--accent); /* Use variable */
      color: white; /* Or var(--text-light) */
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.8rem;
      pointer-events: none;
      z-index: 9999;
      display: none;
    }

    .content {
      flex: 1;
      padding: 2rem; /* This padding is likely causing the space at the top */
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      z-index: 5;
      position: relative;
      background-color: transparent;
      box-sizing: border-box;
      color: var(--text-light);
      /* Always allocate space for the sidebar, transition margin */
      margin-left: 60px;
      width: calc(100% - 60px);
      transition: margin-left var(--transition-speed) ease, width var(--transition-speed) ease;
    }

    .sidebar.open ~ .content {
        margin-left: 60px; /* Push content when sidebar is open */
    }

     .sidebar:not(.open) ~ .content {
        margin-left: 0;
        width: 100%;
     }


    h1 {
      margin-bottom: 2rem;
    }

    .panel {
        /* Existing styles */
        padding: 1.5rem; /* This is a good starting point, maybe increase slightly if content feels cramped */
        margin: 1rem auto; /* Use auto for left/right margin to center the block if it has a max-width */
        max-width: 800px; /* Example: Give panels a max-width to prevent them from stretching too wide on large screens */
        width: 95%; /* Ensure responsiveness */
        box-shadow: 0 4px 15px rgba(0,0,0,0.2); /* Existing shadow */
        background-color: var(--card-bg); /* Use variable */
        border-radius: var(--border-radius);
        box-sizing: border-box;
        color: var(--text-light); /* Ensure text color is set for the panel */
    }

    .panel-container {
      display: flex;
      flex-direction: column; /* Stack panels vertically */
      gap: 1rem; /* Adjust gap between panels */
      flex-wrap: wrap;
      justify-content: flex-start; /* Align panels to the start */
      opacity: 1;
      transition: opacity var(--transition-speed) ease;
      width: 100%; /* Ensure container takes width */
       align-items: center; /* Center panels horizontally */
    }

    .panel-container.fade-out {
      opacity: 0;
    }

    .panel h2 {
        margin-top: 0; /* Remove top margin from the first element */
        margin-bottom: 1rem; /* Space below the heading */
        color: var(--accent); /* Use accent for headings */
    }

    .panel h3 {
         margin-top: 1.5rem; /* Space above subheadings */
         margin-bottom: 0.8rem; /* Space below subheadings */
         color: var(--text-light); /* Or var(--accent) */
    }

    .panel p {
        margin-bottom: 1em; /* Space below paragraphs */
         color: var(--text-muted); /* Use variable for paragraph text */
    }

    input[type="text"] {
      background: var(--card-bg); /* Use variable */
      border: 1px solid var(--accent); /* Use variable */
      padding: 0.5rem;
      width: 100%; /* Take full width of parent */
      margin-bottom: 0.5rem;
      color: var(--text-light); /* Use variable */
      border-radius: 5px;
      transition: border var(--transition-speed) ease;
      box-sizing: border-box; /* Include padding and border in element's total width */
       height: var(--search-height); /* Use defined height */
       font-size: 1rem; /* Adjust font size */
       padding-left: calc(0.5rem + 24px); /* Space for search icon */
    }

    input[type="text"]:focus {
      outline: none;
      border-color: var(--text-light); /* Use variable */
    }

    button {
      background-color: var(--accent); /* Use variable */
      color: black; /* Changed for better contrast on accent, or use var(--bg-dark) */
      border: none; /* Removed border */
      padding: 0.5rem 1rem;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      transition: all var(--transition-speed) ease;
    }

    button:hover {
      filter: brightness(1.2); /* Brighter accent on hover */
      box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Slight shadow on hover */
    }


    .game-card, .action-card {
      background-color: var(--card-bg); /* Use variable */
      border-radius: 10px;
      padding: 1rem;
      text-align: center;
      cursor: pointer;
      transition: transform 0.2s;
      width: 150px;
      position: relative;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2); /* Add shadow */
    }

    .game-card:hover, .action-card:hover {
      transform: scale(1.05);
    }

    .game-card img {
      width: 100%;
      border-radius: var(--border-radius);
      margin-bottom: 0.5rem;
    }

    .iframe-container {
       position: absolute;
       top: 0;
       left: 0;
       right: 0;
       bottom: 100%;
       display: flex;
       justify-content: center;
       align-items: center;
       width: 100%;
       height: 100;
       z-index: 20;
       background: var(--bg-dark);
    }

    .iframe-container iframe {
       width: 100%;
       height: 100%;
       border: none;
    }
    
    #page-content iframe#mainViewerIframe {
       width: 100%;
       flex-grow: 1; /* Ensures the iframe takes up available space */
       height: 600px; /* Add this line - common flexbox optimization */
       border: none;
       display: block;
       margin: 0; /* Remove any potential default margin */
       padding: 0; /* Remove any potential default padding */
    }
      
    #page-content {
        flex-grow: 1; /* Make #page-content grow to fill available space */
        display: flex; /* Ensure it is a flex container */
        flex-direction: column; /* Keep its children stacked vertically */
        /* Add other necessary styles for #page-content if they are not inherited */
    }

    /* Adjust .bottom-controls when it's directly inside page-content (Viewer page active) */
    /* Use a more specific selector if needed, or rely on the existing .bottom-controls rule */
     #page-content .bottom-controls#viewer-bottom-controls {
        /* The existing .bottom-controls rule should largely work here */
        /* You might add specific overrides if needed, but try without first */
         flex-shrink: 0; /* Ensure controls don't shrink */
         margin-top: auto; /* Push to bottom */
         width: 100%; /* Ensure full width within #page-content */
     }

    /* Keep the general .bottom-controls styles */
    .bottom-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 10px;
      background-color: var(--bg-dark);
      border-top: 1px solid #444;
      box-sizing: border-box;
      /* width: 100%; REMOVE width here, let the specific rule above control it */
      /* flex-shrink: 0; REMOVE here, control on the specific rule */
      /* margin-top: auto; REMOVE here, control on the specific rule */
    }

     /* Add or adjust styles for inputs within bottom controls */
    #page-content .bottom-controls#viewer-bottom-controls input[type="text"] {
         flex: 1;
         padding: 8px;
         border-radius: 4px;
         border: 1px solid #ccc;
         margin-right: 10px;
         background-color: var(--card-bg);
         color: var(--text-light);
          padding-left: 8px;
          height: auto;
          font-size: 0.9rem;
          margin-bottom: 0;
    }

     /* Add or adjust styles for buttons within bottom controls */
    #page-content .bottom-controls#viewer-bottom-controls button {
         padding: 8px 16px;
         border: none;
         border-radius: 4px;
         cursor: pointer;
         display: flex;
         align-items: center;
         background-color: var(--accent);
         color: black;
          font-weight: normal;
          margin-top: 0;
    }
    #page-content .bottom-controls#viewer-bottom-controls button:hover {
       filter: brightness(1.2);
    }

     /* Adjust input within bottom controls */
    .bottom-controls input[type="text"] {
      flex: 1;
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      margin-right: 10px;
      background-color: var(--card-bg);
      color: var(--text-light);
       padding-left: 8px; /* Remove space for icon */
       height: auto; /* Remove fixed height */
       font-size: 0.9rem; /* Adjust font size */
       margin-bottom: 0; /* Remove margin-bottom */
    }

     /* Adjust button within bottom controls */
    .bottom-controls button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      background-color: var(--accent);
      color: black;
       font-weight: normal;
       margin-top: 0; /* Remove margin-top */
    }
    .bottom-controls button:hover {
       filter: brightness(1.2);
    }

    .bottom-icons {
      margin-top: auto;
      border-top: 1px solid #444; /* Keep static or make a variable */
      padding-top: 1rem;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .bottom-icons .icon {
      margin-top: 1rem;
    }
      

    .viewer-page-content iframe {
       width: 100%;
       flex-grow: 1; /* Ensures the iframe takes up available space */
       height: 0; /* Add this line - common flexbox optimization */
       border: none;
       display: block; /* Remove any potential extra space below iframe */
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7); /* Keep static or make a variable */
      z-index: 100;
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background-color: var(--card-bg); /* Use variable */
      padding: 2rem;
      border-radius: var(--border-radius);
      width: 300px;
      position: relative;
      box-shadow: 0 5px 20px rgba(0,0,0,0.3); /* Keep static or make a variable */
    }

    .modal-close {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: var(--text-muted); /* Use variable */
      font-size: var(--icon-size);
      cursor: pointer;
    }

    .modal-close:hover {
      color: white; /* Or var(--text-light) */
    }

    .modal-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 1rem;
    }

    .games-container {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem; /* Increased gap */
        justify-content: center;
        padding: 1rem; /* Add padding */
        width: 100%; /* Take full width */
    }

    .games-header {
      display: flex;
      justify-content: center;
      gap: 1rem;
      width: 100%;
      margin-bottom: 1rem;
    }

    .remove-game {
      margin-top: 1rem;
      background-color: #ff4444; /* Keep specific color or make a variable */
      color: white;
      font-weight: bold;
      width: 100%;
    }

    .remove-icon {
      position: absolute;
      top: 5px;
      right: 5px;
      color: #ff4444; /* Keep specific color or make a variable */
      background: rgba(0,0,0,0.7); /* Keep static or make a variable */
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      cursor: pointer;
      z-index: 2;
      transition: background 0.2s, color 0.2s;
    }

    .remove-icon:hover {
      background: #ff4444; /* Keep specific color or make a variable */
      color: white;
    }


    .game-card.dragging {
      opacity: 0.5;
      transform: scale(0.95);
    }

    .game-card-placeholder {
      border: 2px dashed #444; /* Keep static or make a variable */
      background-color: transparent;
    }

    .theme-option {
      width: 50px;
      height: 50px;
      margin: 5px;
      cursor: pointer;
      transition: transform 0.2s, border-color 0.2s; /* Smooth transition */
    }

    .theme-option:hover {
      transform: scale(1.1);
       border-color: rgba(255, 255, 255, 0.5); /* Subtle border on hover */
    }

    .theme-option.selected {
      border-color: var(--accent); /* Use variable */
      transform: scale(1.1);
    }

    .theme-selector {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 1rem;
    }

    .theme-default-preview { background: linear-gradient(135deg, #1c1c1e 50%, #2c2c2e 50%); }
    .theme-cyberpunk-preview { background: linear-gradient(135deg, #0f0f1a 50%, #1a1a2e 50%); }
    .theme-sunset-preview { background: linear-gradient(135deg, #2c1a1a 50%, #4a2c2c 50%); }
    .theme-forest-night-preview { background: linear-gradient(135deg, #0d1a0b 50%, #1a2e17 50%); }
    .theme-midnight-sky-preview { background: linear-gradient(135deg, #1a1c2e 50%, #2b2e4a 50%); }
    .theme-volcano-preview { background: linear-gradient(135deg, #3a0d0d 50%, #5f1c1c 50%); }
    .theme-arctic-preview { background: linear-gradient(135deg, #0a1a1c 50%, #1c3a3d 50%); }
    .theme-grayscale-preview { background: linear-gradient(135deg, #1c1c1c 50%, #2c2c2c 50%); }
    .theme-sunny-preview { background: linear-gradient(135deg, #4a3a1a 50%, #6a4a1a 50%); }
    .theme-marine-preview { background: linear-gradient(135deg, #0f2a3a 50%, #1a3c4a 50%); }
    .theme-swamp-preview { background: linear-gradient(135deg, #2b2b1c 50%, #3a3a2a 50%); }
      
    .favorite-button {
      background-color: transparent;
      color: var(--text-muted); /* Use muted text color variable */
      border: none;
      padding: 5px 8px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: all 0.2s;
    }

    .favorite-button:hover {
      background-color: rgba(255,255,255,0.1); /* Keep static or make a variable */
      color: var(--text-light); /* Lighten on hover using variable */
    }
     .favorite-button i.fa-star { /* Style filled star */
        color: var(--accent); /* Use variable */
     }


    #librarySearch {
        margin: 1rem auto; /* Add margin */
        display: block;
        width: 80%;
        max-width: 400px; /* Max width */
    }

    .library-item {
      position: relative;
      padding: 4px 12px;
      border-radius: 6px;
      transition: all 0.2s ease;
      width: 90%;
      margin: 4px auto;
      background-color: var(--card-bg); /* Use variable */
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 30px;
      min-height: 30px;
      box-sizing: border-box;
      overflow: hidden;
    }

    .library-item-content {
      flex: 1;
      text-align: left; /* Align left */
      padding: 0 35px 0 25px; /* Adjust padding for icons */
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 0.9rem;
      border-radius: 4px;
      transition: all 0.2s ease;
      color: var(--text-light); /* Ensure text is visible using variable */
    }

    .library-item:hover {
       background-color: var(--sidebar-dark); /* Darker background on hover using variable */
    }

    .library-item:hover .library-item-content {
       color: var(--accent); /* Accent color for text on hover using variable */
       background-color: transparent; /* Remove background change */
     }


    .library-item .remove-icon {
      position: absolute;
      left: 6px;
      top: 50%; /* Center vertically */
      transform: translateY(-50%); /* Center vertically */
      color: var(--text-muted); /* Use variable */
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s;
      z-index: 2;
    }

    .library-item:hover .remove-icon {
       color: #ff4444; /* Red remove icon on hover - keep static or make variable */
       background: rgba(255, 68, 68, 0.2); /* Slight red background - keep static or make variable */
    }


    .favorite-transition {
      opacity: 0;
      transition: opacity var(--transition-speed) ease;
    }

    .favorite-transition.show {
      opacity: 1;
    }

    .action-card i {
      font-size: 2rem;
      margin-bottom: 0.5rem;
      color: var(--accent); /* Use variable */
    }

    .action-card p {
      margin: 0;
       color: var(--text-muted); /* Muted text for actions using variable */
    }
     .action-card:hover p {
        color: var(--text-light); /* Lighten text on hover using variable */
     }

    .library-columns {
      display: flex;
      flex-wrap: wrap; /* Allow wrapping on smaller screens */
      gap: 2rem;
      justify-content: center;
      width: 100%;
    }

    .library-column {
      flex: 1;
      min-width: 250px; /* Min width before wrapping */
      max-width: 45%;
    }

    .library-column h3 {
      text-align: center;
      margin-bottom: 1rem;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--accent); /* Use variable */
      color: var(--accent); /* Accent color for headings using variable */
    }
    /* Add specific styling for changelog modal content */
    #changelogContent {
        background-color: var(--bg-dark); /* Match theme background */
        color: var(--text-light); /* Match theme text color */
        padding: 1rem;
        border-radius: var(--border-radius);
        max-height: 60vh;
        max-width: 900px;/* Limit height */
        overflow-y: auto; /* Allow scrolling */
        border: 1px solid var(--sidebar-dark); /* Subtle border using variable */
    }

    /* --- Home Page Specific Styles --- */
    .home-bottom-section {
        display: flex; /* Use flexbox to place news and game button side-by-side */
        justify-content: space-between; /* Push items to the ends */
        align-items: flex-start; /* Align items to the top */
        gap: 20px; /* Space between news and game button */
        width: 95%; /* Match the width of the news panel */
        max-width: 1100px; /* Adjust max-width as needed to accommodate both */
        margin: 0 auto; /* Center the section */
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
    }

    .home-layout {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%; /* Take full height of content container */
        position: relative; /* Needed for absolute positioning of middle section */
        align-items: center; /* Center items horizontally by default */
        overflow-y: auto; /* Allow scrolling if content exceeds height */
        padding-top: 20px; /* Add some space at the top */
    }

    .home-header {
        width: 100%;
        text-align: center; /* Center the logo */
        margin-bottom: 20px; /* Space below the logo */
    }

    .home-logo {
        font-size: 3rem; /* Large font size for the name */
        font-weight: bold;
        color: var(--text-light); /* Ensure name is bright using variable */
        text-shadow: 0 0 10px var(--accent); /* Optional: glow effect using variable */
    }

    .home-main-section {
        display: flex;
        align-items: center;
        justify-content: center; /* Center the items horizontally */
        gap: 20px; /* Space between items */
        margin-bottom: 30px; /* Space below this section */
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
    }

    .home-search-container {
        display: flex;
        align-items: center;
        position: relative; /* For search icon */
        flex-grow: 1; /* Allow search to take available space */
        max-width: 400px; /* Limit max width */
    }

    .home-search-container input[type="text"] {
        flex-grow: 1; /* Allow input to fill space */
        padding-left: calc(1rem + 24px); /* Adjust padding for icon */
    }

    .home-search-container .search-icon {
        position: absolute;
        left: 10px;
        color: var(--text-muted); /* Use variable */
        font-size: 1.2rem;
        height: var(--search-height); /* Match search height */
        display: flex;
        align-items: center; /* Vertically center icon */
    }

    .home-status {
        color: var(--text-muted); /* Use variable */
        font-size: 0.9rem;
        display: flex; /* Use flexbox for status items */
        gap: 15px; /* Space between status items */
    }

    .home-status p {
        margin: 0; /* Remove default paragraph margin */
    }


    .home-news-panel {
        width: 95%; /* Adjust width as needed */
        max-width: 800px; /* Limit max width */
        margin: 0 auto; /* Center the news panel */
        flex-shrink: 0; /* Prevent shrinking */
        flex: 2;
        min-width: 300px;
    }

     /* Explicitly set color for the pre tag containing news content */
    #news-content {
        color: var(--text-light); /* Ensure news content text uses the light text color variable */
    }


    .game-of-day-container {
        flex: 1; /* Allow the game container to take remaining space */
        min-width: 180px; /* Minimum width for the game container */
        max-width: 200px; /* Maximum width for the game container */
        display: flex; /* Use flex to center the button */
        flex-direction: column; /* Stack content vertically if needed */
        align-items: center; /* Center button horizontally */
        padding: 1.5rem; /* Add padding similar to panels */
        background-color: var(--card-bg); /* Use card background variable */
        border-radius: var(--border-radius); /* Use defined radius */
        box-shadow: 0 4px 15px rgba(0,0,0,0.2); /* Add shadow */
         text-align: center; /* Center text inside */
         box-sizing: border-box; /* Include padding in width */
    }

     .game-of-day-container h3 {
         margin-top: 0;
         margin-bottom: 1rem;
         color: var(--accent); /* Use variable */
     }


    .game-of-day-button {
        /* Inherit styles from game-card but maybe adjust size */
        background-color: var(--card-bg); /* Use variable */
        border-radius: 10px;
        padding: 1rem;
        text-align: center;
        cursor: pointer;
        transition: transform 0.2s;
        width: 100%; /* Take full width of its container */
        position: relative;
        box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        box-sizing: border-box; /* Include padding in width */
         /* Ensure flex properties don't conflict if container is flex */
         flex-shrink: 0;
         flex-grow: 0;
         margin: 0; /* Remove margin if inheriting from game-card */
    }

     .game-of-day-button:hover {
        transform: scale(1.05);
     }

     .game-of-day-button img {
        width: 100%;
        border-radius: var(--border-radius);
        margin-bottom: 0.5rem;
     }
      .game-of-day-button p {
          margin: 0;
          color: var(--text-light); /* Use variable */
          font-weight: bold;
      }

    .changelog-button {
        background-color: var(--accent); /* Use the theme's accent color variable */
        color: black; /* Set text color to black for contrast on the accent color */
        border: none; /* Remove the border */
        padding: 0.5rem 1rem;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: all var(--transition-speed) ease;
        display: flex; /* Use flexbox to align the icon and text */
        align-items: center; /* Vertically center the icon and text */
        gap: 5px; /* Add a small gap between the icon and the text */
    }

    .changelog-button:hover {
        filter: brightness(1.2); /* Make the button slightly brighter on hover */
        box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Add a subtle shadow on hover */
    }
/* Updated styles for Settings Grid Layout */
/* Updated styles for Settings Grid Layout */
 .settings-grid-container {
     display: grid;
     grid-template-columns: repeat(3, 1fr); /* Exactly 3 equal columns */
     gap: 1.5rem; /* Space between grid items */
     padding: 1rem; /* Add some padding around the grid */
     max-width: 900px; /* Limit the maximum width of the grid */
     margin: 0 auto; /* Center the grid */
     /* Add responsiveness: Below a certain width, allow fewer columns */
     @media (max-width: 900px) {
         grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /* Adjust min width as needed */
         max-width: none; /* Allow it to take more width on smaller screens */
     }
      @media (max-width: 550px) { /* Further adjust for very small screens */
          grid-template-columns: 1fr; /* Single column */
      }
 }

.settings-grid-item {
    background-color: var(--card-bg); /* Use variable */
    border-radius: var(--border-radius);
    padding: 1.5rem; /* Adjust padding as needed */
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    display: flex; /* Use flexbox for content within the item */
    flex-direction: column; /* Stack content vertically */
    /* Removed justify-content: space-between; to allow content to flow naturally */
    /* Removed aspect-ratio for more horizontal flexibility */
    box-sizing: border-box; /* Include padding in the size */
    text-align: center; /* This centers the text inside */
    height: 100%; /* Ensure items in the same row have equal height */
}

.settings-grid-item h2 {
     margin-top: 0;
     margin-bottom: 1rem;
     color: var(--accent); /* Use variable */
     font-size: 1.2rem;
     /* Removed margin-right: 60px; */
     text-align: center; /* Ensure the h2 content itself is centered */
 }

 .settings-grid-item h3 {
      color: var(--text-light); /* Use variable */
      margin-top: 0.8rem; /* Space above subheadings */
      margin-bottom: 0.5rem;
      font-size: 1rem; /* Adjust subheading size */
 }

    .settings-grid-item p {
        font-size: 0.9rem;
        color: var(--text-muted); /* Use variable */
        margin-bottom: 0.8rem;
        flex-grow: 1; /* Add this line to make the paragraph take up available space */
    }

   .settings-grid-item button {
       margin-top: 0.8rem; /* Add margin above buttons */
       width: 100%; /* Make buttons full width */
   }

   .settings-grid-item input[type="text"],
   .settings-grid-item select {
        width: 100%;
        margin-bottom: 0.8rem;
        box-sizing: border-box;
         padding: 0.5rem; /* Add padding */
         background-color: var(--bg-dark); /* Darker background using variable */
         color: var(--text-light); /* Light text using variable */
         border: 1px solid var(--sidebar-dark); /* Subtle border using variable */
         border-radius: 5px;
   }

    /* Specific adjustments for Theme Selector within grid item */
    .settings-grid-item .theme-selector {
        justify-content: center; /* Center theme options */
        flex-wrap: wrap;
        gap: 5px; /* Adjust gap for smaller icons */
        margin-top: 0.5rem;
        flex-grow: 1; /* Allow theme selector to take up space */
         align-items: center; /* Center vertically if space available */
    }

    .settings-grid-item .theme-option {
        width: 40px; /* Smaller size for theme options in grid */
        height: 40px;
         margin: 0; /* Remove margin defined elsewhere */
    }

     /* Style for the select dropdown arrow */
    .settings-grid-item select {
        -webkit-appearance: none; /* Remove default arrow */
        -moz-appearance: none;
        appearance: none;
        /* The fill color in the SVG is calculated based on --text-light */
        background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.362%22%20height%3D%22292.362%22%3E%3Cpath%20fill%3D%22%23${encodeURIComponent(getComputedStyle(document.documentElement).getPropertyValue('--text-light').trim().substring(1))}%22%20d%3D%22M287.9%20197.2c.9%201.3%201.1%202.9.8%204.3s-1.3%202.6-2.6%203.5l-124.5%20124.5c-1.8%201.8-4.3%202.9-7.4%202.9s-5.7-1.1-7.4-2.9l-124.7-124.7c-1.8-1.8-2.9-4.1-2.9-6.3s1.1-4.5%202.9-6.3l20.8-20.8c1.9-1.9%204.5-3%207.8-3%203.3%200%205.9%201.1%207.8%203l96.8%2096.7%2096.7-96.7c1.9-1.9%204.5-3%207.8-3%203.2%200%205.8%201.1%207.8%203l20.8%2020.8z%22%2F%3E%3C%2Fsvg%3E');
        background-repeat: no-repeat;
        background-position: right 0.7em top 50%, 0 0;
        background-size: 0.65em auto, 100%;
    }

    /* Style for individual setting reset buttons */
/* Style for individual setting reset buttons */
    .setting-reset-button {
        background-color: #666; /* Grey background - keep static or make variable */
        color: white;
        padding: 0.3rem 0.6rem; /* Smaller padding */
        font-size: 0.8rem;     /* Smaller font size */
        border-radius: 4px;
        border: none;
        cursor: pointer;
        transition: background-color 0.2s;
        /* Use margin-top: auto to push the button to the bottom in the flex column */
        margin-top: auto;
        /* Ensure it is a block element to take up its own line and center horizontally */
        display: block;
        /* Center horizontally within the flex item */
        margin-left: auto;
        margin-right: auto;
        /* Optional: set a specific width if not 100% */
        width: fit-content; /* Adjust width based on content */
    }

    .setting-reset-button:hover {
        background-color: #888; /* Lighter grey on hover - keep static or make variable */
    }

    /* Adjust grid item padding if needed to accommodate buttons */
    .settings-grid-item {
         position: relative; /* Needed for absolute/float positioning inside */
         padding-bottom: 3rem; /* Add more bottom padding if buttons overlap */
     }
    .settings-grid-item h2 {
         margin-top: 0;
         margin-bottom: 1rem;
         color: var(--accent); /* Use variable */
         font-size: 1.2rem; /* Adjust heading size */
         /* Removed margin-right: 60px; */
         text-align: center; /* Ensure the title text is centered */
     }


    /* --- Update Overlay Styles --- */
    .update-overlay {
        display: none; /* Hidden by default */
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8); /* Semi-transparent dark background */
        z-index: 200; /* Ensure it's above other elements like modals */
        justify-content: center;
        align-items: center;
        backdrop-filter: blur(5px); /* Optional: Add a blur effect */
    }
    
    .update-message-box {
        background-color: var(--card-bg);
        padding: 2rem;
        border-radius: var(--border-radius);
        text-align: center;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
        /* Keep the increased max-width to help with horizontal text flow */
        max-width: 350px; /* Or your preferred wider value */
        width: 90%;
        color: var(--text-light);
    }
    
    .update-message-box h2 {
        margin-top: 0;
        color: var(--accent);
        margin-bottom: 1rem;
    }
    
    .update-message-box button {
        margin-top: 0.5rem;
        padding: 0.5rem 1rem; /* Button size adjustments */
        font-size: 1rem;
         margin-right: 0 !important; /* Ensure no extra margin on buttons */
         margin-top: 0;
    }
    
    /* Optional: Style for disabled download button */
    .update-message-box button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
      
    .update-options-container {
        margin-top: 1.5rem;
        display: flex;
        flex-direction: column; /* Stack the options vertically */
        /* Increase the gap to add more vertical space between options */
        gap: 20px; /* Increased gap */
        align-items: center; /* Center items horizontally */
    }
    
    .update-option {
        display: flex;
        /* Change direction to stack items vertically */
        flex-direction: column;
        /* Center items horizontally within the column */
        align-items: center;
        gap: 5px; /* Reduce gap since items are now stacked */
        /* Remove flex-wrap as items are explicitly stacked */
        /* flex-wrap: wrap; */
        /* Ensure the whole option is centered or takes appropriate width */
        width: 100%; /* Allow the option container to take full width within its parent */
    }

    
    .update-option button {
        /* Keep button size adjustments */
        padding: 0.5rem 1rem;
        font-size: 1rem;
        margin: 0 !important; /* Remove all margins to control spacing with gap */
         width: auto; /* Ensure button doesn't stretch to full width */
    }
    
    .update-option p {
        margin: 0; /* Remove default paragraph margin */
        font-size: 0.9rem;
        color: var(--text-muted);
        /* Remove flex-grow as text is now below the button */
        /* flex-grow: 1; */
        /* Center the text itself */
        text-align: center;
         max-width: 100%; /* Ensure text doesn't overflow if very long */
         box-sizing: border-box; /* Include padding/border in width */
    }

    /* --- Sliding Notification Styles --- */
    .sliding-notification {
        background-color: var(--card-bg); /* Use theme card background */
        color: var(--text-light); /* Use theme text color */
        padding: 1rem 1.5rem; /* Adjust padding as needed */
        border-radius: var(--border-radius);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        word-wrap: break-word; /* Prevent long words from overflowing */
        overflow-wrap: break-word; /* Standard property */
        opacity: 0; /* Start hidden */
        transform: translateX(120%); /* Start off-screen to the right */
        transition: transform 0.5s ease-out, opacity 0.5s ease-out; /* Animation */
        pointer-events: auto; /* Allow clicks on the notification itself */
        position: relative; /* Needed for progress bar positioning */
        /* Initial display state will be handled by JS setting display: block/none */
        display: none;
    }
    
    .sliding-notification.show {
        opacity: 1; /* Fade in */
        transform: translateX(0); /* Slide in to position */
    }

    .sliding-notification h3 {
        margin-top: 0;
        margin-bottom: 0.5rem; /* Space below the title */
        color: var(--accent); /* Use theme accent color for title */
        font-size: 1.1rem;
    }

    .sliding-notification div { /* Styling for the body content */
        font-size: 0.9rem;
        line-height: 1.4;
        color: var(--text-muted); /* Muted text for body */
        /* Styling to match news text (from your <pre id="news-content"> styles) */
        white-space: pre-wrap; /* Allow wrapping but preserve line breaks */
        font-family: inherit; /* Use the same font as the rest of the body */
        text-align: left; /* Left-align the text */
         margin-top: 0.5rem; /* Add some space above the body */
    }

    .notification-progress-bar {
        position: absolute;
        bottom: 0; /* Position at the bottom edge */
        left: 0; /* Start from the left edge */
        width: 100%; /* Start with the bar fully visible */
        height: 4px; /* Set the height of the progress line */
        background-color: var(--accent); /* Use the theme's accent color */
        /* Define the transition for the width property */
        transition-property: width;
        /* Use linear timing for steady progress. Duration set by JS. */
        transition-timing-function: linear;
        /* Ensure the border radius doesn't clip the corners if parent has one */
        border-bottom-left-radius: var(--border-radius);
        border-bottom-right-radius: var(--border-radius);
    }

    /* Style for individual notification close button */
     .notification-close-button {
         position: absolute;
         top: 5px;
         right: 5px;
         background: none;
         border: none;
         color: var(--text-muted);
         font-size: 0.8rem; /* Smaller close button */
         cursor: pointer;
         z-index: 1; /* Above text/progress bar */
         padding: 0; /* Remove padding */
         width: 20px; /* Make it a small square clickable area */
         height: 20px;
         display: flex;
         align-items: center;
         justify-content: center;
         border-radius: 50%; /* Make it round */
         transition: color 0.2s, background-color 0.2s;
     }

     .notification-close-button:hover {
         color: var(--text-light);
         background-color: rgba(255, 255, 255, 0.1); /* Subtle hover effect */
     }

    #notificationContainer {
        position: fixed;
        top: 20px; /* Distance from the top */
        right: 20px; /* Distance from the right */
        z-index: 150; /* Ensure it's above content but below main overlays */
        display: flex;
        flex-direction: column; /* Stack notifications vertically */
        gap: 10px; /* Space between stacked notifications */
        max-width: 300px; /* Limit the width of the container */
        pointer-events: none; /* Allow clicks to pass through the container */
    }

        /* Music Player Specific Layout */
/* Base for the new music page layout */
    .music-page-container {
        display: flex;
        flex-wrap: wrap; /* Allow columns to wrap on smaller screens */
        gap: var(--padding, 20px); /* Increased gap for better separation */
        width: 100%;
        padding-bottom: 80px; /* Space for fixed controls bar */
    }

    .music-main-column {
        flex: 2; /* Takes up more space */
        min-width: 300px; /* Minimum width before wrapping */
        display: flex;
        flex-direction: row; /* Change from column to row */
        flex-wrap: wrap; /* Add this to allow wrapping */
        gap: var(--padding, 20px); /* Keep the gap */
    }

/* Ensure sidebar column stacks its children vertically */
    .music-sidebar-column {
        flex: 1;
        min-width: 250px;
        display: flex;
        flex-direction: column; /* <<< Ensure this is column */
        gap: var(--padding, 20px);
    }
      
    .music-main-column .music-section-box { /* Target the boxes within the main column */
        flex: 1; /* Allow boxes to grow and shrink */
        min-width: 300px; /* Set a minimum width for each box before wrapping */
        display: flex; /* Keep flex for inner content like lists */
        flex-direction: column; /* Keep inner content stacked */
        /* Remove fixed min-height if present, let content define height */
    }
    .music-main-column .music-section-box .scrollable-list { /* Target lists in the main column */
        flex-grow: 1;
        overflow-y: auto;
        margin-top: 10px;
        padding-right: 8px; /* From previous suggestion */
        /* Calculate max-height based on desired number of items */
        /* Assuming an item height of ~45-50px (padding + text + margin) */
        /* For 8 items: 8 * ~48px = 384px. Adjust as needed. */
        max-height: 384px; /* Adjust this value after testing item heights */
        min-height: 100px; /* Keep a minimum height so it doesn't collapse */
    }
    /* Container for the side-by-side action boxes */
    .music-sidebar-top-row {
        display: flex; /* Arrange children horizontally */
        gap: var(--padding, 20px); /* Space between the two boxes */
        width: 100%; /* Take full width of the sidebar column */
    }

    /* Styling for the smaller action boxes */
    .music-action-box {
        flex: 1; /* Make boxes share space equally */
        background-color: var(--card-bg);
        border-radius: var(--border-radius);
        padding: 15px; /* Slightly reduced padding */
        display: flex;
        flex-direction: column;
        color: var(--text-light);
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        min-height: 150px; /* Adjust min-height as needed */
        justify-content: space-between; /* Pushes button towards bottom if content is short */
    }

    .music-action-box h2 {
        margin-top: 0;
        margin-bottom: 10px; /* Reduced space */
        color: var(--accent);
        font-size: 1.1em; /* Smaller header */
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .music-action-box p {
        font-size: 0.85em; /* Smaller text */
        color: var(--text-muted);
        margin-bottom: 10px;
        line-height: 1.4;
        flex-grow: 1; /* Allow paragraph to take up space */
    }

    /* Style for smaller buttons within action boxes */
    .music-action-box .button-small {
        padding: 8px 12px; /* Smaller padding */
        font-size: 0.9em; /* Smaller font */
        width: 100%; /* Keep full width */
        margin-top: 5px; /* Ensure some space above button */
    }
    /* Ensure the Permission Prompt UI (added via JS) fits nicely */
    #mp_permission_prompt button {
         font-size: 0.85em; /* Smaller button text */
         padding: 5px 10px;
     }
     #mp_permission_prompt p {
         font-size: inherit; /* Inherit size from container */
         margin-bottom: 5px;
     }

    /* Style for the Playlist List Box below the top row */
    #playlists-list-box {
       flex-grow: 1; /* Allow playlist box to take remaining vertical space */
       /* Inherits base .music-section-box styles */
    }

     /* Adjust scrollable list height in the main playlist box */
    #playlists-list-box .scrollable-list {
        display: grid; /* Use CSS Grid */
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); /* Responsive grid: min item width 150px, auto-fill container */
        gap: 15px; /* Gap between grid items */
        padding-right: 0; /* Remove padding if scrollbar is overlayed or styled */
        overflow-y: auto; /* Enable vertical scrolling */
        /* Set min and max height for the scrollable area */
        min-height: 180px; /* Ensure at least one card's height is accommodated */
        max-height: 375px; /* Roughly allows two rows of 180px cards (180*2 + 15 gap) before scrolling */
    }
/* --- New Styles for Youtube Modal --- */
    /* Re-use .mp-modal and .mp-modal-content */

    #mp_Youtube-input {
        flex-grow: 1; /* Allow input to take available space */
        /* Inherits general input[type="text"] or type="search" styles */
        padding: 0.6rem 0.8rem; /* Consistent padding */
        height: auto; /* Remove fixed height */
        font-size: 1rem;
        margin-bottom: 0; /* Remove bottom margin here as gap is used */
         /* Adjust padding-left if you add a search icon here */
         padding-left: 0.8rem;
    }

    #mp_Youtube-input:focus {
        border-color: var(--accent);
        outline: none;
        box-shadow: 0 0 0 2px var(--accent-transparent, rgba(0, 255, 132, 0.3)); /* Add focus ring */
    }

     #mp_Youtube-button {
         flex-shrink: 0; /* Prevent button from shrinking */
         /* Inherits general button styles */
         padding: 0.6rem 1rem; /* Adjust padding for search button */
         font-size: 1rem;
         height: auto;
         margin-top: 0; /* Remove margin if inheriting */
     }

    #mp_youtube-results-list .list-item {
        /* Inherits general list-item styles */
        cursor: pointer;
        display: flex; /* Use flex to align icon and text */
        align-items: center; /* Vertically center items */
        gap: 8px; /* Space for potential icon */
    }

     #mp_youtube-results-list .list-item:hover,
     #mp_youtube-results-list .list-item:focus-visible { /* Added focus-visible */
         background-color: var(--sidebar-dark);
         border-color: var(--accent);
         color: var(--accent);
         outline: none; /* Remove default outline */
     }

     #mp_youtube-results-list .list-item .youtube-icon {
         flex-shrink: 0; /* Prevent icon from shrinking */
         color: red; /* Standard YouTube red */
         font-size: 1em; /* Match text size */
     }

      #mp_youtube-results-list .list-item span {
          flex-grow: 1; /* Allow text to take available space */
          overflow: hidden; /* Hide overflowing text */
          text-overflow: ellipsis; /* Show ellipsis for overflow */
          white-space: nowrap; /* Keep text on a single line */
          /* Inherits text color */
      }
    /* --- End Youtube Modal Styles --- */

    /* --- Styles for the Tiny Hidden Player --- */
     #mp_youtube_hidden_player {
         /* These styles make the div effectively invisible and non-interactive */
         position: fixed;
         bottom: 0;
         right: 0;
         width: 1px;
         height: 1px;
         z-index: 9999; /* Ensure it's behind everything */
         overflow: hidden; /* Hide its contents */
         opacity: 0; /* Ensure it's not visible even if size is briefly wrong */
         pointer-events: none; /* Prevent any mouse interaction */
     }
    /* Ensure the iframe inside also respects these properties */
     #mp_youtube_hidden_player iframe {
         width: 1px;
         height: 1px;
         opacity: 0;
         pointer-events: none;
         border: none; /* Ensure no border */
     }
    /* --- End Styles for Tiny Hidden Player --- */

    /* Renamed .music-box to .music-section-box for clarity */
    .music-section-box {
        background-color: var(--card-bg);
        border-radius: var(--border-radius);
        padding: var(--padding, 20px); /* Consistent padding */
        display: flex;
        flex-direction: column;
        color: var(--text-light);
        box-shadow: 0 2px 8px rgba(0,0,0,0.15); /* Softer shadow */
        /* min-height: auto; Removed fixed min-height, let content define it */
    }

    .music-section-box h2 {
        margin-top: 0;
        margin-bottom: 15px; /* Increased space below header */
        color: var(--accent);
        font-size: 1.3em; /* Slightly larger header */
        display: flex; /* For icon alignment */
        align-items: center;
        gap: 8px; /* Space between icon and text */
    }

    .music-section-box p {
        font-size: 0.95em; /* Slightly larger paragraph text */
        color: var(--text-muted);
        margin-bottom: 15px;
        line-height: 1.6; /* Improved line height for readability */
    }
    
    /* Input styling improvements */
    .music-section-box input[type="search"] {
        background: var(--bg-dark); /* Darker background for contrast */
        border: 1px solid var(--sidebar-dark); /* Subtler border */
        color: var(--text-light);
        padding: 0.6rem 0.8rem; /* Adjust padding */
        width: 100%;
        margin-bottom: 15px;
        border-radius: var(--border-radius); /* Consistent border radius */
        font-size: 1rem;
        height: auto; /* Remove fixed height */
    }
    .music-section-box input[type="search"]:focus {
        border-color: var(--accent);
        outline: none;
        box-shadow: 0 0 0 2px var(--accent-transparent, rgba(0, 255, 132, 0.3)); /* Focus ring */
    }


    .scrollable-list {
        flex-grow: 1;
        overflow-y: auto;
        margin-top: 10px;
        padding-right: 8px; /* Slightly more space for scrollbar */
        /* Consider a min-height if sections can become too short */
        /* min-height: 150px; */
    }
    
    /* Custom Scrollbar - keep existing or refine further */
    .scrollable-list::-webkit-scrollbar {
        width: 10px; /* Slightly wider */
    }
    .scrollable-list::-webkit-scrollbar-track {
        background: transparent; /* Cleaner track */
    }
    .scrollable-list::-webkit-scrollbar-thumb {
        background-color: var(--text-muted);
        border-radius: var(--border-radius);
        border: 2px solid var(--card-bg); /* Creates a "floating" thumb look */
    }
    .scrollable-list::-webkit-scrollbar-thumb:hover {
        background-color: var(--accent);
    }

    .list-item {
        padding: 12px 15px; /* Increased padding for better touch targets and visual space */
        border-radius: var(--border-radius); /* Consistent radius */
        cursor: pointer;
        margin-bottom: 8px; /* Increased gap between items */
        background-color: transparent; /* Cleaner default state */
        border: 1px solid transparent; /* Placeholder for hover/focus border */
        transition: background-color var(--transition-speed), border-color var(--transition-speed), color var(--transition-speed);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-size: 1em; /* Larger font size */
        color: var(--text-light);
        position: relative; /* For potential ::before elements or icons */
    }
      
    .list-item .playlist-info i.fa-cog:hover {
        color: var(--accent);
    }


    .list-item:hover,
    .list-item:focus-visible { /* Added :focus-visible for keyboard accessibility */
        background-color: var(--sidebar-dark); /* Or a slightly lighter version of card-bg */
        border-color: var(--accent);
        color: var(--accent);
        outline: none; /* Handled by focus-visible style */
    }

    .list-item.playing {
        background-color: var(--accent);
        color: var(--bg-dark) !important; /* Ensure contrast, important if other styles conflict */
        font-weight: bold;
        border-color: var(--accent);
    }
    .list-item.playing:hover,
    .list-item.playing:focus-visible {
         background-color: var(--accent); /* Keep accent on hover/focus when playing */
         filter: brightness(0.9);
    }

    /* General button styling within music page for consistency */
    .music-section-box button.button-primary,
    .music-section-box button.button-secondary {
        /* Assuming you have global .button-primary, .button-secondary styles.
           If not, define them based on your main 'button' styles but with more distinction.
           Example:
        */
        padding: 10px 15px;
        border: none;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-weight: bold;
        transition: all var(--transition-speed) ease;
        display: inline-flex; /* For icon alignment */
        align-items: center;
        justify-content: center;
        gap: 8px; /* Space between icon and text */
        width: 100%; /* Make buttons full width in their sections */
        box-sizing: border-box;
    }
    .music-section-box button.button-primary {
        background-color: var(--accent);
        color: var(--bg-dark); /* Ensure contrast */
    }
    .music-section-box button.button-primary:hover {
        filter: brightness(1.15);
    }
    .music-section-box button.button-secondary {
        background-color: var(--sidebar-dark);
        color: var(--text-light);
    }
    .music-section-box button.button-secondary:hover {
        background-color: #555; /* Slightly lighter for hover */
    }
    
    
    /* Playback Controls Bar Styles (Adapted) */
    #mp_playback_controls {
        position: fixed;
        bottom: 0;
        left: 0; /* Default for when sidebar is closed */
        width: 100%; /* Default for when sidebar is closed */
        background-color: var(--bg-dark); /* Darker, distinct background */
        padding: 12px 20px; /* Adjusted padding for a sleeker look */
        box-sizing: border-box;
        display: flex; /* This should be set by JS when a song loads */
        align-items: center;
        gap: 15px;
        border-top: 1px solid var(--sidebar-dark); /* Softer border */
        z-index: 100; /* Ensure it's above other page content but below modals */
        color: var(--text-light);
        transition: left var(--transition-speed) ease, width var(--transition-speed) ease, background-color var(--transition-speed) ease; /* Added background-color transition */
        box-shadow: 0 -2px 10px rgba(0,0,0,0.2); /* Subtle shadow at the top of the bar */
    }
    
    /* Add this new rule */
    .sidebar.open ~ #mp_playback_controls {
        left: 60px; /* Push the playback bar by the sidebar width */
        width: calc(100% - 60px); /* Reduce width by the sidebar width */
    }
    
    #mp_playback_controls .song-info {
        flex-basis: 250px; /* Allow more space for song info */
        flex-shrink: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-size: 0.95em; /* Slightly larger */
        font-weight: 500; /* Medium weight */
    }
    
    #mp_playback_controls .controls {
        display: flex;
        align-items: center;
        gap: 8px; /* Slightly reduced gap for a tighter group */
    }
    
    #mp_playback_controls .controls button,
    #mp_playback_controls .volume-container button {
        background: none; /* Keep transparent */
        border: none;
        color: var(--text-muted); /* Muted by default */
        font-size: 1.4em; /* Consistent larger icons */
        padding: 8px; /* Increased padding for better touch/click area */
        border-radius: 50%; /* Make buttons round */
        width: 40px; /* Explicit width */
        height: 40px; /* Explicit height */
        display: flex;
        align-items: center;
        justify-content: center;
        transition: color var(--transition-speed), background-color var(--transition-speed);
    }
      
    #mp_playback_controls .controls button:hover,
    #mp_playback_controls .volume-container button:hover {
        color: var(--accent);
        background-color: rgba(255,255,255,0.05); /* Subtle background on hover */
    }
      
    #mp_playback_controls .controls button:disabled,
    #mp_playback_controls .volume-container button:disabled {
         color: #555; /* Darker muted for disabled */
         cursor: not-allowed;
         opacity: 0.6;
         background-color: transparent;
    }
      
    #mp_playback_controls .controls button#mp_playPauseButton { /* Special styling for play/pause */
        color: var(--accent); /* Make play/pause button always accent color */
        transform: scale(1.1); /* Slightly larger */
    }
    #mp_playback_controls .controls button#mp_playPauseButton:hover {
        filter: brightness(1.2);
    }
    
    
    #mp_playback_controls .seek-bar-container {
        flex-grow: 1;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    #mp_playback_controls input[type="range"] {
        flex-grow: 1;
        cursor: pointer;
        height: 6px; /* Slightly thicker bar */
        background: #444; /* Darker track */
        border-radius: 3px;
        -webkit-appearance: none;
        appearance: none;
        transition: background var(--transition-speed);
    }
    #mp_playback_controls input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px; /* Larger thumb */
        height: 16px;
        background: var(--accent);
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid var(--bg-dark); /* Border to make it pop from the track */
        box-shadow: 0 0 5px rgba(0, 255, 132, 0.5); /* Glow effect for accent */
    }
    #mp_playback_controls input[type="range"]::-moz-range-thumb {
         width: 16px;
         height: 16px;
         background: var(--accent);
         border-radius: 50%;
         cursor: pointer;
         border: 2px solid var(--bg-dark);
         box-shadow: 0 0 5px rgba(0, 255, 132, 0.5);
    }
    
    
    #mp_playback_controls .time-display {
        font-size: 0.9em; /* Slightly larger time */
        color: var(--text-muted);
        min-width: 50px; /* Adjusted width */
        text-align: center;
        font-variant-numeric: tabular-nums; /* Keeps numbers aligned */
    }

    #mp_playback_controls .volume-container {
        display: flex;
        align-items: center;
        gap: 8px; /* Consistent gap */
    }

    #mp_playback_controls .volume-container input[type="range"] {
        width: 100px; /* Slightly longer volume slider */
        height: 6px;
    }
     #mp_playback_controls .volume-container input[type="range"]::-webkit-slider-thumb {
         width: 14px; /* Slightly smaller thumb for volume */
         height: 14px;
         border-width: 1px; /* Thinner border for volume thumb */
     }
      
     #mp_playback_controls .volume-container input[type="range"]::-moz-range-thumb {
          width: 14px;
          height: 14px;
          border-width: 1px;
     }
    
    #mp_playback_controls .volume-percentage {
         font-size: 0.85em;
         color: var(--text-muted);
         min-width: 35px; /* Adjusted width */
         text-align: right;
    }
    
    
    /* Modal Styles (Adapted) */
    .mp-modal { /* Use a specific class for music player modals */
        display: none;
        position: fixed;
        z-index: 150; /* Above most content, maybe below update overlay */
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.6);
        justify-content: center;
        align-items: center;
    }
    
    .mp-modal-content {
        background-color: var(--card-bg); /* Use theme card background */
        margin: auto;
        padding: 20px;
        border: 1px solid var(--sidebar-dark); /* Use theme border */
        width: 90%;
        max-width: 500px;
        border-radius: var(--border-radius);
        position: relative;
        color: var(--text-light);
        display: flex;
        flex-direction: column;
        max-height: 80vh; /* Limit height */
    }
    
    .mp-modal-close {
        color: var(--text-muted);
        position: absolute;
        top: 10px;
        right: 15px;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
    }
    .mp-modal-close:hover,
    .mp-modal-close:focus {
        color: var(--accent); /* Use theme accent */
        text-decoration: none;
    }
    
    .mp-modal-content h3 {
         margin-top: 0;
         color: var(--accent);
    }
    
    .mp-modal-body {
         flex-grow: 1;
         overflow-y: auto;
         margin-bottom: 15px;
    }
    
    
    .mp-modal-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 10px;
        flex-shrink: 0;
    }
    
    /* Styles for lists within modals */
    #mp_removeSongsModalList .list-item,
    #mp_viewPlaylistModalList .list-item,
    #mp_createPlaylistSongList .list-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        background-color: rgba(0,0,0,0.2); /* Slightly different background for modal lists */
    }
    #mp_createPlaylistSongList .list-item {
         cursor: default !important;
         margin-bottom: 2px !important;
    }
    
    
    #mp_removeSongsModalList .list-item label,
    #mp_viewPlaylistModalList .list-item span,
    #mp_createPlaylistSongList .list-item label {
         flex-grow: 1;
         margin-left: 10px;
         overflow: hidden;
         text-overflow: ellipsis;
         white-space: nowrap;
         cursor: pointer;
     }
     #mp_removeSongsModalList input[type="checkbox"],
     #mp_createPlaylistSongList input[type="checkbox"] {
         flex-shrink: 0;
         margin-right: 8px;
          vertical-align: middle;
     }
    
    #mp_viewPlaylistModalList .list-item button {
         background: none;
         border: none;
         color: #ff6b6b;
         cursor: pointer;
         font-size: 0.9em;
         flex-shrink: 0;
         margin-left: 5px;
     }
     #mp_viewPlaylistModalList .list-item button:hover {
         color: #ff4f4f;
     }
    .placeholder-text {
         color: var(--text-muted);
         font-style: italic;
         text-align: center;
         margin-top: 20px;
     }
    /* Highlight style for list items in modals */
    
    /* Optional: Style for checkbox itself */
    #mp_removeSongsModalList input[type="checkbox"],
    #mp_createPlaylistSongList input[type="checkbox"] {
        /* You can add custom checkbox styling here if desired */
        /* For now, we'll rely on the list item highlighting */
        margin-right: 8px; /* Ensure spacing */
        vertical-align: middle;
    }
    
    /* Style for modal search inputs */
    /* Re-use existing styles for inputs within music-section-box if they are general enough */
    /* Or add specific styles if needed */
    .mp-modal-body input[type="search"] {
        background: var(--bg-dark); /* Darker background for contrast */
        border: 1px solid var(--sidebar-dark); /* Subtler border */
        color: var(--text-light);
        padding: 0.6rem 0.8rem; /* Adjust padding */
        width: 100%;
        margin-bottom: 15px; /* Space below the search bar */
        border-radius: var(--border-radius); /* Consistent border radius */
        font-size: 1rem;
        height: auto; /* Remove fixed height */
        box-sizing: border-box; /* Include padding and border in element's total width */
    }
    .mp-modal-body input[type="search"]:focus {
        border-color: var(--accent);
        outline: none;
        box-shadow: 0 0 0 2px var(--accent-transparent, rgba(0, 255, 132, 0.3)); /* Focus ring */
    }

    /* Container for the music icon and its hover overlay */
    /* Positioned relative to the sidebar, so its absolute child can be placed */
    #musicIconAndHoverContainer {
        position: relative; /* Needed for absolute positioning of the overlay */
        /* You might need to add specific positioning here if you want the overlay
           to appear differently when the sidebar is open/closed. For simplicity,
           we'll position the overlay relative to the icon's fixed spot. */
    }
      
    /* Style for list items selected for an action in modals */
    #mp_removeSongsModalList .list-item.selected-for-action,
    #mp_createPlaylistSongList .list-item.selected-for-action {
        background-color: var(--accent); /* Use the accent color */
        color: var(--bg-dark) !important; /* Ensure text color contrasts with accent */
        font-weight: bold; /* Make text bold */
        border-color: var(--accent); /* Accent border */
    }
    
    /* Optional: Hover effect for selected items */
    #mp_removeSongsModalList .list-item.selected-for-action:hover,
    #mp_createPlaylistSongList .list-item.selected-for-action:hover {
         background-color: var(--accent); /* Keep accent on hover when selected */
         filter: brightness(0.9); /* Slightly darken on hover */
    }
    
    /* Ensure default list-item hover doesn't override selected style */
    #mp_removeSongsModalList .list-item:hover,
    #mp_createPlaylistSongList .list-item:hover {
        background-color: var(--sidebar-dark); /* Keep the default hover background */
        border-color: var(--accent);
        color: var(--accent);
    }
    
    /* Remove padding/margins added specifically for checkboxes if any */
    #mp_removeSongsModalList .list-item span,
    #mp_createPlaylistSongList .list-item span {
        /* Adjust padding if needed after removing checkboxes */
        padding-left: 0;
    }
    
    
    /* Style for the hover overlay box */
    #audioControlHoverOverlay {
        display: none; /* Hidden by default */
        position: absolute; /* Position relative to #musicIconAndHoverContainer */
    
        /* Adjust position relative to the sidebar icon's location */
        /* Example: To appear to the right of the icon when sidebar is closed */
        top: 0; /* Align top with the icon */
        left: calc(60px + 10px); /* Sidebar width (60px) + a little gap (10px) */
        /* Example: To appear just below the icon when sidebar is open (more complex CSS or JS might be needed) */
        /* top: 60px; left: 50%; transform: translateX(-50%); width: 200px; */
    
    
        width: 220px; /* Compressed box width */
        background-color: var(--card-bg); /* Use theme card background */
        border: 1px solid var(--accent); /* Use theme accent border */
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        padding: 10px;
        border-radius: var(--border-radius);
        z-index: 100; /* Ensure it's above most content, below modals */
        color: var(--text-light); /* Use theme text color */
    
        /* Basic layout using Flexbox */
        flex-direction: column;
        gap: 8px; /* Space between sections */
    }
    
    /* Style for the song title in the overlay */
    .overlay-song-title {
        font-size: 0.9em;
        font-weight: bold;
        white-space: nowrap; /* Prevent wrapping */
        overflow: hidden; /* Hide overflow text */
        text-overflow: ellipsis; /* Show ellipsis for overflow */
        text-align: center;
    }
    
    /* Style for the "Next song:" label in the overlay */
    .overlay-label {
        font-size: 0.8em;
        color: var(--text-muted); /* Use theme muted text */
        text-align: center;
    }
    
    /* Container for control buttons in the overlay */
    .overlay-controls {
        display: flex;
        justify-content: center; /* Center buttons horizontally */
        gap: 10px; /* Space between buttons */
    }
    
    /* Style for control buttons in the overlay */
    .overlay-controls button {
        background: none;
        border: none;
        font-size: 1.5em;
        cursor: pointer;
        padding: 0 5px; /* Add some padding */
        color: var(--text-light); /* Use theme text color */
        transition: color 0.2s;
    }
    
    .overlay-controls button:hover {
        color: var(--accent); /* Use theme accent on hover */
    }
    .overlay-controls button:disabled {
         color: var(--text-muted); /* Muted color for disabled buttons */
         cursor: not-allowed;
         opacity: 0.5;
    }
    
    
    /* Container for time and scroller in the overlay */
    .overlay-time-scroller {
        display: flex;
        align-items: center; /* Vertically align items */
        gap: 5px;
    }
    
    /* Style for the scroller (range input) in the overlay */
    .overlay-time-scroller input[type="range"] {
        flex-grow: 1; /* Allow scroller to fill available space */
         cursor: pointer;
         height: 5px;
         background: #555; /* Static grey background for the track */
         border-radius: 3px;
         -webkit-appearance: none; /* Hide default styling */
         appearance: none;
         /* You might need specific styles for the thumb based on browser */
    }
    /* Styles for the scroller thumb */
    .overlay-time-scroller input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 14px;
        height: 14px;
        background: var(--accent); /* Use theme accent for thumb */
        border-radius: 50%;
        cursor: pointer;
    }
    .overlay-time-scroller input[type="range"]::-moz-range-thumb {
         width: 14px;
         height: 14px;
         background: var(--accent);
         border-radius: 50%;
         cursor: pointer;
         border: none; /* Remove default Firefox border */
    }
    
    
    /* Style for time spans in the overlay */
    .overlay-time {
        font-size: 0.8em;
        color: var(--text-muted); /* Use theme muted text */
        min-width: 35px; /* Give time spans a minimum width to prevent layout shifts */
        text-align: center;
        font-variant-numeric: tabular-nums; /* Helps keep numbers aligned */
    }
      
    /* Style for the small album art image in the playlist list */
    .playlist-info img {
        width: 30px; /* Small fixed width */
        height: 30px; /* Small fixed height */
        object-fit: cover; /* Ensure the image covers the area without distortion */
        margin-right: 10px; /* Space between image and text/icon */
        border-radius: var(--border-radius); /* Optional: match border radius */
        flex-shrink: 0; /* Prevent image from shrinking */
    }
/* --- New Styles for Playlist Grid Layout --- */

    /* Modify the container for playlists to be a grid */
    #playlists-list-box .scrollable-list { /* Target the scrollable list div inside the playlists box */
        display: grid; /* Use CSS Grid */
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); /* Responsive grid: min item width 150px, auto-fill container */
        gap: 15px; /* Gap between grid items */
        padding-right: 0; /* Remove padding needed for scrollbar when it was a simple list */
        overflow-y: auto; /* Keep scrolling for the grid */
        /* Inherits max-height/min-height from general .scrollable-list style */
    }
    
    /* Style for each individual playlist "card" (was .list-item) */
    /* Target list items specifically in the playlists box */
    #playlists-list-box .list-item {
        display: flex; /* Use flexbox for content within the item */
        flex-direction: column; /* Stack content vertically within the card (image above info) */
        background-color: var(--card-bg); /* Use card background variable for the card */
        border-radius: var(--border-radius); /* Apply rounded corners to the card */
        overflow: hidden; /* Hide anything outside the card's rounded corners */
        text-align: center; /* Center text and images within the card */
        cursor: pointer; /* Indicate the card is clickable */
        transition: transform 0.2s ease, box-shadow 0.2s ease; /* Add smooth transition for hover effects */
        padding: 0; /* Remove padding here, padding is added to the info area */
        border: 1px solid transparent; /* Add a subtle border for hover/focus highlight */
         margin-bottom: 0; /* Remove margin-bottom as grid gap handles spacing */
         min-height: 180px; /* Minimum height for each card (adjust as needed) */
    }
    
    #playlists-list-box .list-item:hover,
    #playlists-list-box .list-item:focus-visible {
        transform: translateY(-5px); /* Lift slightly on hover */
        box-shadow: 0 5px 15px rgba(0,0,0,0.3); /* Add shadow on hover */
        border-color: var(--accent); /* Highlight border on hover */
        outline: none; /* Remove default outline for focus-visible */
    }
    
    
    /* Container for the album art image */
    .playlist-card-image-area {
        width: 100%; /* Make the image area fill the width of the card */
        height: 100px; /* Fixed height for the image area, creating a rectangular box */
        overflow: hidden; /* Hide content that exceeds this area */
        display: flex; /* Use flex to center the image/icon inside */
        align-items: center;
        justify-content: center;
        background-color: var(--bg-dark); /* Darker background for the image area */
    }
    
    .playlist-card-image-area img {
        display: block; /* Remove potential extra space below image */
        width: 100%; /* Make image fill the width of its container */
        height: 100%; /* Make image fill the height of its container */
        object-fit: cover; /* Ensures the image covers the box area without distortion */
    }
    
    /* Style for placeholder icon in the image area (if no album art) */
    .playlist-card-image-area i.placeholder-icon {
        font-size: 3em; /* Larger icon size */
        color: var(--text-muted); /* Muted color for the placeholder */
    }
    
    /* Container for the text (name and count) and controls */
    .playlist-card-info {
        display: flex; /* Use flex for horizontal arrangement of text and settings icon */
        align-items: center; /* Aligns icon and text span vertically in the center */
        gap: 8px; /* Space between the text and the icon */
        /* ADJUSTED: Increased top padding to move text and icon down */
        padding: 15px 10px 10px 10px; /* Add padding inside the info area */
        flex-grow: 1; /* Allows this area to take the remaining vertical space in the card */
        width: 100%; /* Ensure it takes full width of the card */
        box-sizing: border-box; /* Include padding in the element's total width */
         /* Optional: justify-content: space-between; if you want the text left and icon right */
    }
    
    /* Style for the playlist name and song count text span */
    .playlist-card-info span {
        flex-grow: 1; /* Allows the text span to take up available horizontal space */
        overflow: hidden; /* Hides overflowing text */
        text-overflow: ellipsis; /* Shows ellipsis (...) for overflowing text */
        white-space: nowrap; /* Prevents text from wrapping */
        text-align: left; /* Aligns text to the left within its span */
        font-size: 0.9em; /* Adjust font size */
        font-weight: bold;
        color: var(--text-light); /* Ensure text is visible using theme variable */
    }
    
    /* Style for the settings icon in the card */
    .playlist-card-info .fa-cog {
        cursor: pointer; /* Keep the cursor pointer for the icon */
        color: var(--text-muted); /* Use theme muted color for the icon */
        transition: color 0.2s; /* Smooth color transition on hover */
        flex-shrink: 0; /* Prevent the icon from shrinking */
        font-size: 1em; /* Adjust icon size */
    }
    
    /* Ensure settings icon color changes on hover */
    .playlist-card-info .fa-cog:hover {
        color: var(--accent); /* Use theme accent color on hover */
    }
    
    /* When the card is hovered, make the text accent color */
    #playlists-list-box .list-item:hover .playlist-card-info span {
        color: var(--accent); /* Use theme accent color for text on card hover */
    }
    
    /* Specific style for the centered placeholder text in the grid when empty */
    #playlists-list-box .scrollable-list .placeholder-text {
        grid-column: 1 / -1; /* Make the placeholder span across all grid columns */
        color: var(--text-muted); /* Added from your general .placeholder-text style */
        font-style: italic; /* Added from your general .placeholder-text style */
        text-align: center; /* Added from your general .placeholder-text style */
        margin-top: 20px; /* Added from your general .placeholder-text style */
    }

        
        /* Style for a placeholder icon if no album art */
        .playlist-info i.placeholder-icon {
            font-size: 1.5em; /* Size similar to the image */
            margin-right: 10px; /* Space between icon and text/icon */
            color: var(--text-muted); /* Muted color for placeholder */
            flex-shrink: 0; /* Prevent icon from shrinking */
            width: 30px; /* Give it a fixed width for alignment */
            text-align: center; /* Center the icon */
        }
    /* --- New Styles for Playlist Grid Layout --- */
    
    /* This rule defines the scrollable container for the playlist grid */
    #playlists-list-box .scrollable-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); /* Responsive grid */
        gap: 15px; /* Gap between playlist cards */
        padding-right: 0; /* Remove padding if scrollbar is overlayed or styled */
        overflow-y: auto; /* Enable vertical scrolling */
        /* NEW/ADJUSTED: Set min and max height for the scrollable area */
        min-height: 180px; /* Ensure at least one card's height is accommodated */
        max-height: 375px; /* Roughly allows two rows of 180px cards (180*2 + 15 gap) before scrolling */
    }
    
    /* Style for each individual playlist "card" */
    #playlists-list-box .list-item {
        display: flex;
        flex-direction: column;
        background-color: var(--card-bg);
        border-radius: var(--border-radius);
        overflow: hidden;
        text-align: center;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        padding: 0; /* Padding is handled by inner elements */
        border: 1px solid transparent;
        margin-bottom: 0; /* Gap handles spacing */
        min-height: 180px; /* Minimum height for each card */
    }
    
    #playlists-list-box .list-item:hover,
    #playlists-list-box .list-item:focus-visible {
        transform: translateY(-5px); /* Lift the card slightly on hover */
        box-shadow: 0 5px 15px rgba(0,0,0,0.3); /* Add a shadow on hover */
        border-color: var(--accent); /* Highlight the border with the accent color */
        outline: none; /* Remove default outline for better focus-visible styling */
    }
    
    .playlist-card-image-area {
        width: 100%; /* Make the image area fill the width of the card */
        /* CHANGE: Remove fixed height and add aspect-ratio to make it square based on width */
        height: auto;
        aspect-ratio: 1 / 1; /* Makes the height equal to the width */
        overflow: hidden; /* Hide content that exceeds this area */
        display: flex; /* Use flex to center the image/icon inside */
        align-items: center;
        justify-content: center;
        background-color: var(--bg-dark); /* Darker background for the image area */
    }
    
    .playlist-card-image-area img {
        display: block;
        width: 100%;
        height: 100%;
        object-fit: cover; /* Ensures the image covers the box area */
    }
    
    .playlist-card-image-area i.placeholder-icon {
        font-size: 3em;
        color: var(--text-muted);
    }
    
    .playlist-card-info {
        display: flex; /* Use flex for horizontal arrangement of text and settings icon */
        align-items: center; /* Vertically aligns text and icon in the center */
        gap: 8px; /* Space between the text and the icon */
        /* Keep padding for internal spacing */
        padding: 15px 10px 10px 10px; /* Add padding inside the info area */
        flex-grow: 1; /* Allows this area to take the remaining vertical space in the card */
        width: 100%; /* Ensure it takes full width of the card */
        box-sizing: border-box; /* Include padding in the element's total width */
        /* NEW: Push this element to the bottom of the flex container (.list-item) */
        margin-top: auto;
    }
    
    .playlist-card-info span {
        flex-grow: 1; /* Allows the text span to take up available horizontal space */
        overflow: hidden; /* Hides overflowing text */
        text-overflow: ellipsis; /* Shows ellipsis (...) for overflowing text */
        white-space: nowrap; /* Prevents text from wrapping */
        text-align: left; /* Aligns text to the left within its span */
        font-size: 0.9em; /* Adjust font size */
        font-weight: bold;
        color: var(--text-light); /* Ensure text is visible using theme variable */
    }   
    
    .playlist-card-info .fa-cog {
        cursor: pointer;
        color: var(--text-muted);
        transition: color 0.2s;
        flex-shrink: 0;
        font-size: 1em;
    }
    
    .playlist-card-info .fa-cog:hover {
        color: var(--accent);
    }
    
    #playlists-list-box .list-item:hover .playlist-card-info span {
        color: var(--accent);
    }
    
    /* Specific style for the centered placeholder text in the grid when empty *



  </style>
</head>
<body class="theme-default"> <div class="tooltip" id="tooltip"></div>

  <div class="modal" id="addGameModal">
    <div class="modal-content">
      <button class="modal-close" onclick="closeModal()">&times;</button>
      <h2>Add New Game</h2>
      <input type="text" id="gameName" placeholder="Game Name" required>
      <input type="text" id="gameUrl" placeholder="Game URL" required>
      <input type="text" id="gameIcon" placeholder="Icon URL (optional)">
      <div class="modal-buttons">
        <button onclick="closeModal()">Cancel</button>
        <button onclick="addGame()">Add Game</button>
      </div>
    </div>
  </div>
    
    <div class="update-overlay" id="updateOverlay">
        <div class="update-message-box">
            <h2 id="updateTitle">New Update Available!</h2>
            <p id="updateMessage">A new version (vX.Y.Z) is available.</p> <div class="update-options-container">
                <div class="update-option">
                    <button id="reloadSiteButton">Reload Site</button>
                    <p>if you are on the website</p>
                </div>
                <div class="update-option">
                     <button id="downloadOfflineButton">Download Offline Version</button>
                     <p>if you are on a local version</p>
                </div>
            </div>
    
             <button id="updateCloseButton" style="margin-top: 1.5rem; background-color: #555; color: white;">Dismiss</button>
        </div>
    </div>

  <div class="modal" id="changelogModal">
    <div class="modal-content" style="max-width: 900px; max-height: 80vh;">
      <button class="modal-close" onclick="closeChangelogModal()">&times;</button>
      <h2>Changelog</h2>
      <pre id="changelogContent" style="white-space: pre-wrap; font-family: inherit;"></pre>
    </div>
  </div>
    
    <div id="mp_youtubeSearchModal" class="mp-modal">
        <div class="mp-modal-content" style="max-width: 600px;">
            <span class="mp-modal-close" onclick="mp_closeModal('mp_youtubeSearchModal')"></span>
            <h3>Search Music on YouTube</h3>
            <div class="mp-modal-body">
                <div id="mp_Youtube-container" style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <input type="text" id="mp_Youtube-input" placeholder="Search for a video or song..." aria-label="Search YouTube">
                    <button id="mp_Youtube-button">Search</button>
                </div>
                <div class="scrollable-list" id="mp_youtube-results-list" style="max-height: 300px;">
                    <p class="placeholder-text">Search results will appear here.</p>
                </div>
            </div>
            <div class="mp-modal-buttons" style="justify-content: flex-end;">
                 <button class="secondary" onclick="mp_closeModal('mp_youtubeSearchModal')">Close</button>
                 </div>
        </div>
    </div>
    <div id="mp_youtube_hidden_player" style="position: fixed; bottom: 0; right: 0; width: 1px; height: 1px; z-index: -1; overflow: hidden;"></div>
    <script src="https://www.youtube.com/iframe_api"></script>

<div id="notificationContainer">
    </div>
    
  <div class="sidebar">
    <div class="icon active" data-page="Home" title="Home"><i class="fas fa-home"></i></div>
    <div class="icon" data-page="Library" title="Library"><i class="fas fa-book"></i></div>
    <div class="icon" data-page="Viewer" title="Viewer"><i class="fas fa-globe"></i></div>
    <div class="icon" data-page="Games" title="Games"><i class="fas fa-gamepad"></i></div>
      
    <div id="musicIconAndHoverContainer" style="position: relative; z-index: 11;"> <div class="icon" data-page="Music" title="Music">
            <i class="fas fa-music"></i>
        </div>
    
        <div id="audioControlHoverOverlay" class="audio-hover-overlay">
            <div id="hoverOverlaySongTitle" class="overlay-song-title">No song playing</div>
            <div class="overlay-label">Next song:</div>
            <div id="hoverOverlayControls" class="overlay-controls">
                <button id="hoverOverlayBackwardBtn" title="Previous"><i class="fas fa-step-backward"></i></button>
                <button id="hoverOverlayPlayPauseBtn" title="Play/Pause"><i class="fas fa-play"></i></button>
                <button id="hoverOverlayForwardBtn" title="Next"><i class="fas fa-step-forward"></i></button>
            </div>
            <div id="hoverOverlayTimeScroller" class="overlay-time-scroller">
                <span id="hoverOverlayCurrentTime" class="overlay-time">0:00</span>
                <input type="range" id="hoverOverlayScroller" min="0" value="0" step="0.1">
                <span id="hoverOverlayTotalDuration" class="overlay-time">0:00</span>
            </div>
        </div>
    </div>
    <div class="icon" data-page="Updater" title="Updater"><i class="fas fa-sync-alt"></i></div>

    <div class="bottom-icons">
      <div class="icon" data-page="Settings" title="Settings"><i class="fas fa-cog"></i></div>
      <div class="icon" data-page="About" title="About"><i class="fas fa-info-circle"></i></div>
    </div>
  </div>
    
<audio id="mp_audioPlayer"></audio>

<div class="playback-controls" id="mp_playback_controls" style="display: none;"> <div class="song-info" id="mp_currentSongInfo">No Song Playing</div>
    <div class="controls">
        <button id="mp_prevButton" title="Previous"><i class="fas fa-step-backward"></i></button>
        <button id="mp_playPauseButton" title="Play"><i class="fas fa-play"></i></button>
        <button id="mp_nextButton" title="Next"><i class="fas fa-step-forward"></i></button>
    </div>
    <div class="seek-bar-container">
        <span class="time-display" id="mp_currentTime">0:00</span>
        <input type="range" id="mp_seekBar" value="0" step="0.1" max="100">
        <span class="time-display" id="mp_totalDuration">0:00</span>
    </div>
    <div class="volume-container">
        <button id="mp_muteButton" title="Mute"><i class="fas fa-volume-up"></i></button>
        <input type="range" id="mp_volumeSlider" min="0" max="1" step="0.01" value="1">
        <span class="volume-percentage" id="mp_volumePercentage">100%</span>
    </div>
</div>

<div id="mp_removeSongsModal" class="mp-modal">
    <div class="mp-modal-content">
        <span class="mp-modal-close" onclick="mp_closeModal('mp_removeSongsModal')">&times;</span>
        <h3>Remove Songs</h3>
        <div class="mp-modal-body">
            <p>Select songs to remove permanently from the library.</p>
            <input type="search" id="mp_removeSongsSearch" placeholder="Search songs to remove" aria-label="Search songs to remove">
            <div class="scrollable-list" id="mp_removeSongsModalList" style="max-height: 300px;">
                </div>
        </div>
        <div class="mp-modal-buttons">
             <button class="secondary" onclick="mp_closeModal('mp_removeSongsModal')">Cancel</button>
             <button onclick="mp_removeSelectedSongs()">Remove Selected</button>
        </div>
    </div>
</div>

<div id="mp_createPlaylistModal" class="mp-modal">
    <div class="mp-modal-content">
         <span class="mp-modal-close" onclick="mp_closeModal('mp_createPlaylistModal')">&times;</span>
         <h3>Create New Playlist</h3>
         <div class="mp-modal-body">
              <input type="text" id="mp_newPlaylistName" placeholder="Playlist Name">
              <h4>Add Songs (Optional):</h4>
              <input type="search" id="mp_createPlaylistSearch" placeholder="Search songs to add" aria-label="Search songs to add to playlist">
                <div class="scrollable-list" id="mp_createPlaylistSongList" style="max-height: 200px; padding: 5px;">
                 <p class="placeholder-text">Loading library...</p>
              </div>
         </div>
         <div class="mp-modal-buttons">
             <button class="secondary" onclick="mp_closeModal('mp_createPlaylistModal')">Cancel</button>
             <button onclick="mp_createNewPlaylist()">Create</button>
         </div>
     </div>
 </div>

 <div id="mp_viewPlaylistModal" class="mp-modal"> <div class="mp-modal-content">
         <span class="mp-modal-close" onclick="mp_closeModal('mp_viewPlaylistModal')">&times;</span>
         <h3 id="mp_viewPlaylistName">Playlist</h3>
         <div class="mp-modal-body">
              <div class="scrollable-list" id="mp_viewPlaylistModalList" style="max-height: 300px;">
                  </div>
         </div>
          <div class="mp-modal-buttons">
              <button class="secondary" onclick="mp_closeModal('mp_viewPlaylistModal')">Close</button>
              <button onclick="mp_deleteCurrentPlaylist()">Delete Playlist</button>
         </div>
     </div>
 </div>

  <div class="content">
    <h1 id="page-title" style="display: none;">UnderGr0und</h1>
    <div id="page-content" class="panel-container">
      </div>
  </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.fog.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsmediatags@3.9.7/dist/jsmediatags.min.js"></script>


<script>
    // DOM Elements
    const icons = document.querySelectorAll('.sidebar .icon');
    const pageTitle = document.getElementById('page-title');
    const pageContent = document.getElementById('page-content');
    const tooltip = document.getElementById('tooltip');
    const addGameModal = document.getElementById('addGameModal');
    const changelogModal = document.getElementById('changelogModal'); // Get changelog modal
    const API_KEY = 'AIzaSyAaK9yxxs1I_mtKqanp5r7YdEjCkXXbI-8';
    

    // App State
    let games = [];
    let library = [];
    let draggedItem = null;
    let draggedIndex = null;
    let favoriteGames = [];
    let isSidebarOpen = false;
    let vantaEffect = null;
    let showingFavorites = false;
    let shownNotificationContentSet = new Set();
    let activeNotifications = {};
    let notificationEnabled = true;
    let notificationDisplayDuration = 8000;
    let currentThemeName = 'default';

    // --- Music Hover Overlay Element References ---
    let musicIconAndHoverContainer = null;
    let audioControlHoverOverlay = null;
    let hoverOverlaySongTitle = null;
    // let hoverOverlayNextSongLabel = null; // This is a static label, no JS ref needed unless you want to change its text
    let hoverOverlayBackwardBtn = null;
    let hoverOverlayPlayPauseBtn = null;
    let hoverOverlayForwardBtn = null;
    let hoverOverlayCurrentTime = null;
    let hoverOverlayScroller = null;
    let hoverOverlayTotalDuration = null;
    let mp_musicQueue = [];
    
    // Flag to know if the hover overlay elements and listeners are initialized
    let mp_hoverOverlayInitialized = false;
    if (API_KEY === 'YOUR_YOUTUBE_API_KEY' || !API_KEY || API_KEY.includes(' ')) {
        console.error('WARNING: Please replace "YOUR_YOUTUBE_API_KEY" in the script with your actual API key.');
        // You might want to show an alert or error message to the user here on critical pages
    }

    let mp_youtubePlayer = null; // Variable to hold the hidden YouTube player instance
    let youtubeTimeUpdateInterval = null; // Interval for YouTube time update simulation
    // let isSeekingHover = false; // Declare this globally if not already accessible for the hover overlay scroller

    // --- YouTube API Readiness Handling ---
    let youtubeApiReady = false;
    let youtubeApiQueue = []; // Queue of functions to run once the API is ready
    
    // This function queues up actions until the YouTube API is loaded and ready
    function runWhenYouTubeApiReady(func) {
        if (youtubeApiReady) {
            // If API is already ready, execute the function immediately
            func();
        } else {
            // If API is not ready, add the function to the queue
            youtubeApiQueue.push(func);
        }
    }
    
    // This function is called by the YouTube Iframe Player API when it's loaded.
    // It must be a global function.
    function onYouTubeIframeAPIReady() {
         youtubeApiReady = true;
         console.log('MP YouTube Player: YouTube Iframe API is ready.');
         // Process any functions that were queued while the API was loading
         while (youtubeApiQueue.length > 0) {
             const func = youtubeApiQueue.shift(); // Get the oldest function from the queue
             func(); // Execute the function
         }
     }
    
    // Ensure the API callback is in the global scope
    // (This might already be handled implicitly by defining the function directly in a <script> tag,
    // but explicitly assigning to window confirms it).
    window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady;
    
    // --- End YouTube API Readiness Handling ---
    
    // ... rest of your music player code, including mp_loadSong ...


    // Define themes array (keep your existing themes array here)
    const themes = [
      {
        name: 'default',
        previewClass: 'theme-default-preview', // Keep existing preview class for visual swatch
        variables: {
          '--bg-dark': '#1c1c1e',
          '--sidebar-dark': '#2c2c2e',
          '--text-light': '#fff',
          '--text-muted': '#aaa',
          '--card-bg': '#1a1a1a',
          '--accent': '#00ff84',
        }
      },
      {
          name: 'cyberpunk',
           previewClass: 'theme-cyberpunk-preview',
          variables: {
            '--bg-dark': '#0f0f1a',
            '--sidebar-dark': '#1a1a2e',
            '--text-light': '#e6e6ff',
            '--text-muted': '#b3b3ff',
            '--card-bg': '#1a1a2e',
            '--accent': '#ff00ff',
          }
        },
         {
          name: 'sunset', // <--- Sunset theme is now kept
          previewClass: 'theme-sunset-preview',
          variables: {
            '--bg-dark': '#2c1a1a',
            '--sidebar-dark': '#4a2c2c',
            '--text-light': '#fff0e0',
            '--text-muted': '#e0b0a0',
            '--card-bg': '#3a2222',
            '--accent': '#ff8844',
          }
        },
         {
           name: 'forest-night',
           previewClass: 'theme-forest-night-preview',
           variables: {
             '--bg-dark': '#0d1a0b',
             '--sidebar-dark': '#1a2e17',
             '--text-light': '#e0f2f1',
             '--text-muted': '#a7ffeb',
             '--card-bg': '#132611',
             '--accent': '#11661f',
           }
         },
         {
            name: 'midnight-sky',
            previewClass: 'theme-midnight-sky-preview',
            variables: {
                '--bg-dark': '#1a1c2e',
                '--sidebar-dark': '#2b2e4a',
                '--text-light': '#e0e0ff',
                '--text-muted': '#a0a0c0',
                '--card-bg': '#20233d',
                '--accent': '#7b68ee',
            }
         },
         // --- New Themes (Plum removed) ---
        {
           name: 'volcano',
           previewClass: 'theme-volcano-preview',
           variables: {
               '--bg-dark': '#3a0d0d',
               '--sidebar-dark': '#5f1c1c',
               '--text-light': '#fff0e0',
               '--text-muted': '#e0b0a0',
               '--card-bg': '#4a1414',
               '--accent': '#ff4500',
           }
        },
        {
           name: 'arctic',
           previewClass: 'theme-arctic-preview',
           variables: {
               '--bg-dark': '#0a1a1c',
               '--sidebar-dark': '#1c3a3d',
               '--text-light': '#e0ffff',
               '--text-muted': '#a0e0e0',
               '--card-bg': '#152a2c',
               '--accent': '#00ffff',
           }
        },
         {
            name: 'grayscale',
            previewClass: 'theme-grayscale-preview',
            variables: {
                '--bg-dark': '#1c1c1c',
                '--sidebar-dark': '#2c2c2c',
                '--text-light': '#ffffff',
                '--text-muted': '#cccccc',
                '--card-bg': '#202020',
                '--accent': '#808080',
            }
         },
         {
            name: 'sunny',
            previewClass: 'theme-sunny-preview',
            variables: {
                '--bg-dark': '#4a3a1a',
                '--sidebar-dark': '#6a4a1a',
                '--text-light': '#fffacd',
                '--text-muted': '#f0d8a0',
                '--card-bg': '#5a4a1a',
                '--accent': '#ffcc00',
            }
         },
        {
            name: 'marine', // <--- New Marine theme
            previewClass: 'theme-marine-preview',
            variables: {
                '--bg-dark': '#0f2a3a',      // Dark blue-green
                '--sidebar-dark': '#1a3c4a', // Darker blue-green
                '--text-light': '#e0f0ff',   // Pale blue
                '--text-muted': '#a0c0d0',   // Muted blue-gray
                '--card-bg': '#15303a',      // Dark blue-green for cards
                '--accent': '#00bfff',       // Deep sky blue
            }
         },
        {
            name: 'swamp',
            previewClass: 'theme-swamp-preview',
            variables: {
                '--bg-dark': '#2b2b1c',      // Dark greenish-brown
                '--sidebar-dark': '#3a3a2a', // Slightly lighter greenish-brown
                '--text-light': '#e0e6d8',   // Pale green-gray
                '--text-muted': '#a0b390',   // Muted green-brown
                '--card-bg': '#303020',      // Darker greenish-brown for cards
                '--accent': '#8a9a5b',       // Dull green
            }
         },
        {
            name: 'inverted-bw',
            previewClass: 'theme-inverted-bw-preview',
            variables: {
                '--bg-dark': '#e3e3e3', // Very light grey background
                '--sidebar-dark': '#d3d3d3', // Slightly darker light grey sidebar
                '--text-light': '#000000', // Black text
                '--text-muted': '#333333', // Dark grey muted text
                '--card-bg': '#dddddd', // Light grey card background
                '--accent': '#404040', // Dark grey accent
            }
        },
        {
            name: 'mint-chocolate',
            previewClass: 'theme-mint-chocolate-preview',
            variables: {
                '--bg-dark': '#1c0903',
                '--sidebar-dark': '#1c0903',
                '--text-light': '#fff',
                '--text-muted': '#ccc',
                '--card-bg': '#1c0903',
                '--accent': '#19d866',
            }
        }
    ];

        const defaultGames = [
             { name: "Agar.io", url: "https://fluxaga.glitch.me", icon: "https://static.wikia.nocookie.net/yogscast/images/1/19/Agar.io_appstore_logo.png", proxiedUrl: "https://flux.englishd.workers.dev/", proxied: false },
             { name: "Slither.io", url: "https://slither.io", icon: "https://pbs.twimg.com/profile_images/1854966120509267968/gUTLTAMd_400x400.jpg", proxiedUrl: "place", proxied: false }, // Placeholder for proxiedUrl
             { name: "n-gon", url: "https://landgreen.github.io/n-gon/", icon: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSIiXBQof9-UTot6CA0A-X9Ntyp0pNALernmg&s", proxiedUrl: "https://skibidi.global.fastly.net/uv/service/hvtrs8%2F-lcnfgpegn%2Cgktju%60.ko-n%2Fgmn-", proxied: false },
             { name: "FreeRiderHD", url: "https://freeriderhd.com", icon: "https://cdn.freeriderhd.com/free_rider_hd/sprites/youtube_poster_art.png", proxiedUrl: "https://skibidi.global.fastly.net/uv/service/hvtrs8%2F-wuw%2Cfpegrkdgrjd%2Ccmm-", proxied: false },
             { name: "Shell Shockers", url: "https://shellshock.io/", icon: "https://rocketgames.imgix.net/uploads/games/s/shell-shockers/shell-shockers.jpg", proxiedUrl: "none", proxied: false },
             { name: "Happy Wheels", url: "https://totaljerkface.com/happy_wheels.tjf", icon: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR8ZZNe14xfg_CvlBFQRnl2Boj4GIEuiyVqYw&s", proxiedUrl: "https://nyx-2b7o.onrender.com/active/go/hvtrs8%2F-tmtclhepkdaae%2Ccmm-hcpry%5Dwjeglq.vjd", proxied: false }
        ];

    // --- START OF MUSIC PLAYER JAVASCRIPT ---
    // Prefix functions and IDs with 'mp_' to avoid conflicts

    // --- Music Player State ---
    let mp_musicLibrary = []; // Array of song objects { id, artist, title, fileName, fileSize }
    let mp_recentlyPlayed = []; // Array of song IDs
    let mp_playlists = {}; // Object: { "Playlist Name": [songId1, songId2] }
    let mp_currentSong = null; // The song object currently loaded/playing (includes tempUrl)
    let mp_currentSongIndex = -1; // Index in the currently playing list
    let mp_isPlaying = false;
    let mp_currentQueue = []; // Holds the IDs of songs being played
    let mp_currentPlaylistNameForView = null; // To know which playlist is open in the modal
    let mp_currentDirectoryHandle = null; // Holds the File System Access API handle
    const MP_MAX_RECENTLY_PLAYED = 20;
    let mp_isInitialized = false; // Flag to check if player UI is set up
    let mp_playbackBarInitialized = false; // Flag for playback bar listeners

    // --- Music Player DOM Element References (Filled later) ---
    let mp_fileInput = null;
    let mp_songsList = null;
    let mp_recentlyPlayedList = null;
    let mp_playlistsList = null;
    let mp_songSearch = null;
    const mp_audioPlayer = document.getElementById('mp_audioPlayer');
    const mp_playbackControlsBar = document.getElementById('mp_playback_controls');
    let mp_playPauseButton = null;
    let mp_prevButton = null;
    let mp_nextButton = null;
    let mp_seekBar = null;
    let mp_currentTime = null;
    let mp_totalDuration = null;
    let mp_currentSongInfo = null;
    let mp_volumeSlider = null;
    let mp_muteButton = null;
    let mp_volumePercentage = null;


    // --- START IndexedDB Helper Functions ---
    const MP_KEY_DIR_HANDLE = 'songs'; // Key for the directory handle
    const MP_DB_NAME = 'musicPlayerDB';
    const MP_DB_VERSION = 2; // Make sure this version number is correct based on your upgrade history
    const MP_HANDLE_STORE_NAME = 'fileHandles'; // Object store name for the directory handle
    const MP_SONG_STORE_NAME = 'songs';

// Global variable for the database connection
    let mp_db = null;

    // Opens or creates the IndexedDB database
    function mp_dbOpen() {
        console.log("MP_DB: Opening database...");
        return new Promise((resolve, reject) => {
            if (mp_db) { // If connection already open, resolve it
                console.log("MP_DB: Database connection already open.");
                resolve(mp_db);
                return;
            }

            const request = indexedDB.open(MP_DB_NAME, MP_DB_VERSION);

            request.onerror = (event) => {
                console.error(`MP_DB: Database error: ${event.target.errorCode}`);
                reject(`Database error: ${event.target.errorCode}`);
            };

            request.onsuccess = (event) => {
                mp_db = event.target.result;
                console.log("MP_DB: Database opened successfully.");
                // --- Add listener for database closing unexpectedly ---
                 mp_db.onclose = () => {
                     console.warn("MP_DB: Database connection closed unexpectedly.");
                     mp_db = null; // Reset the connection variable
                 };
                 mp_db.onerror = (event) => { // General DB errors
                      console.error("MP_DB: General database error:", event.target.error);
                 };
                resolve(mp_db);
            };

            // This event only runs if the database version changes (initial creation or upgrade)
            request.onupgradeneeded = (event) => {
                console.log("MP_DB: Upgrade needed or database creation.");
                const db = event.target.result;

                // Object store for Directory Handle (existing)
                if (!db.objectStoreNames.contains(MP_HANDLE_STORE_NAME)) {
                    console.log(`MP_DB: Creating object store: ${MP_HANDLE_STORE_NAME}`);
                    db.createObjectStore(MP_HANDLE_STORE_NAME);
                }

                // NEW: Object store for Song Metadata
                if (!db.objectStoreNames.contains(MP_SONG_STORE_NAME)) {
                    console.log(`MP_DB: Creating object store: ${MP_SONG_STORE_NAME}`);
                    // Create an object store for songs, using 'id' as the keyPath
                    db.createObjectStore(MP_SONG_STORE_NAME, { keyPath: 'id' });
                     // Optional: Create an index for filename if you often search by filename
                     // store.createIndex('by_fileName', 'fileName', { unique: false });
                }
            };
        });
    }

    // Puts (saves/updates) a value in the object store
    function mp_dbPut(key, value) {
        console.log(`MP_DB: Attempting to put value for key: ${key}`);
        return mp_dbOpen().then(db => {
            return new Promise((resolve, reject) => {
                 // Ensure the store exists before starting a transaction
                 if (!db || !db.objectStoreNames.contains(MP_STORE_NAME)) {
                     console.error(`MP_DB: Database not ready or Object store "${MP_STORE_NAME}" not found for put.`);
                     reject(`Database not ready or Object store "${MP_STORE_NAME}" not found.`);
                     // Optional: Attempt to reopen DB? Careful with loops.
                     // if (db) db.close();
                     // mp_db = null;
                     return;
                 }

                try {
                    const transaction = db.transaction([MP_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(MP_STORE_NAME);
                    const request = store.put(value, key);

                    request.onsuccess = () => {
                        console.log(`MP_DB: Successfully put value for key: ${key}`);
                        resolve(request.result);
                    };

                    request.onerror = (event) => {
                        console.error(`MP_DB: Error putting value for key ${key}:`, event.target.error);
                        reject(`Error putting value: ${event.target.error}`);
                    };

                    transaction.oncomplete = () => {
                        console.log(`MP_DB: Transaction completed for putting key: ${key}`);
                    };
                    transaction.onerror = (event) => {
                        console.error("MP_DB: Transaction error during put:", event.target.error);
                        reject(`Transaction error during put: ${event.target.error}`);
                    };
                 } catch (err) {
                     console.error("MP_DB: Error initiating transaction for put:", err);
                     reject(`Error initiating transaction: ${err}`);
                 }
            });
        }).catch(error => {
             console.error(`MP_DB: Error in mp_dbPut process for key ${key}:`, error);
             return Promise.reject(error);
        });
    }
// Saves multiple song objects to the 'songs' object store in IndexedDB
    function mp_dbPutSongs(songs) {
        console.log(`MP_DB: Attempting to put ${songs.length} songs into '${MP_SONG_STORE_NAME}'.`);
        if (!songs || songs.length === 0) {
            console.log("MP_DB: No songs to put.");
            return Promise.resolve();
        }
        return mp_dbOpen().then(db => {
            return new Promise((resolve, reject) => {
                 if (!db || !db.objectStoreNames.contains(MP_SONG_STORE_NAME)) {
                     console.error(`MP_DB: Database not ready or Object store "${MP_SONG_STORE_NAME}" not found for putSongs.`);
                     reject(`Database not ready or Object store "${MP_SONG_STORE_NAME}" not found.`);
                     return;
                 }
                 const transaction = db.transaction([MP_SONG_STORE_NAME], 'readwrite');
                 const store = transaction.objectStore(MP_SONG_STORE_NAME);
                 let successCount = 0;
                 let errorCount = 0;

                 songs.forEach(song => {
                     const request = store.put(song); // Put each song object

                     request.onsuccess = () => {
                         successCount++;
                         // console.log(`MP_DB: Put song ${song.id} successfully. Total success: ${successCount}`); // Verbose
                     };
                     request.onerror = (event) => {
                         errorCount++;
                         console.error(`MP_DB: Error putting song ${song.id}:`, event.target.error);
                         // Continue processing other songs despite error
                     };
                 });

                 transaction.oncomplete = () => {
                     console.log(`MP_DB: Transaction completed for putting songs. Success: ${successCount}, Errors: ${errorCount}`);
                     resolve(successCount); // Resolve with number of successful saves
                 };
                 transaction.onerror = (event) => {
                     console.error("MP_DB: Transaction error during putSongs:", event.target.error);
                     reject(`Transaction error during putSongs: ${event.target.error}`);
                 };
                 transaction.onabort = (event) => {
                     console.warn("MP_DB: Transaction aborted during putSongs:", event.target.error);
                     reject(`Transaction aborted during putSongs: ${event.target.error}`);
                 };
            });
        }).catch(error => {
             console.error(`MP_DB: Error in mp_dbPutSongs process:`, error);
             return Promise.reject(error);
        });
    }
    // Function to perform the Youtube (triggered by modal button/input)
    function performYouTubeSearch() {
        // Get elements from the Youtube modal
        const searchInput = document.getElementById('mp_Youtube-input');
        const resultsList = document.getElementById('mp_youtube-results-list');

        if (!searchInput || !resultsList) {
             console.error("MP Youtube: Search input or results list not found.");
             return;
        }

        const query = searchInput.value.trim();
        if (!query) {
            resultsList.innerHTML = '<p class="placeholder-text">Please enter a search query.</p>';
            return;
        }

        if (API_KEY === 'YOUR_YOUTUBE_API_KEY' || !API_KEY || API_KEY.includes(' ')) {
            resultsList.innerHTML = '<p class="placeholder-text" style="color: red;">YouTube API key is not set correctly.</p>';
            console.error('YouTube API Key is not set correctly in script.js');
            return;
        }

        // Clear previous results and show loading indicator
        resultsList.innerHTML = '<p class="placeholder-text">Searching...</p>';

        // Construct the YouTube Data API search URL
        // Searching for type=video and part=snippet (includes title, channel, thumbnail)
        const searchUrl = `https://www.googleapis.com/youtube/v3/search?key=${API_KEY}&q=${encodeURIComponent(query)}&maxResults=25&part=snippet&type=video`;

        console.log("MP Youtube: Fetching from:", searchUrl);

        fetch(searchUrl)
            .then(response => {
                if (!response.ok) {
                     // Check for specific error codes
                     console.error('MP Youtube: API response not OK:', response.status, response.statusText);
                     return response.json().then(err => {
                          const errorMsg = err.error && err.error.message ? err.error.message : 'Unknown API error';
                          throw new Error(`API error ${response.status}: ${errorMsg}`);
                     });
                }
                return response.json();
            })
            .then(data => {
                resultsList.innerHTML = ''; // Clear loading indicator

                if (data.items.length === 0) {
                    resultsList.innerHTML = '<p class="placeholder-text">No results found.</p>';
                    return;
                }

                // Display results
                const fragment = document.createDocumentFragment();
                data.items.forEach(item => {
                    // item.id.videoId gives the YouTube video ID
                    // item.snippet.title gives the video title
                    // item.snippet.channelTitle gives the channel name (can use as artist)
                    const videoId = item.id.videoId;
                    const title = item.snippet.title;
                    const artist = item.snippet.channelTitle; // Use channel title as artist
                    const thumbnailUrl = item.snippet.thumbnails.default.url; // Get a thumbnail URL

                    const li = document.createElement('div'); // Use div matching .list-item class
                    li.className = 'list-item';
                    li.setAttribute('role', 'option'); // Role for listbox item
                    li.setAttribute('tabindex', '0'); // Make focusable
                    li.dataset.videoId = videoId; // Store video ID

                    // Add a YouTube icon (requires Font Awesome)
                    const youtubeIcon = document.createElement('i');
                    youtubeIcon.className = 'fab fa-youtube youtube-icon';
                    li.appendChild(youtubeIcon);

                    // Add text content (Title by Artist)
                    const textSpan = document.createElement('span');
                    textSpan.textContent = `${escapeHtml(artist)} - ${escapeHtml(title)}`;
                    textSpan.title = `YouTube: ${escapeHtml(title)} by ${escapeHtml(artist)}`;
                    li.appendChild(textSpan);

                    // Add click listener to add the song
                    li.addEventListener('click', () => handleYouTubeResultClick(videoId, title, artist, thumbnailUrl));
                     // Add keyboard accessibility
                     li.onkeydown = (event) => {
                         if (event.key === 'Enter' || event.key === ' ') {
                             event.preventDefault(); // Prevent page scroll
                             handleYouTubeResultClick(videoId, title, artist, thumbnailUrl);
                         }
                     };

                    fragment.appendChild(li);
                });
                resultsList.appendChild(fragment);
                console.log(`MP Youtube: Displayed ${data.items.length} results.`);
            })
            .catch(error => {
                console.error('MP Youtube: Error fetching search results:', error);
                 resultsList.innerHTML = `<p class="placeholder-text" style="color: red;">Error searching: ${error.message}. Check console and API key.</p>`;
            });
    }

    // Handles clicking on a Youtube result
    function handleYouTubeResultClick(videoId, title, artist, thumbnailUrl) {
        console.log("MP Youtube: Result clicked. Adding video:", videoId, title, artist);

        // Create a song object for a YouTube video
        const youtubeSong = {
            id: `youtube-${videoId}`, // Unique ID prefix
            isYouTube: true, // Flag to identify YouTube songs
            videoId: videoId, // Store the video ID
            artist: artist, // Use channel title
            title: title,
            fileName: `YouTube: ${title}`, // A descriptive filename for display/search
            fileSize: 0, // N/A for YouTube
            albumArtUrl: thumbnailUrl // Store the thumbnail URL (YouTube thumbnail)
        };

        // Check if this YouTube video is already in the library by ID
        const exists = mp_musicLibrary.some(song => song.id === youtubeSong.id);

        if (exists) {
             showIndividualNotification('Info', 'This YouTube video is already in your library.', 4000);
             console.log('MP Youtube: Video already exists in library.');
        } else {
            // Add the new song to the library
            mp_musicLibrary.push(youtubeSong);
            console.log('MP Youtube: Added YouTube video to library:', youtubeSong);

            // Save the updated library (which now includes the new YouTube song)
            mp_saveMusicData(); // This saves all music data (songs to IDB, recents/playlists to LS)

            // Update the music player UI if it's currently visible/initialized
            if (mp_isInitialized) {
                if (document.getElementById('mp_songsList')) mp_renderSongsList(); // Re-render main list
                // Recents and Playlists will be updated when saved and re-rendered via their own logic
                mp_renderRecentlyPlayed(); // Important to re-render recents if a YouTube song is added and played
                mp_renderPlaylists(); // Important to re-render playlists if a YouTube song is added to one
            }

            // Close the search modal
            mp_closeModal('mp_youtubeSearchModal');

            // Show a confirmation notification
            showIndividualNotification('Success', `Added "${escapeHtml(title)}" to your library.`, 4000);
        }
    }

    // Gets all song objects from the 'songs' object store in IndexedDB
    function mp_dbGetAllSongs() {
        console.log(`MP_DB: Attempting to get all songs from '${MP_SONG_STORE_NAME}'.`);
        return mp_dbOpen().then(db => {
            return new Promise((resolve, reject) => {
                 if (!db || !db.objectStoreNames.contains(MP_SONG_STORE_NAME)) {
                      console.warn(`MP_DB: Database not ready or Object store "${MP_SONG_STORE_NAME}" not found during getAllSongs. Returning empty array.`);
                     resolve([]); // Return empty array if DB/store doesn't exist
                     return;
                 }
                 const transaction = db.transaction([MP_SONG_STORE_NAME], 'readonly');
                 const store = transaction.objectStore(MP_SONG_STORE_NAME);
                 const request = store.getAll();

                 request.onsuccess = () => {
                     console.log(`MP_DB: Successfully got ${request.result.length} songs from '${MP_SONG_STORE_NAME}'.`);
                     resolve(request.result); // request.result is an array of all objects
                 };

                 request.onerror = (event) => {
                     console.error(`MP_DB: Error getting all songs:`, event.target.error);
                     reject(`Error getting all songs: ${event.target.error}`);
                 };

                 transaction.onerror = (event) => {
                     console.error("MP_DB: Transaction error during getAllSongs:", event.target.error);
                     reject(`Transaction error during getAllSongs: ${event.target.error}`);
                 };
            });
         }).catch(error => {
             console.error(`MP_DB: Error in mp_dbGetAllSongs process:`, error);
             return Promise.reject(error);
        });
    }

     // Deletes a song by ID from the 'songs' object store
     function mp_dbDeleteSong(songId) {
         console.log(`MP_DB: Attempting to delete song with ID: ${songId} from '${MP_SONG_STORE_NAME}'.`);
         return mp_dbOpen().then(db => {
             return new Promise((resolve, reject) => {
                 if (!db || !db.objectStoreNames.contains(MP_SONG_STORE_NAME)) {
                     console.warn(`MP_DB: Database not ready or Object store "${MP_SONG_STORE_NAME}" not found during deleteSong.`);
                     resolve(); // Resolve as if deleted if store doesn't exist
                     return;
                 }
                 const transaction = db.transaction([MP_SONG_STORE_NAME], 'readwrite');
                 const store = transaction.objectStore(MP_SONG_STORE_NAME);
                 const request = store.delete(songId);

                 request.onsuccess = () => {
                     console.log(`MP_DB: Successfully deleted song with ID: ${songId}.`);
                     resolve();
                 };
                 request.onerror = (event) => {
                     console.error(`MP_DB: Error deleting song with ID ${songId}:`, event.target.error);
                     reject(`Error deleting song: ${event.target.error}`);
                 };
                  transaction.onerror = (event) => {
                      console.error("MP_DB: Transaction error during deleteSong:", event.target.error);
                      reject(`Transaction error during deleteSong: ${event.target.error}`);
                  };
             });
         }).catch(error => {
             console.error(`MP_DB: Error in mp_dbDeleteSong process for ID ${songId}:`, error);
             return Promise.reject(error);
         });
     }

    // Deletes multiple songs by ID from the 'songs' object store
    function mp_dbDeleteSongs(songIds) {
        console.log(`MP_DB: Attempting to delete ${songIds.length} songs from '${MP_SONG_STORE_NAME}'.`);
         if (!songIds || songIds.length === 0) {
            console.log("MP_DB: No song IDs to delete.");
            return Promise.resolve(0);
         }
        return mp_dbOpen().then(db => {
            return new Promise((resolve, reject) => {
                 if (!db || !db.objectStoreNames.contains(MP_SONG_STORE_NAME)) {
                     console.warn(`MP_DB: Database not ready or Object store "${MP_SONG_STORE_NAME}" not found for deleteSongs.`);
                     resolve(0); // Resolve with 0 deleted if store doesn't exist
                     return;
                 }
                 const transaction = db.transaction([MP_SONG_STORE_NAME], 'readwrite');
                 const store = transaction.objectStore(MP_SONG_STORE_NAME);
                 let deleteCount = 0;
                 let errorCount = 0;

                 songIds.forEach(songId => {
                     const request = store.delete(songId);

                     request.onsuccess = () => {
                         deleteCount++;
                         // console.log(`MP_DB: Deleted song ${songId}. Total deleted: ${deleteCount}`); // Verbose
                     };
                     request.onerror = (event) => {
                         errorCount++;
                         console.error(`MP_DB: Error deleting song ${songId}:`, event.target.error);
                         // Continue despite error
                     };
                 });

                 transaction.oncomplete = () => {
                     console.log(`MP_DB: Transaction completed for deleting songs. Deleted: ${deleteCount}, Errors: ${errorCount}`);
                     resolve(deleteCount); // Resolve with number of successful deletes
                 };
                 transaction.onerror = (event) => {
                     console.error("MP_DB: Transaction error during deleteSongs:", event.target.error);
                     reject(`Transaction error during deleteSongs: ${event.target.error}`);
                 };
                 transaction.onabort = (event) => {
                     console.warn("MP_DB: Transaction aborted during deleteSongs:", event.target.error);
                     reject(`Transaction aborted during deleteSongs: ${event.target.error}`);
                 };
            });
        }).catch(error => {
             console.error(`MP_DB: Error in mp_dbDeleteSongs process:`, error);
             return Promise.reject(error);
        });
    }
// Loads the directory handle from IndexedDB and checks its permission status


    // Gets a value from the object store by key
    function mp_dbGet(key) {
        console.log(`MP_DB: Attempting to get value for key: ${key}`);
        return mp_dbOpen().then(db => {
            return new Promise((resolve, reject) => {
                 if (!db || !db.objectStoreNames.contains(MP_STORE_NAME)) {
                     console.warn(`MP_DB: Database not ready or Object store "${MP_STORE_NAME}" not found during get. Returning undefined.`);
                     resolve(undefined); // Resolve with undefined if DB/store doesn't exist
                     return;
                 }

                try {
                    const transaction = db.transaction([MP_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(MP_STORE_NAME);
                    const request = store.get(key);

                    request.onsuccess = () => {
                        console.log(`MP_DB: Successfully got value for key: ${key}`, request.result);
                        resolve(request.result); // request.result will be undefined if key not found
                    };

                    request.onerror = (event) => {
                        console.error(`MP_DB: Error getting value for key ${key}:`, event.target.error);
                        reject(`Error getting value: ${event.target.error}`);
                    };

                    transaction.onerror = (event) => {
                        console.error("MP_DB: Transaction error during get:", event.target.error);
                        reject(`Transaction error during get: ${event.target.error}`);
                    };
                } catch (err) {
                     console.error("MP_DB: Error initiating transaction for get:", err);
                     reject(`Error initiating transaction: ${err}`);
                }
            });
         }).catch(error => {
             console.error(`MP_DB: Error in mp_dbGet process for key ${key}:`, error);
             return Promise.reject(error);
        });
    }
    // --- END IndexedDB Helper Functions ---
// Helper function to convert ArrayBuffer to Base64 string (needed for album art)
    function arrayBufferToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return window.btoa(binary);
    }

    // --- START Permission UI Function ---
    // *** MOVED EARLIER IN SCRIPT ***
    function mp_updatePermissionUI(hasAccess, handleToRequest = null) {
        // Try to find the button more reliably within the music page structure
        const musicBox = document.querySelector('#Music .music-box'); // Find the first music box
        const selectFolderButton = musicBox ? musicBox.querySelector('button[onclick="mp_selectMusicDirectory()"]') : null;

        let permissionPromptDiv = document.getElementById('mp_permission_prompt');

        // Create the prompt area if it doesn't exist and we found the button's parent
        if (!permissionPromptDiv && selectFolderButton && selectFolderButton.parentNode) {
            permissionPromptDiv = document.createElement('div');
            permissionPromptDiv.id = 'mp_permission_prompt';
            permissionPromptDiv.style.marginTop = '10px';
            permissionPromptDiv.style.padding = '8px';
            permissionPromptDiv.style.border = '1px dashed var(--text-muted)';
            permissionPromptDiv.style.borderRadius = 'var(--border-radius)';
            permissionPromptDiv.style.textAlign = 'center';
            // Insert after the "Select Folder" button
            selectFolderButton.parentNode.insertBefore(permissionPromptDiv, selectFolderButton.nextSibling);
            console.log("MP UI: Created permission prompt div.");
        }

        if (!permissionPromptDiv) {
            // Only log warning if we expected to find/create it (i.e., on Music page)
             if (document.getElementById('Music')) { // Check if the Music page structure exists
                 console.warn("MP UI: Could not find or create permission prompt UI area.");
             }
            return; // Exit if UI element isn't relevant or couldn't be created/found
        }

        if (hasAccess) {
            // Hide the prompt area if access is granted
            permissionPromptDiv.style.display = 'none';
            permissionPromptDiv.innerHTML = ''; // Clear content
            console.log("MP UI: Hiding permission prompt.");
        } else {
            // Show the prompt area if access is needed
            permissionPromptDiv.style.display = 'block';
            console.log("MP UI: Showing permission prompt.");

            if (handleToRequest) {
                // We have a handle, but need permission - show a button to request it
                 permissionPromptDiv.innerHTML = `
                    <p style="margin-bottom: 8px; color: var(--accent);">Permission needed for previously selected folder: <strong>${escapeHtml(handleToRequest.name)}</strong></p>
                    <button id="mp_grant_permission_button">Grant Access</button>
                 `;
                 const grantButton = document.getElementById('mp_grant_permission_button');
                 if (grantButton) {
                    grantButton.onclick = async () => {
                         console.log("MP: Grant Access button clicked.");
                        try {
                            const permissionStatus = await handleToRequest.requestPermission({ mode: 'read' });
                            if (permissionStatus === 'granted') {
                                console.log("MP: Permission granted via button click.");
                                mp_currentDirectoryHandle = handleToRequest; // NOW set the handle
                                mp_updatePermissionUI(true); // Update UI to hide prompt
                                // Optional: Immediately process?
                                await mp_processDirectoryHandle(mp_currentDirectoryHandle);
                            } else {
                                console.warn("MP: Permission denied via button click.");
                                alert("Permission denied. Please select the folder again if you change your mind.");
                                mp_updatePermissionUI(false); // Keep prompt, but remove specific handle info
                            }
                        } catch (err) {
                            console.error("MP: Error requesting permission:", err);
                            alert(`Error requesting permission: ${err.message}`);
                        }
                    };
                 }
            } else {
                // No handle found or permission was denied - just prompt to select folder
                permissionPromptDiv.innerHTML = `
                     <p style="margin-bottom: 0; color: var(--text-muted);">Select your music folder to load songs. folder > song name - title</p>
                 `;
            }
        }
    }
    // --- END Permission UI Function ---


// --- START Function to load handle and check permissions ---
    async function mp_loadHandleAndCheckPermissions() {
        console.log("MP: Attempting to load directory handle from IndexedDB.");
        mp_currentDirectoryHandle = null; // Reset the global handle variable
        let storedHandle = null;

        try {
            const db = await mp_dbOpen(); // This should now open successfully

            // Check if the database and the handle object store exist
            if (db && db.objectStoreNames.contains(MP_HANDLE_STORE_NAME)) { // Ensure using MP_HANDLE_STORE_NAME
                 const transaction = db.transaction([MP_HANDLE_STORE_NAME], 'readonly');
                 const store = transaction.objectStore(MP_HANDLE_STORE_NAME);
                 // --- Get the handle using the correct key 'directoryHandle' ---
                 const request = store.get('directoryHandle');

                 storedHandle = await new Promise((resolve, reject) => {
                     request.onsuccess = (event) => {
                         console.log("MP_DB: Successfully got value for key: directoryHandle", event.target.result !== undefined ? "Found" : "Not Found");
                         resolve(event.target.result);
                     };
                     request.onerror = (event) => {
                         console.error(`MP_DB: Error getting key 'directoryHandle':`, event.target.error);
                         reject(event.target.error);
                     };
                      transaction.onerror = (event) => { // Added to catch transaction errors
                          console.error("MP_DB: Transaction error during get 'directoryHandle':", event.target.error);
                          reject(event.target.error);
                      };
                 });
            } else {
                 console.warn(`MP_DB: Database not ready or Object store "${MP_HANDLE_STORE_NAME}" not found for handle loading.`);
                 storedHandle = null;
            }

            if (storedHandle) {
                console.log("MP: Directory handle loaded from IndexedDB. Checking permissions...");
                // Check permission status without prompting the user immediately
                const permissionStatus = await storedHandle.queryPermission({ mode: 'read' });
                console.log("MP: Directory handle permission status:", permissionStatus);

                if (permissionStatus === 'granted') {
                    mp_currentDirectoryHandle = storedHandle; // Assign to global variable if granted
                    console.log("MP: Directory handle permission granted.");
                    // If permission is granted, you might want to immediately process the directory
                    // to ensure the library is up-to-date if files changed.
                    // Consider calling: await mp_processDirectoryHandle(mp_currentDirectoryHandle);
                    // This will also update the UI.
                } else {
                    console.warn("MP: Directory handle permission not granted on load.");
                     // Update UI to show permission prompt needed
                    mp_updatePermissionUI(false, storedHandle); // Pass handle to show prompt button
                }
            } else {
                console.log("MP: No directory handle found in IndexedDB.");
                 // Update UI to show folder selection needed
                 mp_updatePermissionUI(false, null);
            }

        } catch (error) {
            // This catch block will now primarily catch errors from mp_dbOpen or permission checks,
            // as the ReferenceError from the old mp_dbGet call for the handle is avoided.
            console.error("MP: Error loading directory handle or checking permissions:", error);
             mp_currentDirectoryHandle = null;
             mp_updatePermissionUI(false, null);
        }
    }
    // --- END Function to load handle and check permissions ---


    // Loads metadata from LocalStorage. (Handles library, recents, playlists)
    function mp_loadDataFromLocalStorage() {
        console.log("MP: Loading metadata from LocalStorage.");
        const libraryData = localStorage.getItem('mp_musicLibrary');
        const recentlyPlayedData = localStorage.getItem('mp_recentlyPlayed');
        const playlistsData = localStorage.getItem('mp_playlists');

        mp_musicLibrary = libraryData ? JSON.parse(libraryData) : [];
        mp_recentlyPlayed = recentlyPlayedData ? JSON.parse(recentlyPlayedData) : [];
        mp_playlists = playlistsData ? JSON.parse(playlistsData) : {};

        console.log(`MP: Loaded Metadata: ${mp_musicLibrary.length} songs, ${mp_recentlyPlayed.length} recents, ${Object.keys(mp_playlists).length} playlists`);
        // Note: Handle loading happens separately in mp_loadHandleAndCheckPermissions
    }

    // Saves metadata to LocalStorage.
    function mp_saveDataToLocalStorage() {
        console.log("MP: Saving metadata to LocalStorage.");
        // Exclude temporary URLs or File objects from metadata storage
        const libraryToStore = mp_musicLibrary.map(song => ({
            id: song.id, artist: song.artist, title: song.title,
            fileName: song.fileName, fileSize: song.fileSize
            // DO NOT store fileHandle or tempUrl here
        }));

        localStorage.setItem('mp_musicLibrary', JSON.stringify(libraryToStore));
        localStorage.setItem('mp_recentlyPlayed', JSON.stringify(mp_recentlyPlayed));
        localStorage.setItem('mp_playlists', JSON.stringify(mp_playlists));
        // Note: Handle saving happens separately when the directory is selected
    }

    // Requests directory access using File System Access API
    async function mp_requestDirectoryAccess() {
        console.log("MP: Requesting directory access.");
        if (!window.showDirectoryPicker) {
            alert('MP: Your browser does not support the File System Access API. Using temporary file selection.');
            const input = document.getElementById('mp_fileInput');
            if (input) input.click();
            else console.error("MP: File input not found for fallback.");
            return null; // Return null as no persistent handle is obtained
        }
        try {
            const dirHandle = await window.showDirectoryPicker({ mode: 'read' });
            console.log("MP: Directory access granted:", dirHandle.name);
            return dirHandle; // Just return the handle
        } catch (err) {
            if (err.name !== 'AbortError') {
                console.error('MP: Error accessing directory:', err);
                alert(`MP: Error accessing directory: ${err.message}`);
            } else {
                console.log("MP: User cancelled directory selection.");
            }
            return null;
        }
    }

    // Called by the "Select Folder" button
// Handles the user clicking "Select Folder" and choosing a directory
    async function mp_selectMusicDirectory() {
        console.log("MP: Select Folder button clicked.");
        try {
            // Use the File System Access API to show directory picker
            const directoryHandle = await window.showDirectoryPicker({ mode: 'readwrite' }); // Request read/write initially
            console.log("MP: Directory selected:", directoryHandle.name);

            // Request persistent permission for read access
            const permissionStatus = await directoryHandle.requestPermission({ mode: 'read' });
            console.log("MP: Read permission request result:", permissionStatus);

            if (permissionStatus === 'granted') {
                mp_currentDirectoryHandle = directoryHandle; // Store the handle globally
                console.log("MP: Read permission granted for selected directory.");

                // --- Save the directory handle to IndexedDB ---
                try {
                    const db = await mp_dbOpen();
                    if (db && db.objectStoreNames.contains(MP_HANDLE_STORE_NAME)) {
                         const transaction = db.transaction([MP_HANDLE_STORE_NAME], 'readwrite');
                         const store = transaction.objectStore(MP_HANDLE_STORE_NAME);
                         const request = store.put(directoryHandle, 'directoryHandle'); // Store handle with a fixed key

                         request.onsuccess = () => {
                              console.log("MP_DB: Directory handle saved to IndexedDB.");
                         };
                         request.onerror = (event) => {
                             console.error("MP_DB: Error saving directory handle:", event.target.error);
                              alert("Error saving directory access for persistence.");
                         };
                          transaction.onerror = (event) => {
                              console.error("MP_DB: Transaction error during handle save:", event.target.error);
                               alert("Error saving directory access for persistence.");
                          };
                    } else {
                         console.error(`MP_DB: Object store "${MP_HANDLE_STORE_NAME}" not found for handle saving.`);
                         alert("Error saving directory access for persistence: Database not ready.");
                    }
                } catch (dbError) {
                     console.error("MP: Error in mp_selectMusicDirectory DB save process:", dbError);
                      alert("Error saving directory access for persistence.");
                }
                // --- End Save Handle ---


                // Update UI to show permission status
                mp_updatePermissionUI(true); // Permission granted

                // Process the files in the selected directory
                await mp_processDirectoryHandle(directoryHandle);
                console.log("MP: Directory processing initiated after selection.");

            } else {
                console.warn("MP: Read permission denied for selected directory.");
                mp_currentDirectoryHandle = null; // Ensure handle is null if permission denied
                 mp_updatePermissionUI(false, directoryHandle); // Update UI to show permission prompt needed (pass the handle)
                alert("Permission to read the selected directory was denied. Music will not be loaded persistently.");
            }

        } catch (error) {
            console.error("MP: Error selecting directory:", error);
             mp_currentDirectoryHandle = null;
             mp_updatePermissionUI(false, null);
            if (error.name === 'AbortError') {
                console.log("MP: Directory picker aborted by user.");
            } else {
                 alert(`An error occurred while selecting the directory: ${error.message}`);
            }
        }
    }

    // Processes files from the directory handle (recursive)
// Processes files from the directory handle (recursive) and extracts metadata including album art
// Processes files from the directory handle (recursive) and extracts metadata including album art
    async function mp_processDirectoryHandle(dirHandle) {
        if (!dirHandle) {
            console.error("MP: mp_processDirectoryHandle called with null handle.");
            return;
        }
        console.log(`MP: Processing directory: ${dirHandle.name}`);
        const processingPromises = [];
        let fileCount = 0;
        const processedPaths = new Set(); // To avoid processing duplicates if structure is odd
    
        // Clear existing library before processing to avoid duplicates from multiple selections/scans
        // We will repopulate it with updated song objects including metadata
        mp_musicLibrary = [];
        console.log("MP: Cleared existing music library before processing directory.");
    
        // Function to read tags asynchronously for a single file
        const readTagsAsync = (file) => {
            return new Promise((resolve, reject) => {
                // Check if jsmediatags is available
                if (typeof jsmediatags === 'undefined') {
                     console.warn("MP: jsmediatags library not loaded. Skipping tag reading for:", file.name);
                     resolve(null); // Resolve with null if library is missing
                     return;
                 }
                jsmediatags.read(file, {
                    onSuccess: function(tag) {
                        // tag.tags will contain the metadata, including tag.tags.picture
                        resolve(tag.tags);
                    },
                    onError: function(error) {
                        console.warn("MP: Error reading tags for", file.name, ":", error.type, error.info);
                        resolve(null); // Resolve with null if tags can't be read
                    }
                });
            });
        };
    
    
        async function processEntry(entryHandle, currentPath = '') {
             // --- Permission Check within Recursion ---
             try {
                  if (entryHandle.kind === 'directory') {
                       // Check permission for the directory *before* trying to iterate its values
                       // Use queryPermission to avoid prompting here; actual prompt happens via UI button
                       if (await entryHandle.queryPermission({ mode: 'read' }) !== 'granted') {
                           console.warn(`MP: Read permission not granted for subdirectory: ${currentPath ? currentPath + '/' : ''}${entryHandle.name}. Skipping.`);
                           return; // Skip this directory
                       }
                  } else if (entryHandle.kind === 'file') {
                      // Check permission for the file *before* trying to getFile()
                      // Use queryPermission
                      if (await entryHandle.queryPermission({ mode: 'read' }) !== 'granted') {
                           console.warn(`MP: Read permission not granted for file: ${currentPath ? currentPath + '/' : ''}${entryHandle.name}. Skipping.`);
                           return; // Skip this file
                       }
                  }
             } catch (permErr) {
                  console.error(`MP: Error checking permission for ${entryHandle.kind} ${entryHandle.name}:`, permErr);
                  return; // Skip on permission check error
             }
             // --- End Permission Check ---
    
    
             const entryPath = currentPath ? `${currentPath}/${entryHandle.name}` : entryHandle.name;
             if (processedPaths.has(entryPath)) {
                 // console.log(`MP: Skipping already processed path: ${entryPath}`); // Optional verbose log
                 return; // Skip if already processed
             }
             processedPaths.add(entryPath);
    
             try {
                 if (entryHandle.kind === 'file') {
                     // Check if it's an audio file before processing
                     if (entryHandle.name.toLowerCase().endsWith('.mp3') || entryHandle.name.toLowerCase().endsWith('.wav') || entryHandle.name.toLowerCase().endsWith('.aac') || entryHandle.name.toLowerCase().endsWith('.ogg')) {
                        const file = await entryHandle.getFile();
                         // Skip files that appear to be too small to be valid audio
                         if (file.size < 1024) { // e.g., less than 1KB
                              console.warn(`MP: Skipping potentially invalid small file: ${entryHandle.name} (${file.size} bytes)`);
                              return; // Skip this file
                         }
                         fileCount++;
                         console.log("MP: Processing file:", file.name); // Log file being processed
    
                        // --- Asynchronously read tags ---
                         const tags = await readTagsAsync(file);
    
                        let artist = "Unknown Artist";
                        let title = file.name.replace(/\.(mp3|wav|aac|ogg)$/i, '').trim(); // Fallback to filename
                        let albumArtUrl = null; // To store the data URL of album art
    
                        if (tags) {
                            // Prefer tags if available
                            artist = tags.artist || artist;
                            title = tags.title || title;
    
                            // Process album art
                            if (tags.picture) {
                                try {
                                    const picture = tags.picture;
                                    const base64String = arrayBufferToBase64(picture.data);
                                    albumArtUrl = `data:${picture.format};base64,${base64String}`;
                                    console.log(`MP: Extracted album art for "${file.name}". Format: ${picture.format}`);
                                } catch (artErr) {
                                    console.warn(`MP: Error processing album art for "${file.name}":`, artErr);
                                    albumArtUrl = null; // Ensure it's null on error
                                }
                            }
                        } else {
                             console.log(`MP: No readable tags found for "${file.name}". Using filename info.`);
                        }
    
                        // Generate a stable ID based on file path relative to the directory handle
                        // This assumes file names within the selected folder are unique enough
                        const songId = entryPath; // Use relative path as ID
    
                        // Create the song object
                         const song = {
                             id: songId,
                             fileName: entryHandle.name, // Just the filename
                             filePath: entryPath, // Full path relative to selected directory
                             artist: artist,
                             title: title,
                             fileSize: file.size,
                            //  handle: entryHandle, // DO NOT store handles directly in objects that are stringified
                             albumArtUrl: albumArtUrl // Store the album art data URL
                         };
                         mp_musicLibrary.push(song); // Add to the main library array
                         // console.log(`MP: Added song to library: "${song.title}" by ${song.artist}`); // Optional verbose log
    
                     } else {
                         // console.log(`MP: Skipping non-audio file: ${entryHandle.name}`); // Optional verbose log
                     }
                 } else if (entryHandle.kind === 'directory') {
                      // console.log(`MP: Entering subdirectory: ${entryPath}`); // Optional verbose log
                      // Iterate using handle.values()
                      for await (const subEntryHandle of entryHandle.values()) {
                          await processEntry(subEntryHandle, entryPath); // Recurse
                      }
                 }
              } catch (err) {
                  // Log errors getting file or iterating directory more specifically
                  if (err.name === 'NotAllowedError') {
                       console.warn(`MP: Permission denied while processing entry ${entryPath}:`, err.message);
                  } else if (err.name === 'NotFoundError') {
                       console.warn(`MP: Entry not found while processing ${entryPath} (possibly moved/deleted):`, err.message);
                  } else {
                       console.error(`MP: Error processing entry ${entryPath}:`, err);
                  }
                  // Continue processing other files despite errors on one
              }
         }
    
        try {
             // Note: Recursive processing with await inside the loop inherently waits
             // We don't need Promise.all on a separate array if await is used directly
             await processEntry(dirHandle); // Start processing from root handle
             console.log(`MP: Directory processing complete. ${mp_musicLibrary.length} audio files added/updated.`);
        } catch (processErr) {
             console.error("MP: Error during overall directory processing:", processErr);
             // Handle top-level errors if needed
        }
    
        // ***** CORRECTED LINE *****
        await mp_saveMusicData(); // Save the potentially updated library metadata to IndexedDB
        // **************************
    
        // Render lists only if the music page is currently active/initialized
        // Use a small delay to ensure DOM is ready after processing might take time
        setTimeout(() => {
            if (mp_isInitialized && document.getElementById('mp_songsList')) {
                 console.log("MP: Rendering lists after directory processing.");
                 mp_renderSongsList();
                 mp_renderRecentlyPlayed(); // Update recents too
                 mp_renderPlaylists(); // And playlists
                 // Ensure playback bar is shown if there's music
                 if (mp_playbackControlsBar) mp_playbackControlsBar.style.display = 'flex';
            } else {
                console.log("MP: Music page not active/initialized, skipping list render after directory processing.");
                 // Ensure playback bar is hidden if no music
                 if (mp_playbackControlsBar) mp_playbackControlsBar.style.display = 'none';
            }
        }, 100); // Short delay
    }


    // Processes a single file, stores metadata
// Processes a single file, stores metadata (primarily for fallback file input)
     // Updated to use jsmediatags for tag reading
     async function mp_processPersistentSongFile(file, fileHandle = null) { // Keep fileHandle param for clarity, even if null
         // This is for the file input fallback
         console.log("MP: Processing single file (fallback):", file.name);

         // Generate a stable ID based on file name and size for fallback
         const songId = `mp-fallback-${file.name}-${file.size}`;

         // Use jsmediatags for metadata if available, otherwise fallback to filename parsing
         let artist = "Unknown Artist";
         let title = file.name.replace(/\.(mp3|wav|aac|ogg)$/i, '').trim(); // Fallback to filename
         let albumArtUrl = null;

         // --- Asynchronously read tags for the single file ---
         const tags = await new Promise((resolve) => {
              if (typeof jsmediatags === 'undefined') {
                  console.warn("MP: jsmediatags library not loaded. Skipping tag reading for single file:", file.name);
                  resolve(null);
                  return;
              }
              jsmediatags.read(file, {
                  onSuccess: function(tag) { resolve(tag.tags); },
                  onError: function(error) {
                      console.warn("MP: Error reading tags for single file", file.name, ":", error.type, error.info);
                      resolve(null);
                  }
              });
         });

         if (tags) {
             artist = tags.artist || artist;
             title = tags.title || title;
             if (tags.picture) {
                 try {
                     const picture = tags.picture;
                     const base64String = arrayBufferToBase64(picture.data);
                     albumArtUrl = `data:${picture.format};base64,${base64String}`;
                      console.log(`MP: Extracted album art for single file "${file.name}". Format: ${picture.format}`);
                 } catch (artErr) {
                      console.warn(`MP: Error processing album art for single file "${file.name}":`, artErr);
                      albumArtUrl = null;
                 }
             }
         } else {
              console.log(`MP: No readable tags found for single file "${file.name}". Using filename info.`);
         }

         const song = {
             id: songId,
             fileName: file.name, // Just the filename
             filePath: file.name, // Use filename as path for fallback
             artist: artist,
             title: title,
             fileSize: file.size,
             // No handle for fallback file
             albumArtUrl: albumArtUrl // Store the album art data URL
         };

         // Check if song with the same name and size already exists in the library
         // (This check is needed here for the fallback, the directory processor clears and repopulates)
         if (!mp_musicLibrary.some(s => s.fileName === song.fileName && s.fileSize === song.fileSize && s.filePath === song.filePath)) {
             mp_musicLibrary.push(song); // Add to the main library array
             console.log(`MP: Added single file to library (fallback): "${song.title}" by ${song.artist}`);
         } else {
             console.log(`MP: Skipping duplicate single file: ${song.fileName}`);
         }
     }

    // Fallback for standard file input
    // Modify mp_handleFileSelect to call mp_processPersistentSongFile
    // Fallback for standard file input
    // Modify mp_handleFileSelect to call mp_processPersistentSongFile
    async function mp_handleFileSelect(event) { // Added async
        console.log("MP: Using file input fallback.");
        mp_currentDirectoryHandle = null; // Not using directory handle here
        mp_updatePermissionUI(false); // Update UI to show folder selection is needed for persistence
    
        const files = event.target.files;
        if (!files || files.length === 0) return;
        console.log(`MP: Processing ${files.length} files from input...`);
        const processingPromises = [];
    
        // Clear library when loading via file input to avoid mixing persistent/non-persistent
        mp_musicLibrary = [];
        console.log("MP: Cleared existing library before processing file input.");
    
    
        Array.from(files).forEach(file => {
            if (file.type.startsWith('audio/')) {
                // Use the updated mp_processPersistentSongFile which includes tag reading
                processingPromises.push(mp_processPersistentSongFile(file, null)); // No handle here
            } else {
                console.warn(`MP: Skipping non-audio file: ${file.name}`);
            }
        });
        await Promise.all(processingPromises);
        console.log("MP: File input processing complete.");
    
        // ***** CORRECTED LINE *****
        await mp_saveMusicData(); // Save metadata using the proper function
        // **************************
    
        if (mp_isInitialized && document.getElementById('mp_songsList')) { // Check if page is active
            console.log("MP: Rendering songs list after file input processing.");
            mp_renderSongsList();
            // No need to re-render recents/playlists as they aren't affected by this process typically
        } else {
             console.log("MP: Music page not active/initialized, skipping list render after file input.");
        }
        event.target.value = null; // Allow selecting same files again
    }

    // Parses filename "Artist - Title.mp3"
    function mp_parseFileName(fileName) {
        let baseName = fileName.substring(0, fileName.lastIndexOf('.')) || fileName;
        const separator = ' - ';
        let artist = 'Unknown Artist';
        let title = baseName;
        if (baseName.includes(separator)) {
            const parts = baseName.split(separator);
            if (parts.length >= 2) {
                artist = parts[0].trim();
                title = parts.slice(1).join(separator).trim();
            }
        }
        return { artist, title };
    }

    // Finds song metadata by ID
    function mp_findSongById(songId) {
        return mp_musicLibrary.find(song => song.id === songId);
    }

    // --- Playback Logic ---

    // Stops playback, revokes URL, clears UI for both main bar and hover overlay
    function mp_stopPlaybackAndClearUI() {
        console.log("MP: Stopping playback and clearing UI.");
        // Stop any currently playing audio or video
        if (mp_audioPlayer && mp_audioPlayer.src) {
            mp_audioPlayer.pause();
            mp_audioPlayer.removeAttribute('src'); // More reliable than setting to ''
            mp_audioPlayer.load(); // Reset internal state
            // Revoke old temporary URL if it exists (only for local files)
            if (mp_currentSong && !mp_currentSong.isYouTube && mp_currentSong.tempUrl) {
                URL.revokeObjectURL(mp_currentSong.tempUrl);
                console.log("MP: Revoked old temporary URL.");
            }
        }
         // Stop any currently playing YouTube video
         // Clear any active YouTube time update simulation interval
         if (youtubeTimeUpdateInterval) {
              clearInterval(youtubeTimeUpdateInterval);
              youtubeTimeUpdateInterval = null;
              console.log("MP: Stopped YouTube time update simulation interval.");
         }

         if (mp_youtubePlayer && typeof mp_youtubePlayer.stopVideo === 'function') {
              mp_youtubePlayer.stopVideo(); // Stop the video
             // Optional: Reset player state/src visually in the tiny div if needed
              const hiddenPlayerDiv = document.getElementById('mp_youtube_hidden_player');
              if (hiddenPlayerDiv) hiddenPlayerDiv.innerHTML = ''; // Clear the iframe
              // Do NOT destroy the player here, as we might need it again
              // if (typeof mp_youtubePlayer.destroy === 'function') mp_youtubePlayer.destroy();
              console.log("MP: Stopped existing YouTube player and cleared div.");
         }


        mp_currentSong = null;
        mp_currentSongIndex = -1;
        // mp_currentQueue = []; // Keep queue for potential resume? Maybe clear on explicit stop?
        mp_isPlaying = false;

        // --- Clear Main Playback Bar UI ---
        if (mp_currentSongInfo) mp_currentSongInfo.textContent = "No Song Playing";
        if (mp_currentSongInfo) mp_currentSongInfo.title = "";
        if (mp_seekBar) mp_seekBar.value = 0;
        if (mp_currentTime) mp_currentTime.textContent = mp_formatTime(0);
        if (mp_totalDuration) mp_totalDuration.textContent = mp_formatTime(0);
        // Disable playback controls buttons
         if (mp_playPauseButton) mp_playPauseButton.disabled = true;
         if (mp_prevButton) mp_prevButton.disabled = true;
         if (mp_nextButton) mp_nextButton.disabled = true;


        // --- Update Hover Overlay State ---
        // Check if the hover overlay is initialized before accessing its elements
        if (mp_hoverOverlayInitialized && audioControlHoverOverlay && audioControlHoverOverlay.style.display === 'flex') {
            // Hide it as no song is playing.
            audioControlHoverOverlay.style.display = 'none'; // Hide the overlay
            console.log("MP: Hiding Hover Overlay.");
            // Clear its content (optional, but clean)
            if (hoverOverlaySongTitle) hoverOverlaySongTitle.textContent = "No song playing";
            if (hoverOverlaySongTitle) hoverOverlaySongTitle.title = "";
            if (hoverOverlayScroller) hoverOverlayScroller.value = 0;
            if (hoverOverlayCurrentTime) hoverOverlayCurrentTime.textContent = mp_formatTime(0);
            if (hoverOverlayTotalDuration) hoverOverlayTotalDuration.textContent = mp_formatTime(0);
             // Disable hover overlay buttons
             if (hoverOverlayPlayPauseBtn) hoverOverlayPlayPauseBtn.disabled = true;
             if (hoverOverlayBackwardBtn) hoverOverlayBackwardBtn.disabled = true;
             if (hoverOverlayForwardBtn) hoverOverlayForwardBtn.disabled = true;
        } else {
             // Ensure it's hidden if it wasn't initialized/visible but playback was stopped
             if (audioControlHoverOverlay) audioControlHoverOverlay.style.display = 'none';
        }
        // --- End Update Hover Overlay ---

        mp_updatePlayingIndicator(); // Clear playing indicators in lists
    }
// Loads music data from IndexedDB (songs) and LocalStorage (recents, playlists)
    async function mp_loadMusicData() {
        console.log("MP: Loading music data from IndexedDB and LocalStorage.");
        try {
            // Load songs from IndexedDB
            mp_musicLibrary = await mp_dbGetAllSongs();
            console.log(`MP: Loaded ${mp_musicLibrary.length} songs from IndexedDB.`);

            // Load recents and playlists from LocalStorage
            const recentlyPlayedData = localStorage.getItem('mp_recentlyPlayed');
            const playlistsData = localStorage.getItem('mp_playlists');

            mp_recentlyPlayed = recentlyPlayedData ? JSON.parse(recentlyPlayedData) : [];
            mp_playlists = playlistsData ? JSON.parse(playlistsData) : {};

            console.log(`MP: Loaded ${mp_recentlyPlayed.length} recents and ${Object.keys(mp_playlists).length} playlists from LocalStorage.`);

        } catch (error) {
            console.error("MP: Error loading music data:", error);
            // Fallback to empty state if loading fails
            mp_musicLibrary = [];
            mp_recentlyPlayed = [];
            mp_playlists = {};
            console.warn("MP: Music data loading failed. Initializing with empty state.");
            // Don't alert here, as it might happen on every load if something is wrong.
            // The UI should indicate that the library is empty.
        }
    }

    // Saves music data to IndexedDB (songs) and LocalStorage (recents, playlists)
    // This function is called after processing or changes
    async function mp_saveMusicData() {
        console.log("MP: Saving music data to IndexedDB and LocalStorage.");
        try {
            // Save the *entire* current in-memory mp_musicLibrary to IndexedDB
            // This will add new songs and update existing ones (if they have the same ID)
            // Note: This replaces ALL songs in the DB with the current in-memory state.
            // A more efficient approach for large libraries might be to only put changed/new songs.
            // But for simplicity, saving the full list works for now.
            await mp_dbPutSongs(mp_musicLibrary);
            console.log(`MP: Saved ${mp_musicLibrary.length} songs to IndexedDB.`);

            // Save recents and playlists to LocalStorage
            localStorage.setItem('mp_recentlyPlayed', JSON.stringify(mp_recentlyPlayed));
            localStorage.setItem('mp_playlists', JSON.stringify(mp_playlists));
             console.log(`MP: Saved ${mp_recentlyPlayed.length} recents and ${Object.keys(mp_playlists).length} playlists to LocalStorage.`);

        } catch (error) {
            console.error("MP: Error saving music data:", error);
            // Don't alert here, as it might happen frequently.
            console.warn("MP: Music data saving failed. Some changes might not be saved.");
        }
        // Note: Saving the directory handle happens separately in mp_selectMusicDirectory
    }


    // Loads song metadata, gets file handle, creates temp URL, loads player
// Loads song metadata, gets file handle (for local), creates temp URL, loads player (audio or YouTube)
// Loads song metadata, gets file handle (for local), creates temp URL, loads player (audio or YouTube)
// Loads song metadata, gets file handle (for local), creates temp URL, loads player (audio or YouTube)
    async function mp_loadSong(songMetaData) {
        console.log("MP_DEBUG: mp_loadSong called for:", songMetaData?.fileName || songMetaData?.title, "ID:", songMetaData?.id);
        if (!songMetaData || !songMetaData.id) {
            console.error("MP_CRITICAL_ERROR: Invalid song metadata passed to mp_loadSong. Metadata:", songMetaData);
            mp_stopPlaybackAndClearUI();
            return;
        }

        if (mp_playbackControlsBar) mp_playbackControlsBar.style.display = 'flex';

        if (mp_audioPlayer && mp_audioPlayer.src) {
             mp_audioPlayer.pause();
             mp_audioPlayer.removeAttribute('src');
             mp_audioPlayer.load();
             if (mp_currentSong && !mp_currentSong.isYouTube && mp_currentSong.tempUrl) {
                 URL.revokeObjectURL(mp_currentSong.tempUrl);
                 console.log("MP_DEBUG: Revoked old temporary URL for local file.");
             }
        }
         if (youtubeTimeUpdateInterval) {
              clearInterval(youtubeTimeUpdateInterval);
              youtubeTimeUpdateInterval = null;
              console.log("MP_DEBUG: Cleared YouTube time update simulation interval.");
         }

         if (mp_youtubePlayer && typeof mp_youtubePlayer.stopVideo === 'function') {
              console.log("MP_DEBUG: Stopping existing YouTube player video (if any).");
              mp_youtubePlayer.stopVideo();
              // If destroying and recreating player, ensure mp_youtubePlayer is nulled after destroy.
              // For now, we are reusing if possible, so just stopVideo.
         }

        mp_currentSong = songMetaData;

        const songTitleDisplay = `${songMetaData.artist || 'Unknown Artist'} - ${songMetaData.title || 'Unknown Title'}`;
        if (mp_currentSongInfo) {
            mp_currentSongInfo.textContent = songTitleDisplay;
            mp_currentSongInfo.title = songTitleDisplay;
        }
        if (mp_seekBar) mp_seekBar.value = 0;
        if (mp_currentTime) mp_currentTime.textContent = mp_formatTime(0);
        if (mp_totalDuration) mp_totalDuration.textContent = mp_formatTime(0);

        if (mp_hoverOverlayInitialized && audioControlHoverOverlay && audioControlHoverOverlay.style.display === 'flex') {
             if (hoverOverlaySongTitle) {
                 hoverOverlaySongTitle.textContent = songTitleDisplay;
                 hoverOverlaySongTitle.title = songTitleDisplay;
             }
             if (hoverOverlayScroller) hoverOverlayScroller.value = 0;
             if (hoverOverlayCurrentTime) hoverOverlayCurrentTime.textContent = mp_formatTime(0);
             if (hoverOverlayTotalDuration) hoverOverlayTotalDuration.textContent = mp_formatTime(0);
        }

        mp_updatePlaybackControls();

        if (songMetaData.isYouTube) {
            console.log("MP_DEBUG: mp_loadSong - Preparing to load YouTube video:", songMetaData.videoId);

            runWhenYouTubeApiReady(() => {
                console.log("MP_DEBUG: YouTube API ready callback executed, proceeding with loading video:", songMetaData.videoId);

                const hiddenPlayerDivId = 'mp_youtube_hidden_player';
                const hiddenPlayerDiv = document.getElementById(hiddenPlayerDivId);
                if (!hiddenPlayerDiv) {
                    console.error("MP_CRITICAL_ERROR: Hidden YouTube player div not found:", hiddenPlayerDivId);
                    showIndividualNotification('Error', 'Player container missing.', 5000);
                    return;
                }
                hiddenPlayerDiv.style.width = '120px';
                hiddenPlayerDiv.style.height = '120px';

                const playerVarsForDebug = {
                    'controls': 1, 'autoplay': 1, 'disablekb': 0, 'fs': 1,
                    'iv_load_policy': 3, 'modestbranding': 1, 'rel': 0,
                    'origin': window.location.origin
                };
                console.log('MP_DEBUG: PlayerVars for new/existing YT.Player:', playerVarsForDebug);
                console.log('MP_DEBUG: Target videoId:', songMetaData.videoId);
                console.log('MP_DEBUG: mp_youtubePlayer before decision:', mp_youtubePlayer, "Is function?", typeof mp_youtubePlayer?.loadVideoById === 'function');


                // Determine if we need to create a new player or reuse an existing one
                let needsNewPlayer = !mp_youtubePlayer ||
                                     typeof mp_youtubePlayer.loadVideoById !== 'function' || // Player object doesn't have methods
                                     (mp_youtubePlayer.getIframe && !document.getElementById(hiddenPlayerDivId)?.contains(mp_youtubePlayer.getIframe())) || // Player's iframe not in our div
                                     !document.getElementById(hiddenPlayerDivId)?.querySelector('iframe'); // No iframe in our div

                if (needsNewPlayer) {
                    console.log('MP_DEBUG: Creating NEW YouTube player instance in div:', hiddenPlayerDivId);
                    if(hiddenPlayerDiv) hiddenPlayerDiv.innerHTML = ''; // Clear div for fresh player

                    // Destroy the old player instance if it exists but is problematic
                    if (mp_youtubePlayer && typeof mp_youtubePlayer.destroy === 'function') {
                        try {
                            mp_youtubePlayer.destroy();
                            console.log('MP_DEBUG: Destroyed previous problematic mp_youtubePlayer instance.');
                        } catch (destroyError) {
                            console.error('MP_DEBUG: Error destroying previous mp_youtubePlayer instance:', destroyError);
                        }
                        mp_youtubePlayer = null; // Explicitly nullify
                    }

                    try {
                        mp_youtubePlayer = new YT.Player(hiddenPlayerDivId, {
                            height: '100%', width: '100%',
                            videoId: songMetaData.videoId,
                            playerVars: playerVarsForDebug,
                            events: {
                                'onReady': (event) => {
                                    console.log('MP_DEBUG: YT.Player INTERNAL onReady event FIRED! Player state at onReady:', event.target.getPlayerState());
                                    console.log('MP_DEBUG: YT.Player INTERNAL onReady - typeof event.target.getPlayerState:', typeof event.target.getPlayerState);
                                    onYouTubePlayerReady(event);
                                },
                                'onStateChange': (event) => {
                                     console.log('MP_DEBUG: YT.Player INTERNAL onStateChange event FIRED! New State:', event.data, "Player State Now:", event.target.getPlayerState());
                                     onYouTubePlayerStateChange(event);
                                },
                                'onError': (event) => {
                                     console.log('MP_DEBUG: YT.Player INTERNAL onError event FIRED! Error code:', event.data, "Player State Now:", event.target.getPlayerState());
                                     onYouTubePlayerError(event);
                                }
                            }
                        });
                        console.log('MP_DEBUG: new YT.Player() call completed. mp_youtubePlayer assigned.');
                    } catch (e) {
                        console.error('MP_CRITICAL_ERROR: Error during new YT.Player() instantiation:', e);
                        showIndividualNotification('Error', 'Failed to create YouTube player.', 6000);
                        mp_youtubePlayer = null;
                    }
                } else {
                    console.log('MP_DEBUG: Reusing existing YouTube player. Loading video:', songMetaData.videoId);
                    try {
                        mp_youtubePlayer.loadVideoById({ videoId: songMetaData.videoId });
                        console.log('MP_DEBUG: mp_youtubePlayer.loadVideoById() call completed.');
                    } catch (e) {
                         console.error('MP_CRITICAL_ERROR: Error during mp_youtubePlayer.loadVideoById():', e);
                         showIndividualNotification('Error', 'Failed to load video in existing player.', 6000);
                    }
                }
            });

        } else { // It's a local file
            console.log("MP_DEBUG: mp_loadSong - Loading local file:", songMetaData.fileName);
            // (Rest of local file loading logic - kept for completeness but not the focus of the current YouTube issue)
            if (!mp_currentDirectoryHandle) {
                 console.error("MP_CRITICAL_ERROR: Directory handle not available for local file. Cannot load song:", songMetaData.fileName);
                 mp_updatePermissionUI(false, null);
                 mp_stopPlaybackAndClearUI();
                 return;
            }
            // ... (findFileHandleRecursive and file loading logic) ...
            let fileToPlay = null;
            try {
                 if (await mp_currentDirectoryHandle.queryPermission({ mode: 'read' }) !== 'granted') {
                      console.error("MP_CRITICAL_ERROR: Read permission check failed just before loading local song:", songMetaData.fileName);
                      mp_updatePermissionUI(false, mp_currentDirectoryHandle);
                      mp_stopPlaybackAndClearUI();
                      return;
                 }
                 async function findFileHandleRecursive(dirHandle, filePathToFind, currentPath = '') { /* ... */ return null;} // Placeholder for brevity
                 const fileHandle = await findFileHandleRecursive(mp_currentDirectoryHandle, songMetaData.filePath);
                 if (!fileHandle) throw new Error(`Local file not found: ${songMetaData.filePath}`);
                 if (await fileHandle.queryPermission({ mode: 'read' }) !== 'granted') throw new Error(`Read permission failed for file: ${fileHandle.name}`);
                 fileToPlay = await fileHandle.getFile();
            } catch (err) {
                console.error("MP_CRITICAL_ERROR: Error getting local file for playback:", err);
                showIndividualNotification("Playback Error", `Error loading "${songMetaData.title || songMetaData.fileName}": ${err.message}`, 6000);
                mp_stopPlaybackAndClearUI(); return;
            }
            const tempUrl = URL.createObjectURL(fileToPlay);
            mp_currentSong.tempUrl = tempUrl;
            if (mp_audioPlayer) {
                mp_audioPlayer.src = tempUrl; mp_audioPlayer.load(); mp_playAudio();
            }
        }

        mp_addToRecentlyPlayed(songMetaData.id);
        mp_updatePlayingIndicator();
        console.log("MP_DEBUG: mp_loadSong finished for:", songMetaData.id);
    }

    // ... (your other functions like onYouTubeIframeAPIReady, runWhenYouTubeApiReady, onYouTubePlayerReady, onYouTubePlayerStateChange, onYouTubePlayerError, etc.) ...
    
// --- Add YouTube Player Event Handlers ---
    function onYouTubePlayerReady(event) {
        console.log('MP YouTube Player: Player is ready.');
        // Player is ready, event.target is the player instance
        // You can use event.target.playVideo() here if you want to ensure playback starts
        // (though autoplay in playerVars should handle it).
         // Ensure the state is updated
         // mp_isPlaying state is primarily managed by onStateChange, but we can optimistically set it true here
         // mp_isPlaying = true; // Better to wait for onStateChange -> PLAYING
         mp_updatePlaybackControls(); // Update UI buttons (they become enabled if a song is loaded)

        // Update duration if available (it might be available here or on the first timeupdate)
         if (event.target && typeof event.target.getDuration === 'function') {
              const duration = event.target.getDuration();
              if (!isNaN(duration) && duration > 0) {
                  if(mp_totalDuration) mp_totalDuration.textContent = mp_formatTime(duration);
                   if(mp_hoverOverlayInitialized && hoverOverlayTotalDuration) hoverOverlayTotalDuration.textContent = mp_formatTime(duration);
                   // Update seek bar max value (if using 0-100 scale)
                   if(mp_seekBar) mp_seekBar.max = 100;
                   if(mp_hoverOverlayInitialized && hoverOverlayScroller) hoverOverlayScroller.max = 100;
              }
         }
         // Start the timeupdate simulation (since YouTube player doesn't fire it like <audio>)
         // This will only start if the state changes to PLAYING
         // mp_startYouTubeTimeUpdateSimulation(); // Moved this call to onStateChange -> PLAYING
    }

     // Simulation interval for YouTube timeupdate
     // let youtubeTimeUpdateInterval = null; // Already declared globally

     function mp_startYouTubeTimeUpdateSimulation() {
          // Clear any existing interval first
          if (youtubeTimeUpdateInterval) {
               clearInterval(youtubeTimeUpdateInterval);
               youtubeTimeUpdateInterval = null;
               console.log("MP YouTube Player: Cleared previous timeupdate simulation interval.");
          }

          // Only start simulation if we are supposed to be playing a YouTube video AND the player is actually playing
          if (!mp_currentSong || !mp_currentSong.isYouTube || !mp_youtubePlayer || typeof mp_youtubePlayer.getPlayerState !== 'function' || mp_youtubePlayer.getPlayerState() !== YT.PlayerState.PLAYING) {
               console.log("MP YouTube Player: Not starting timeupdate simulation. Player not ready, not YouTube, or not in PLAYING state.");
               return; // Don't start the interval if prerequisites aren't met
          }

          console.log("MP YouTube Player: Starting timeupdate simulation interval.");
          // Set a new interval (e.g., update every 250ms)
          youtubeTimeUpdateInterval = setInterval(() => {
               // Inside the interval, check again if the song is still playing and it's a YouTube video
               // This check prevents errors if the song changes or playback stops while the interval is active
               if (mp_currentSong && mp_currentSong.isYouTube && mp_youtubePlayer && typeof mp_youtubePlayer.getCurrentTime === 'function' && typeof mp_youtubePlayer.getDuration === 'function' && mp_youtubePlayer.getPlayerState() === YT.PlayerState.PLAYING) {
                   const currentTime = mp_youtubePlayer.getCurrentTime();
                   const duration = mp_youtubePlayer.getDuration();
                   // Ensure values are valid before updating UI
                   if (!isNaN(currentTime) && !isNaN(duration) && duration > 0) {
                        // Manually call the update function with current data
                        // mp_updateSeekBar function is designed to read from the *active* player internally
                        mp_updateSeekBar(); // Call the combined update function
                   } else {
                        // Handle cases where duration might be 0 or NaN briefly
                        // mp_updateSeekBar already handles displaying 0:00 or similar for invalid duration
                         mp_updateSeekBar();
                   }
               } else {
                   // If the state changes or song changes while the interval is running, stop it
                   console.log("MP YouTube Player: Stopping timeupdate simulation from inside interval (state change or song change detected).");
                   if (youtubeTimeUpdateInterval) {
                        clearInterval(youtubeTimeUpdateInterval);
                        youtubeTimeUpdateInterval = null;
                   }
               }
          }, 250); // Update every quarter second (adjust as needed)
     }

    function onYouTubePlayerStateChange(event) {
        console.log('MP YouTube Player: State changed. Event data:', event.data);
        console.log('MP YouTube Player: Current mp_isPlaying before update:', mp_isPlaying);

        let newStateIsPlaying = false;
        let shouldStartSim = false;
        let shouldStopSim = false;


        switch (event.data) {
            case YT.PlayerState.PLAYING:
                newStateIsPlaying = true;
                shouldStartSim = true; // Start simulation when playing
                console.log("MP YouTube Player: State is PLAYING.");
                break;
            case YT.PlayerState.PAUSED:
                newStateIsPlaying = false;
                shouldStopSim = true; // Stop simulation when paused
                console.log("MP YouTube Player: State is PAUSED.");
                break;
            case YT.PlayerState.ENDED:
                newStateIsPlaying = false;
                shouldStopSim = true; // Stop simulation when ended
                console.log("MP YouTube Player: State is ENDED.");
                mp_updateSeekBar(); // Ensure UI is updated to the end time (100%)
                mp_playNextSong(); // Automatically play the next song
                break;
            case YT.PlayerState.BUFFERING:
                console.log("MP YouTube Player: State is BUFFERING.");
                // The player is temporarily not playing, but mp_isPlaying might remain true
                // Don't explicitly change mp_isPlaying here, let PLAYING/PAUSED handle it.
                break;
            case YT.PlayerState.CUED:
            case -1: // Unstarted
                newStateIsPlaying = false;
                shouldStopSim = true; // Stop simulation if unstarted or cued
                console.log("MP YouTube Player: State is CUED or UNSTARTED.");
                 // Reset time/seek bar UI on load/cue
                 mp_updateSeekBar(); // This should handle resetting time/duration display based on player state (likely 0)
                break;
            default:
                 console.log("MP YouTube Player: Unknown state:", event.data);
                // Don't change mp_isPlaying for unknown states
                break;
        }

        // Update the global mp_isPlaying flag only if the state represents a definite playing/paused/ended state
        // Buffering/Cued/Unstarted states are transient or not actively playing
        if (event.data === YT.PlayerState.PLAYING || event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED) {
             mp_isPlaying = newStateIsPlaying;
             console.log("MP YouTube Player: Updated mp_isPlaying to:", mp_isPlaying);
        }


        // Manage the time update simulation interval
        if (shouldStartSim) {
            mp_startYouTubeTimeUpdateSimulation();
        } else if (shouldStopSim) {
             console.log("MP YouTube Player: Stopping timeupdate simulation interval.");
             if (youtubeTimeUpdateInterval) {
                  clearInterval(youtubeTimeUpdateInterval);
                  youtubeTimeUpdateInterval = null;
             }
        }


        // Update the UI controls based on the new state
        mp_updatePlaybackControls(); // Update buttons based on new state (using mp_isPlaying)
        mp_updatePlayingIndicator(); // Update list indicators (will be none if paused/ended/stopped)
    }

    function onYouTubePlayerError(event) {
        console.error('MP_DEBUG: onYouTubePlayerError - Raw Event Data:', event.data);
        // Attempt to get player reference safely, event.target might be the player
        const playerInstance = event && event.target;
        let videoUrl = "N/A";
        let playerStateAtError = "N/A";

        if (playerInstance && typeof playerInstance.getVideoUrl === 'function') {
            videoUrl = playerInstance.getVideoUrl();
        }
        if (playerInstance && typeof playerInstance.getPlayerState === 'function') {
            playerStateAtError = playerInstance.getPlayerState();
        }

        console.error('MP_DEBUG: onYouTubePlayerError - Video URL (if available):', videoUrl);
        console.error('MP_DEBUG: onYouTubePlayerError - Player State at Error (if available):', playerStateAtError);
        console.error('MP_DEBUG: onYouTubePlayerError - Current song metadata when error occurred:', mp_currentSong);

        let errorMessage = 'An error occurred with the YouTube player.';
        switch(event.data) {
            case 2: errorMessage = 'Invalid video ID or parameters. Check the videoId being loaded.'; break;
            case 5: errorMessage = 'HTML5 player error. This might be an issue with the video or browser.'; break;
            case 100: errorMessage = 'Video not found, private, or deleted.'; break;
            case 101: // Falls through
            case 150: errorMessage = 'Video cannot be played here due to embedding restrictions by the video owner.'; break;
            default: errorMessage = `An unknown error occurred with the YouTube player (Code: ${event.data}).`; break;
        }
        console.error("MP YouTube Player: Playback Error Details:", errorMessage, "Current Song:", mp_currentSong?.title || "N/A");
        showIndividualNotification("YouTube Playback Error", `Could not play "${mp_currentSong?.title || 'YouTube video'}": ${errorMessage}`, 10000);

        mp_isPlaying = false;
        mp_updatePlaybackControls();
        if (youtubeTimeUpdateInterval) {
            clearInterval(youtubeTimeUpdateInterval);
            youtubeTimeUpdateInterval = null;
            console.log("MP_DEBUG: Stopped YouTube time update simulation due to player error.");
        }
        mp_updateSeekBar();

        console.log("MP YouTube Player: Attempting to play the next song after error.");
        mp_playNextSong();
    }


    // Plays a song from the library view
    async function mp_playSongFromLibrary(songId) {
        console.log("MP: playSongFromLibrary, ID:", songId);
    
        const songToPlay = mp_musicLibrary.find(s => s.id === songId);
        if (!songToPlay) {
            console.error("MP: Song with ID", songId, "not found in library.");
            showIndividualNotification('Error', 'Song not found in library.', 4000);
            mp_stopPlaybackAndClearUI();
            return;
        }
    
        // Stop current playback and load the new song metadata into mp_currentSong
        await mp_loadSong(songToPlay); // This function prepares everything and INITIATES YouTube player loading
    
        // Update the queue index to the currently playing song
        const queueIndex = mp_musicQueue.findIndex(s => s.id === songId);
        if (queueIndex !== -1) {
             mp_currentQueueIndex = queueIndex;
             console.log("MP: Set queue from Songs list filter. Length:", mp_musicQueue.length, "Index:", mp_currentQueueIndex);
        } else {
             console.warn("MP: Loaded song not found in current queue.");
             mp_currentQueueIndex = -1; // Or handle as appropriate for your queue logic
        }
    
    
        // *** IMPORTANT MODIFICATION HERE ***
        // Do NOT call mp_togglePlayPause automatically for YouTube videos.
        // The initial playback for YouTube is handled by autoplay=1 and the onYouTubePlayerReady/onStateChange events.
        // mp_togglePlayPause should only be called by user interaction AFTER the player is ready.
    
        // Check if the song is NOT a YouTube video before calling togglePlayPause automatically
        if (!songToPlay.isYouTube) {
            console.log("MP: Automatically toggling play for local file.");
            mp_togglePlayPause(); // Call togglePlayPause only for local files if needed for initial play
        } else {
             console.log("MP: YouTube video loading initiated. Awaiting onYouTubePlayerReady for playback start.");
             // The onYouTubePlayerReady handler (and subsequent onStateChange) will manage setting mp_isPlaying
             // and updating the UI based on autoplay=1.
        }
    
        // The UI state (play/pause button icon, mp_isPlaying flag) should be updated
        // by the player's state change events (onStateChange for YouTube, 'play'/'pause' for audio).
    
    }

    // Starts playback of a specific playlist
    function mp_playPlaylist(playlistName) {
        console.log("MP: playPlaylist:", playlistName);

        const playlistSongIds = mp_playlists[playlistName];
        if (!playlistSongIds || playlistSongIds.length === 0) {
            alert(`MP: Playlist "${playlistName}" is empty.`);
            return;
        }

        // --- Check for directory handle if playlist contains local files ---
        const containsLocalFiles = playlistSongIds.some(id => {
            const song = mp_findSongById(id);
            return song && !song.isYouTube;
        });

        if (containsLocalFiles && !mp_currentDirectoryHandle) {
            console.warn("MP: Attempted to play playlist containing local files, but directory handle is not ready.");
            mp_updatePermissionUI(false, null); // Ensure prompt is visible without specific handle
            showIndividualNotification("Permission Required", "Select music folder or grant access to play local files in playlist.", 6000);
            // If permission is missing, we cannot load any local files, so perhaps don't set the queue?
            // Or set the queue but mp_loadSong will fail for local ones?
            // Let's set the queue, and mp_loadSong will handle individual failures.
        }
        // --- End handle check ---


        mp_currentQueue = [...playlistSongIds]; // Set queue to this playlist
        mp_currentSongIndex = 0; // Start from the beginning
        console.log(`MP: Set queue from Playlist "${playlistName}". Length: ${mp_currentQueue.length}.`);

        const firstSongMeta = mp_findSongById(mp_currentQueue[0]);
        if (firstSongMeta) {
            mp_loadSong(firstSongMeta); // Load and attempt play
        } else {
            console.error("MP: First song in playlist not found, ID:", mp_currentQueue[0]);
            mp_playNextSong(); // Try next one if first is missing
        }
    }

    // Starts audio playback
// Starts audio playback
    function mp_playAudio() {
        if (!mp_currentSong || !mp_audioPlayer || !mp_audioPlayer.src || mp_audioPlayer.src.startsWith('blob:') === false) {
            console.warn("MP: Cannot play - No current song, audio element, or valid src.", mp_currentSong, mp_audioPlayer?.src);
            return;
        }
        mp_audioPlayer.play()
            .then(() => {
                 mp_isPlaying = true;
                 mp_updatePlaybackControls(); // <-- Corrected function name
                 console.log("MP: Playback started or resumed.");
             })
            .catch(error => {
                // Common errors: NotAllowedError (autoplay), NotSupportedError
                console.error("MP: Playback failed:", error);
                mp_isPlaying = false;
                mp_updatePlaybackControls(); // <-- Corrected function name
                 // Don't alert here, rely on the 'error' event listener on the audio element for user feedback
                // alert(`MP: Playback Error - ${error.name}: ${error.message}`);
            });
    }

    // Pauses audio playback
    function mp_pauseAudio() {
        if(mp_audioPlayer) mp_audioPlayer.pause();
        mp_isPlaying = false;
        mp_updateMainPlaybackBarControls()
        console.log("MP: Playback paused.");
    }

    // Toggles play/pause state
    function mp_togglePlayPause() {
         console.log("MP_DEBUG: mp_togglePlayPause called.");
         console.trace("MP_DEBUG: Call Stack for mp_togglePlayPause");
         console.log("MP_DEBUG: Current state - mp_isPlaying:", mp_isPlaying, "Current Song ID:", mp_currentSong?.id, "Is YouTube:", mp_currentSong?.isYouTube);

         if (!mp_currentSong) {
              console.warn("MP_DEBUG: mp_togglePlayPause - Cannot toggle, no song loaded.");
              if (mp_musicLibrary.length > 0) {
                   console.log("MP_DEBUG: mp_togglePlayPause - Attempting to load the first song from the library.");
                   mp_playSongFromLibrary(mp_musicLibrary[0].id);
              }
              return;
         }

         if (mp_currentSong.isYouTube) {
              console.log("MP_DEBUG: mp_togglePlayPause - Called for YouTube song.");

              if (mp_youtubePlayer && typeof mp_youtubePlayer.getPlayerState === 'function') {
                  const playerState = mp_youtubePlayer.getPlayerState();
                  let playerStateMeaning = "Unknown";
                  switch(playerState) {
                      case -1: playerStateMeaning = "UNSTARTED"; break;
                      case YT.PlayerState.ENDED: playerStateMeaning = "ENDED"; break;
                      case YT.PlayerState.PLAYING: playerStateMeaning = "PLAYING"; break;
                      case YT.PlayerState.PAUSED: playerStateMeaning = "PAUSED"; break;
                      case YT.PlayerState.BUFFERING: playerStateMeaning = "BUFFERING"; break;
                      case YT.PlayerState.CUED: playerStateMeaning = "CUED"; break;
                      default: playerStateMeaning = `UNKNOWN_STATE_CODE_${playerState}`; break;
                  }
                  console.log(`MP_DEBUG: mp_togglePlayPause - YouTube player current state: ${playerState} (${playerStateMeaning})`);

                  // It's crucial that getPlayerState() is a valid function and returns a defined state.
                  // The API might not be ready if playerState is undefined or getPlayerState is not a function.
                  if (typeof playerState !== 'undefined' && playerState !== null) {
                      if (playerState === YT.PlayerState.PLAYING || playerState === YT.PlayerState.BUFFERING) {
                          console.log("MP_DEBUG: mp_togglePlayPause - Calling mp_youtubePlayer.pauseVideo()");
                          mp_youtubePlayer.pauseVideo();
                      } else { // Includes UNSTARTED, PAUSED, ENDED, CUED states
                          console.log("MP_DEBUG: mp_togglePlayPause - Calling mp_youtubePlayer.playVideo()");
                          mp_youtubePlayer.playVideo();
                      }
                  } else {
                      console.warn("MP_DEBUG: mp_togglePlayPause - getPlayerState() returned undefined or null. Player may not be fully initialized or in an error state. Player object:", mp_youtubePlayer);
                      showIndividualNotification('Warning', 'YouTube Player state is unclear. Please wait or try reloading the song.', 3500);
                  }
              } else {
                  console.warn("MP_DEBUG: mp_togglePlayPause - mp_youtubePlayer object is NOT VALID (null, undefined, or no getPlayerState method). mp_youtubePlayer:", mp_youtubePlayer);
                  showIndividualNotification('Error', 'YouTube player component is unavailable or failed. Try reloading the song.', 4000);
              }
         } else { // Handle Local Audio File
              console.log("MP_DEBUG: mp_togglePlayPause - Toggling Audio player state.");
              if (mp_audioPlayer) {
                  if (mp_audioPlayer.paused || mp_audioPlayer.ended) {
                      console.log("MP_DEBUG: mp_togglePlayPause - Calling audioPlayer.play()");
                      mp_audioPlayer.play().catch(error => {
                           console.error("MP_DEBUG: mp_togglePlayPause - Audio play failed:", error);
                           showIndividualNotification('Playback Error', `Could not play "${mp_currentSong.title || 'audio'}": ${error.message}`, 5000);
                           mp_isPlaying = false;
                           mp_updatePlaybackControls();
                       });
                  } else {
                      console.log("MP_DEBUG: mp_togglePlayPause - Calling audioPlayer.pause()");
                      mp_audioPlayer.pause();
                  }
              } else {
                  console.error("MP_CRITICAL_ERROR: mp_togglePlayPause - Audio player element (mp_audioPlayer) not found.");
              }
         }
    }
    
    function mp_playNextSong() {
        console.log("MP: playNextSong called.");

        if (!mp_currentQueue || mp_currentQueue.length === 0) {
            console.log("MP: Queue empty, cannot play next.");
            mp_stopPlaybackAndClearUI(); // Stop if queue is empty
            return;
        }

        let nextIndex = mp_currentSongIndex + 1;
        if (nextIndex >= mp_currentQueue.length) {
            nextIndex = 0; // Loop to start
             console.log("MP: Reached end of queue, looping to start.");
        }

        // Stop the currently playing song/video before loading the next one
         if (mp_currentSong) {
             if (mp_currentSong.isYouTube && mp_youtubePlayer && typeof mp_youtubePlayer.stopVideo === 'function') {
                 mp_youtubePlayer.stopVideo();
                  // Stop simulation interval
                  if (youtubeTimeUpdateInterval) clearInterval(youtubeTimeUpdateInterval); youtubeTimeUpdateInterval = null;
             } else if (!mp_currentSong.isYouTube && mp_audioPlayer) {
                 mp_audioPlayer.pause();
                 mp_audioPlayer.removeAttribute('src');
                 mp_audioPlayer.load();
                 if (mp_currentSong.tempUrl) {
                     URL.revokeObjectURL(mp_currentSong.tempUrl);
                     mp_currentSong.tempUrl = null;
                 }
             }
             // mp_isPlaying state will be updated by the next song's play event
             mp_isPlaying = false; // Assume not playing until the next song starts
         }


        const nextSongId = mp_currentQueue[nextIndex];
        const nextSongMeta = mp_findSongById(nextSongId);

        if (nextSongMeta) {
            mp_currentSongIndex = nextIndex;
            console.log(`MP: Playing next song (Index ${nextIndex}): ${nextSongMeta.title || nextSongMeta.fileName}`);

            // *** Check for directory handle before loading local file ***
             if (!nextSongMeta.isYouTube && !mp_currentDirectoryHandle) {
                 console.warn("MP: Directory handle not available for next local song. Skipping.");
                 mp_updatePermissionUI(false, null); // Ensure prompt is visible
                 // Remove the missing song from the queue and try again
                 mp_currentQueue.splice(nextIndex, 1);
                 // If the removed song was before the current index, the index needs to adjust.
                 // If the removed song was at nextIndex (which is current + 1), and nextIndex > current,
                 // then the song at current will remain at current. The 'next' song is now the one
                 // that was originally at nextIndex + 1. So currentSongIndex doesn't need to change.
                 // However, if the queue is now empty, stop playback.
                 if (mp_currentQueue.length === 0) {
                     mp_currentSongIndex = -1;
                     mp_stopPlaybackAndClearUI();
                     return;
                 }
                 console.log("MP: Retrying playNextSong after removing missing local song.");
                 mp_playNextSong(); // Recursive call
                 return; // Exit this call
             }
            // *** End handle check ***


            mp_loadSong(nextSongMeta); // Load the next song
        } else {
            console.warn("MP: Next song ID not found in library, removing from queue:", nextSongId);
            // Use splice to remove the missing song ID from the queue
            mp_currentQueue.splice(nextIndex, 1);
            // Adjust current index if the removed item was before it.
            // If nextIndex was after currentSongIndex, currentSongIndex doesn't need to change relative to the song it's on.
            // However, if nextIndex was 0 (looping back) and we remove the first song, the new first song is now at index 0,
            // and if the current song was the last one, the new 'next' song will be index 0.
            // For simplicity, if we remove an item, just try playing the "next" song again.
             if (mp_currentQueue.length === 0) {
                 mp_currentSongIndex = -1;
                 mp_stopPlaybackAndClearUI();
                 return;
             }
            console.log("MP: Retrying playNextSong after removing missing ID.");
             mp_playNextSong(); // Recursive call
        }
    }


    // Plays the previous song or restarts current
     function mp_playPrevSong() {
        console.log("MP: playPrevSong called.");

        if (!mp_currentQueue || mp_currentQueue.length === 0) {
            console.log("MP: Queue empty, cannot play previous.");
            mp_stopPlaybackAndClearUI(); // Stop if queue is empty
            return;
        }

        // Restart current song if played for more than ~3 seconds
        let restartCurrent = false;
        if (mp_currentSong) {
            if (mp_currentSong.isYouTube && mp_youtubePlayer && typeof mp_youtubePlayer.getCurrentTime === 'function' && mp_youtubePlayer.getCurrentTime() > 3) {
                 restartCurrent = true;
                 console.log("MP: Restarting current YouTube song.");
                 mp_youtubePlayer.seekTo(0, true); // Seek to start and play
                 mp_isPlaying = true; // Ensure state is playing
                 mp_updatePlaybackControls(); // Update UI
                  // Ensure simulation is running
                 mp_startYouTubeTimeUpdateSimulation();
                 return; // Exit the function after restarting
            } else if (!mp_currentSong.isYouTube && mp_audioPlayer && mp_audioPlayer.currentTime > 3) {
                 restartCurrent = true;
                 console.log("MP: Restarting current Audio song.");
                 mp_audioPlayer.currentTime = 0;
                 mp_playAudio(); // Ensure playback state is correct
                 return; // Exit the function after restarting
            }
        }


        // If not restarting current song, proceed to previous song in queue
        let prevIndex = mp_currentSongIndex - 1;
        if (prevIndex < 0) {
            prevIndex = mp_currentQueue.length - 1; // Loop to end
             console.log("MP: Reached start of queue, looping to end.");
        }

         // Stop the currently playing song/video before loading the next one
         if (mp_currentSong) {
             if (mp_currentSong.isYouTube && mp_youtubePlayer && typeof mp_youtubePlayer.stopVideo === 'function') {
                 mp_youtubePlayer.stopVideo();
                  // Stop simulation interval
                  if (youtubeTimeUpdateInterval) clearInterval(youtubeTimeUpdateInterval); youtubeTimeUpdateInterval = null;
             } else if (!mp_currentSong.isYouTube && mp_audioPlayer) {
                 mp_audioPlayer.pause();
                 mp_audioPlayer.removeAttribute('src');
                 mp_audioPlayer.load();
                 if (mp_currentSong.tempUrl) {
                     URL.revokeObjectURL(mp_currentSong.tempUrl);
                     mp_currentSong.tempUrl = null;
                 }
             }
             // mp_isPlaying state will be updated by the next song's play event
             mp_isPlaying = false; // Assume not playing until the next song starts
         }


        const prevSongId = mp_currentQueue[prevIndex];
        const prevSongMeta = mp_findSongById(prevSongId);

        if (prevSongMeta) {
            mp_currentSongIndex = prevIndex;
            console.log(`MP: Playing previous song (Index ${prevIndex}): ${prevSongMeta.title || prevSongMeta.fileName}`);

            // *** Check for directory handle before loading local file ***
             if (!prevSongMeta.isYouTube && !mp_currentDirectoryHandle) {
                 console.warn("MP: Directory handle not available for previous local song. Skipping.");
                 mp_updatePermissionUI(false, null); // Ensure prompt is visible
                 // Remove the missing song from the queue and try again
                 mp_currentQueue.splice(prevIndex, 1);
                 // If the removed song was before the current index, adjust the current index
                  if (prevIndex < mp_currentSongIndex) {
                       mp_currentSongIndex--;
                  }
                 console.log("MP: Retrying playPrevSong after removing missing local song.");
                 mp_playPrevSong(); // Recursive call
                 return; // Exit this call
             }
            // *** End handle check ***


            mp_loadSong(prevSongMeta); // Load the previous song
        } else {
            console.warn("MP: Previous song ID not found in library, removing from queue:", prevSongId);
             // Use splice to remove the missing song ID from the queue
            mp_currentQueue.splice(prevIndex, 1);
            // Adjust current index if the removed item was before it
            // We removed prevIndex. If prevIndex was < currentSongIndex, currentSongIndex needs to decrease.
            // However, since we *just* calculated prevIndex from currentSongIndex - 1, if the item at prevIndex
            // is removed, the new item at currentSongIndex (which was originally at currentSongIndex) will still be there.
            // So, no need to adjust currentSongIndex *unless* the queue becomes empty.
             if (mp_currentQueue.length === 0) {
                 mp_currentSongIndex = -1;
                 mp_stopPlaybackAndClearUI();
                 return;
             }
             // Otherwise, try playing the song at the calculated prevIndex again (which is now a different song)
            console.log("MP: Retrying playPrevSong after removing missing ID.");
             mp_playPrevSong(); // Recursive call
        }
    }


    // Updates playback control buttons/UI state for both main bar and hover overlay
    function mp_updatePlaybackControls() {
        // Update Main Playback Bar Controls (if initialized)
        if (mp_playbackBarInitialized) {
            // Ensure play/pause button exists before updating
            if (mp_playPauseButton) {
                mp_playPauseButton.innerHTML = mp_isPlaying ? '<i class="fas fa-pause"></i>' : '<i class="fas fa-play"></i>';
                mp_playPauseButton.title = mp_isPlaying ? 'Pause' : 'Play';
                // Disable play/pause if no songs are in the library at all
                mp_playPauseButton.disabled = (mp_musicLibrary.length === 0);
            }
            // Enable prev/next only if there's a valid queue with more than one song
            const canNavigate = mp_currentQueue && mp_currentQueue.length > 1;
             // Ensure prev/next buttons exist before updating
            if (mp_prevButton) mp_prevButton.disabled = !canNavigate;
            if (mp_nextButton) mp_nextButton.disabled = !canNavigate;
        } else {
             console.warn("MP: Main Playback Bar not initialized, skipping button update.");
        }


        // --- Update Hover Overlay Controls (if initialized AND visible) ---
        // Check if the hover overlay is initialized before accessing its elements
        if (mp_hoverOverlayInitialized && audioControlHoverOverlay && audioControlHoverOverlay.style.display === 'flex') {
            console.log("MP: Updating hover overlay controls.");
             // Ensure buttons exist before updating
            if (hoverOverlayPlayPauseBtn) {
                 hoverOverlayPlayPauseBtn.innerHTML = mp_isPlaying ? '<i class="fas fa-pause"></i>' : '<i class="fas fa-play"></i>';
                 hoverOverlayPlayPauseBtn.title = mp_isPlaying ? 'Pause' : 'Play';
                  hoverOverlayPlayPauseBtn.disabled = (mp_musicLibrary.length === 0);
            }
            const canNavigate = mp_currentQueue && mp_currentQueue.length > 1;
             // Ensure prev/next buttons exist before updating
            if (hoverOverlayBackwardBtn) hoverOverlayBackwardBtn.disabled = !canNavigate;
            if (hoverOverlayForwardBtn) hoverOverlayForwardBtn.disabled = !canNavigate;
             // Note: Hover overlay doesn't need mp_updatePlayingIndicator as it's not a list of songs
        } else {
            // Optional: log if overlay is not initialized or not visible
            // if (!mp_hoverOverlayInitialized) console.log("MP: Hover Overlay not initialized, skipping button update.");
            // else if (audioControlHoverOverlay && audioControlHoverOverlay.style.display !== 'flex') console.log("MP: Hover Overlay not visible, skipping button update.");
        }
        // --- End Update Hover Overlay ---

        mp_updatePlayingIndicator(); // Ensure list indicators are updated (this only affects the main song lists)
    }

    // Formats time in seconds to M:SS
    function mp_formatTime(totalSeconds) {
        if (isNaN(totalSeconds) || totalSeconds < 0) return '0:00';
        const minutes = Math.floor(totalSeconds / 60);
        const secs = Math.floor(totalSeconds % 60);
        return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
    }


    // Updates seek bar progress and time display for both main bar and hover overlay
// isSeeking is typically local to mp_initializePlaybackBar
// isSeekingHover should be a variable accessible here, maybe declared globally
// let isSeekingHover = false; // Example global declaration

// Updates the main playback bar's time and seek bar
    function mp_updateSeekBar() {
         // console.log("MP: mp_updateSeekBar called."); // Can be noisy, uncomment for debugging

         if (!mp_currentSong) {
             // No song loaded, reset everything
             if(mp_currentTime) mp_currentTime.textContent = mp_formatTime(0);
             if(mp_totalDuration) mp_totalDuration.textContent = mp_formatTime(0);
             if(mp_seekBar) mp_seekBar.value = 0;
             if(mp_seekBar) mp_seekBar.max = 0; // Reset max value
             return;
         }

         let currentTime = 0;
         let duration = 0;

         if (mp_currentSong.isYouTube && mp_youtubePlayer && typeof mp_youtubePlayer.getCurrentTime === 'function') {
             // Get time from YouTube player
             currentTime = mp_youtubePlayer.getCurrentTime() || 0; // Use 0 if null/undefined
             duration = mp_youtubePlayer.getDuration() || 0; // Use 0 if null/undefined

         } else if (!mp_currentSong.isYouTube && mp_audioPlayer) {
             // Get time from HTML Audio player
             currentTime = mp_audioPlayer.currentTime || 0; // Use 0 if null/undefined
             duration = mp_audioPlayer.duration || 0; // Use 0 if NaN/Infinity/undefined - check explicitly for NaN/Infinity might be safer
              if (isNaN(duration) || !isFinite(duration)) { // Check for invalid audio duration
                 duration = 0;
             }
         } else {
              // No active player found for the current song type
              console.warn("MP: mp_updateSeekBar called but no valid player instance found for current song type.");
             // Reset UI as a fallback
             if(mp_currentTime) mp_currentTime.textContent = mp_formatTime(0);
             if(mp_totalDuration) mp_totalDuration.textContent = mp_formatTime(0);
             if(mp_seekBar) mp_seekBar.value = 0;
             if(mp_seekBar) mp_seekBar.max = 0;
              return;
         }


         // Update current time display
         if(mp_currentTime) mp_currentTime.textContent = mp_formatTime(currentTime);

         // Update total duration display only if duration is valid and not already displayed
         // This prevents flickering if duration changes slightly or is updated late
          if (duration > 0 && duration !== Infinity) {
              if(mp_totalDuration && mp_totalDuration.textContent !== mp_formatTime(duration)) {
                 mp_totalDuration.textContent = mp_formatTime(duration);
             }
              // Also set the max value of the seek bar based on duration for more accurate scrubbing
              if(mp_seekBar && mp_seekBar.max !== duration) {
                  mp_seekBar.max = duration; // Set max to duration in seconds
              }
         } else {
              // If duration is still not available/valid, show a placeholder or 0:00
              if(mp_totalDuration) mp_totalDuration.textContent = mp_formatTime(0); // Or '--:--'
              if(mp_seekBar) mp_seekBar.max = 0; // Reset max
         }


         // Update seek bar slider position only if the user is NOT dragging it
         // Also ensure duration is valid to prevent division by zero or incorrect calculations
         if (!isSeeking && duration > 0 && duration !== Infinity) {
             // Calculate slider value based on current time relative to duration
             // If using mp_seekBar.max = duration, then mp_seekBar.value = currentTime is sufficient
              if(mp_seekBar) {
                  mp_seekBar.value = currentTime;
              }
             // If mp_seekBar.max is still 100 (default), calculate percentage:
             // if(mp_seekBar) {
             //     mp_seekBar.value = (currentTime / duration) * 100;
             // }
         }
         // If isSeeking is true, the seek bar's value is being set by the input listener during dragging
         // The time display (mp_currentTime) is updated in the input listener as well for immediate feedback.

    }

    // Helper function to format time (you likely already have this)
    function mp_formatTime(seconds) {
        if (isNaN(seconds) || seconds < 0) {
            return '0:00';
        }
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        const formattedSeconds = remainingSeconds < 10 ? '0' + remainingSeconds : remainingSeconds;
        return `${minutes}:${formattedSeconds}`;
    }



    // Updates volume slider and mute button UI
    function mp_updateVolumeControls() {
         // Ensure playback bar elements exist for the main bar
         if (!mp_playbackBarInitialized || !mp_muteButton || !mp_volumePercentage || !mp_volumeSlider) {
              console.warn("MP: Main Volume control elements not initialized, skipping update.");
              // Still try to update hover overlay if it exists
         }

         let isMuted = false;
         let volume = 1; // Default to 100% if no player state

         // Get volume and mute state from the active player or default
         if (mp_currentSong?.isYouTube && mp_youtubePlayer && typeof mp_youtubePlayer.isMuted === 'function' && typeof mp_youtubePlayer.getVolume === 'function') {
             isMuted = mp_youtubePlayer.isMuted();
             volume = mp_youtubePlayer.getVolume() / 100; // YouTube volume is 0-100, convert to 0-1
         } else if (!mp_currentSong?.isYouTube && mp_audioPlayer && !isNaN(mp_audioPlayer.volume)) {
             isMuted = mp_audioPlayer.muted;
             volume = mp_audioPlayer.volume; // Audio volume is 0-1
         } else {
             // No active player with valid volume info, default to initial state
              isMuted = false; // Assume not muted
              volume = 1; // Assume 100%
         }

         // --- Update Main Playback Bar Volume Controls ---
         if (mp_muteButton && mp_volumePercentage && mp_volumeSlider) { // Check elements exist
             if (isMuted || volume <= 0.001) { // Use a small threshold for volume being effectively zero
                 mp_muteButton.innerHTML = '<i class="fas fa-volume-mute"></i>';
                 mp_muteButton.title = 'Unmute';
                 mp_volumePercentage.textContent = `0%`;
             } else {
                 mp_muteButton.innerHTML = '<i class="fas fa-volume-up"></i>'; // Assume volume > 0 means 'up' or 'down' based on level
                 // You could add logic here for volume-down icon if volume is low (e.g., volume < 0.5)
                 mp_muteButton.title = 'Mute';
                 mp_volumePercentage.textContent = `${Math.round(volume * 100)}%`;
             }

             // Update slider value *visually* based on the player's volume
             // Do NOT set the player volume here, as this function is for updating the UI *from* the player state.
             // The slider's 'input' event listener sets the player volume.
             mp_volumeSlider.value = volume; // Always set slider value based on current volume
         }

        // Note: The hover overlay currently doesn't have volume controls, so no update needed there.
    }

    // Function to set volume on the active player (called by slider input)
    function mp_setVolume(volume) { // Volume is expected to be 0-1
         if (mp_currentSong?.isYouTube && mp_youtubePlayer && typeof mp_youtubePlayer.setVolume === 'function') {
             mp_youtubePlayer.setVolume(volume * 100); // Convert 0-1 to 0-100 for YouTube API
         } else if (!mp_currentSong?.isYouTube && mp_audioPlayer) {
             mp_audioPlayer.volume = volume;
         } else {
              console.warn("MP: Attempted to set volume, but no active player found.");
         }
          // Ensure muted state is correct if volume changes
         if (volume > 0.001) { // Use threshold
              mp_setMuted(false); // Unmute if volume is increased above near-zero
         }
         // Update the UI immediately after setting volume
         mp_updateVolumeControls();
    }

    // Function to set muted state on the active player (called by mute button click)
    function mp_setMuted(isMuted) {
         if (mp_currentSong?.isYouTube && mp_youtubePlayer && typeof mp_youtubePlayer.mute === 'function' && typeof mp_youtubePlayer.unMute === 'function') {
             if (isMuted) {
                 mp_youtubePlayer.mute();
             } else {
                 mp_youtubePlayer.unMute();
             }
         } else if (!mp_currentSong?.isYouTube && mp_audioPlayer) {
             mp_audioPlayer.muted = isMuted;
         } else {
              console.warn("MP: Attempted to set muted state, but no active player found.");
         }
         // Update the UI immediately after setting muted state
         mp_updateVolumeControls();
    }

    // --- Recently Played Logic ---
    function mp_addToRecentlyPlayed(songId) {
        if (!songId) return;
        mp_recentlyPlayed = mp_recentlyPlayed.filter(id => id !== songId);
        mp_recentlyPlayed.unshift(songId);
        if (mp_recentlyPlayed.length > MP_MAX_RECENTLY_PLAYED) {
            mp_recentlyPlayed = mp_recentlyPlayed.slice(0, MP_MAX_RECENTLY_PLAYED);
        }
        mp_saveDataToLocalStorage(); // Save metadata
        // Render only if page is active
         if (mp_isInitialized && document.getElementById('mp_recentlyPlayedList')) {
             mp_renderRecentlyPlayed();
         }
    }

    // --- Sets up listeners and gets references for the music hover overlay ---
    // --- Sets up listeners and gets references for the music hover overlay ---
    function initializeMusicHoverOverlay() {
        if (mp_hoverOverlayInitialized) return; // Run only once
        console.log("MP: Initializing Music Hover Overlay Listeners");

        // Get references AFTER DOM is loaded
        musicIconAndHoverContainer = document.getElementById('musicIconAndHoverContainer');
        audioControlHoverOverlay = document.getElementById('audioControlHoverOverlay');
        hoverOverlaySongTitle = document.getElementById('hoverOverlaySongTitle');
        // hoverOverlayNextSongLabel = document.getElementById('hoverOverlayNextSongLabel'); // Static label, no need for JS ref
        hoverOverlayBackwardBtn = document.getElementById('hoverOverlayBackwardBtn');
        hoverOverlayPlayPauseBtn = document.getElementById('hoverOverlayPlayPauseBtn');
        hoverOverlayForwardBtn = document.getElementById('hoverOverlayForwardBtn');
        hoverOverlayCurrentTime = document.getElementById('hoverOverlayCurrentTime');
        hoverOverlayScroller = document.getElementById('hoverOverlayScroller');
        hoverOverlayTotalDuration = document.getElementById('hoverOverlayTotalDuration');

        // Check if essential elements were found
        if (!musicIconAndHoverContainer || !audioControlHoverOverlay || !hoverOverlaySongTitle ||
            !hoverOverlayBackwardBtn || !hoverOverlayPlayPauseBtn || !hoverOverlayForwardBtn ||
            !hoverOverlayCurrentTime || !hoverOverlayScroller || !hoverOverlayTotalDuration) {
            console.error("MP: Failed to find one or more essential hover overlay elements. Cannot initialize overlay fully.");
            return; // Stop initialization
        }

        // --- Add Hover Listeners to the Container ---
        let hideOverlayTimeout;

        musicIconAndHoverContainer.addEventListener('mouseenter', () => {
            // Only show if a song is currently loaded or playing/paused
            // Check if mp_currentSong exists or if the audio player has a source
             if (mp_currentSong || (mp_audioPlayer && mp_audioPlayer.src) || (mp_youtubePlayer && typeof mp_youtubePlayer.getPlayerState === 'function' && mp_youtubePlayer.getPlayerState() !== -1)) {
                 clearTimeout(hideOverlayTimeout); // Cancel any pending hide
                 audioControlHoverOverlay.style.display = 'flex'; // Show the overlay (using flex from CSS)

                 // --- *** Call Update Functions Immediately on Showing Overlay *** ---
                 console.log("MP: Hover Overlay shown. Updating content.");
                 // Update Song Title
                 if (hoverOverlaySongTitle && mp_currentSong) {
                      // Use fallback titles in case metadata is incomplete
                      const songTitleDisplay = `${mp_currentSong.artist || 'Unknown Artist'} - ${mp_currentSong.title || 'Unknown Title'}`;
                      hoverOverlaySongTitle.textContent = songTitleDisplay;
                      hoverOverlaySongTitle.title = songTitleDisplay;
                 } else if (hoverOverlaySongTitle) {
                     hoverOverlaySongTitle.textContent = "No song playing";
                     hoverOverlaySongTitle.title = "";
                 }

                 // Update Button States (Play/Pause, Next/Prev enabled/disabled)
                 mp_updatePlaybackControls(); // This function updates buttons for both bars

                 // Update Time and Scroller (will get time/duration from the active player)
                 mp_updateSeekBar(); // This function updates time and scroller for both bars if visible

                 // Ensure Total Duration is set if known (handled by mp_updateSeekBar now)
                 // if (mp_audioPlayer && !isNaN(mp_audioPlayer.duration) && mp_audioPlayer.duration > 0) {
                 //     if(hoverOverlayTotalDuration) hoverOverlayTotalDuration.textContent = mp_formatTime(mp_audioPlayer.duration);
                 // } else {
                 //     if(hoverOverlayTotalDuration) hoverOverlayTotalDuration.textContent = '0:00'; // Reset if no duration yet
                 // }
                 // --- *** End Update on Showing Overlay *** ---

            } else {
                 console.log("MP Hover Overlay: Not showing overlay, no song loaded or playing.");
                 // Optionally hide it explicitly if it was somehow left visible but no song is playing/paused
                 audioControlHoverOverlay.style.display = 'none';
            }
        });

        musicIconAndHoverContainer.addEventListener('mouseleave', () => {
            // Add a small delay before hiding, allows moving mouse onto the overlay
            hideOverlayTimeout = setTimeout(() => {
                audioControlHoverOverlay.style.display = 'none'; // Hide the overlay
            }, 200); // 200ms delay
        });

        // Prevent the timeout from hiding the overlay if the mouse enters the overlay itself
        audioControlHoverOverlay.addEventListener('mouseenter', () => {
            clearTimeout(hideOverlayTimeout);
        });

        audioControlHoverOverlay.addEventListener('mouseleave', () => {
            hideOverlayTimeout = setTimeout(() => {
                 audioControlHoverOverlay.style.display = 'none';
             }, 200); // Keep the same delay
        });


        // --- Add Control Button Listeners for the Overlay ---
        hoverOverlayPlayPauseBtn.addEventListener('click', mp_togglePlayPause);
        hoverOverlayBackwardBtn.addEventListener('click', mp_playPrevSong);
        hoverOverlayForwardBtn.addEventListener('click', mp_playNextSong);

        // --- Add Scroller Listener for the Overlay ---
        // 'isSeekingHover' flag should be accessible to this function and its listeners.
        // If it's not declared outside, declare it here:
         // let isSeekingHover = false; // Assuming it's local as per your original snippet or declared above


         hoverOverlayScroller.addEventListener('mousedown', () => { isSeekingHover = true; }); // Start seeking flag
         hoverOverlayScroller.addEventListener('mouseup', () => { isSeekingHover = false; }); // End seeking flag
         hoverOverlayScroller.addEventListener('touchstart', () => { isSeekingHover = true; }); // Mobile touch start
         hoverOverlayScroller.addEventListener('touchend', () => { isSeekingHover = false; }); // Mobile touch end


        hoverOverlayScroller.addEventListener('input', () => {
             // Only update time if the hover seek bar is being dragged AND a song is loaded
             if (!mp_currentSong || !mp_audioPlayer && !mp_youtubePlayer) return; // Check for loaded song/player
             // isSeekingHover = true; // Set seeking flag for this scroller (handled by mouse/touch events)

             let duration = 0;
              // Get duration from the active player
              if (mp_currentSong.isYouTube && mp_youtubePlayer && typeof mp_youtubePlayer.getDuration === 'function') {
                  duration = mp_youtubePlayer.getDuration();
              } else if (!mp_currentSong.isYouTube && mp_audioPlayer && !isNaN(mp_audioPlayer.duration)) {
                  duration = mp_audioPlayer.duration;
              } else {
                   console.warn("MP: Hover seek bar input, but duration not available from active player.");
                   return; // Cannot seek if duration is unknown
              }


             if (duration <= 0) return;

             const seekTime = (hoverOverlayScroller.value / 100) * duration; // Assuming max=100

             // Set current time/seek for the active player
             if (mp_currentSong.isYouTube && mp_youtubePlayer && typeof mp_youtubePlayer.seekTo === 'function') {
                 mp_youtubePlayer.seekTo(seekTime, true);
                  // Ensure player is playing after seeking if it was before or if it was paused by seeking
                  if (mp_youtubePlayer.getPlayerState() !== YT.PlayerState.PLAYING && mp_youtubePlayer.getPlayerState() !== YT.PlayerState.BUFFERING) {
                       mp_youtubePlayer.playVideo();
                  }
             } else if (!mp_currentSong.isYouTube && mp_audioPlayer && !isNaN(seekTime)) {
                 mp_audioPlayer.currentTime = seekTime;
                  // Ensure player is playing after seeking if it was before or if it was paused by seeking
                  if (mp_audioPlayer.paused && !mp_audioPlayer.ended) {
                       mp_audioPlayer.play().catch(error => console.error("MP: Audio play after hover seek failed:", error));
                  }
             }


              // Update time display immediately while scrubbing (hover overlay)
             if(hoverOverlayCurrentTime) hoverOverlayCurrentTime.textContent = mp_formatTime(seekTime);
             // The mp_updateSeekBar function will handle syncing the main seek bar on the next timeupdate event
           });

         // 'change' listener (fires after user releases mouse/touch)
          hoverOverlayScroller.addEventListener('change', () => {
               // isSeekingHover = false; // Clear seeking flag for this scroller (handled by mouseup/touchend)
               // The timeupdate listener will sync both bars after scrubbing stops
           });


        mp_hoverOverlayInitialized = true;
        console.log("MP: Music Hover Overlay Initialized.");
    }

    // --- Playlist Management & Modals ---
    // (Keep your existing mp_populateCreatePlaylistModalSongs, mp_openCreatePlaylistModal,
    // mp_createNewPlaylist, mp_deleteCurrentPlaylist, mp_removeSongFromPlaylist,
    // mp_populateViewPlaylistModal, mp_openViewPlaylistModal, mp_openModal, mp_closeModal,
    // mp_openRemoveSongsModal, mp_removeSelectedSongs functions here...)
    // ... (Make sure they are included) ...
function mp_populateCreatePlaylistModalSongs(filter = '') { // Added filter parameter
         const modalList = document.getElementById('mp_createPlaylistSongList');
         if (!modalList) return;
         modalList.innerHTML = ''; // Clear previous list

         const lowerFilter = filter.toLowerCase(); // Convert filter to lowercase

         // Filter the library based on the search input
         const filteredLibrary = mp_musicLibrary.filter(song => {
             // Ensure properties exist before calling toLowerCase or includes
             const titleMatch = song.title && song.title.toLowerCase().includes(lowerFilter);
             const artistMatch = song.artist && song.artist.toLowerCase().includes(lowerFilter);
             const fileNameMatch = song.fileName && song.fileName.toLowerCase().includes(lowerFilter); // Include filename search (check if exists)
             const videoIdMatch = song.isYouTube && song.videoId && song.videoId.toLowerCase().includes(lowerFilter); // Search by video ID for YouTube

             return titleMatch || artistMatch || fileNameMatch || videoIdMatch;
         }).sort((a, b) => {
             // Handle potential missing artist/title when sorting
             const nameA = `${a.artist || ''} - ${a.title || ''}`.trim();
             const nameB = `${b.artist || ''} - ${b.title || ''}`.trim();
             // Fallback to fileName if both artist and title are missing, or for YouTube use videoId if artist/title missing?
              const sortKeyA = nameA || a.fileName || a.videoId || a.id;
              const sortKeyB = nameB || b.fileName || b.videoId || b.id;

             return sortKeyA.localeCompare(sortKeyB);
         });


         if (filteredLibrary.length === 0) {
              const message = mp_musicLibrary.length === 0
                 ? 'No songs in library.'
                 : (filter ? 'No songs match search.' : 'No songs in library.'); // Message based on whether filter is active or library is empty
             modalList.innerHTML = `<p class="placeholder-text">${message}</p>`;
         } else {
             const fragment = document.createDocumentFragment();
             filteredLibrary.forEach(song => {
                 const div = document.createElement('div');
                 div.className = 'list-item';
                 div.setAttribute('role', 'option'); // Add ARIA role
                 div.setAttribute('tabindex', '0'); // Make keyboard focusable
                 div.style.cursor = 'pointer'; // Make item clickable
                 div.dataset.songId = song.id; // Store the song ID on the list item

                  // Add YouTube icon if it's a YouTube song
                  if (song.isYouTube) {
                      const youtubeIcon = document.createElement('i');
                      youtubeIcon.className = 'fab fa-youtube youtube-icon'; // Assuming you have Font Awesome loaded
                      youtubeIcon.title = 'YouTube'; // Tooltip
                      div.appendChild(youtubeIcon);
                  }

                 // Create span for the text content
                 const textSpan = document.createElement('span');
                 textSpan.textContent = `${escapeHtml(song.artist || 'Unknown Artist')} - ${escapeHtml(song.title || 'Unknown Title')}`; // Add fallback text and escape HTML
                 textSpan.title = `${escapeHtml(song.artist || 'Unknown Artist')} - ${escapeHtml(song.title || 'Unknown Title')} (${song.isYouTube ? 'YouTube' : escapeHtml(song.fileName || 'Unknown File')})`; // Update title logic and escape HTML
                 textSpan.style.flexGrow = '1';
                 textSpan.style.overflow = 'hidden';
                 textSpan.style.textOverflow = 'ellipsis';
                 textSpan.style.whiteSpace = 'nowrap';

                 // Append the text span
                 div.appendChild(textSpan);

                 // Add click listener to the div (list item) to toggle selection highlight
                 div.addEventListener('click', () => {
                     div.classList.toggle('selected-for-action'); // Toggle the new highlight class
                      // Optional: Provide visual/aria feedback for selection
                      if (div.classList.contains('selected-for-action')) {
                          div.setAttribute('aria-selected', 'true');
                      } else {
                           div.setAttribute('aria-selected', 'false');
                      }
                 });

                 // Add keyboard accessibility for Enter/Space keys to select
                 div.addEventListener('keydown', (event) => {
                     if (event.key === 'Enter' || event.key === ' ') {
                          event.preventDefault(); // Prevent default space/enter behavior (like scrolling)
                          event.target.click(); // Simulate a click to toggle selection
                     }
                 });


                 fragment.appendChild(div);
             });
             modalList.appendChild(fragment);
              // Optional: Focus the first item for keyboard navigation
              if (filteredLibrary.length > 0 && modalList.firstChild) {
                   modalList.firstChild.focus();
              }
         }
          console.log(`MP: Populated Create Playlist modal song list with ${filteredLibrary.length} songs (filter: "${filter}").`);
     }

    function mp_openCreatePlaylistModal() {
        const nameInput = document.getElementById('mp_newPlaylistName');
        if (nameInput) nameInput.value = '';
    
        // Get the search input for the modal
        const searchInput = document.getElementById('mp_createPlaylistSearch');
        if (searchInput) searchInput.value = ''; // Clear search input on open
    
        mp_populateCreatePlaylistModalSongs(); // Populate with no filter initially
        mp_openModal('mp_createPlaylistModal');
    }

    function mp_createNewPlaylist() {
        const nameInput = document.getElementById('mp_newPlaylistName');
        const name = nameInput ? nameInput.value.trim() : '';
        if (!name) { alert("MP: Please enter a playlist name."); return; }
        if (mp_playlists[name]) { alert(`MP: Playlist "${name}" already exists.`); return; }
    
        // Find list items with the 'selected-for-action' class
        const selectedListItems = document.querySelectorAll('#mp_createPlaylistSongList .list-item.selected-for-action');
        // Get the song IDs from the data-song-id attribute
        const initialSongIds = Array.from(selectedListItems).map(item => item.dataset.songId);
    
        mp_playlists[name] = initialSongIds;
        mp_saveDataToLocalStorage();
        if(mp_isInitialized && document.getElementById('mp_playlistsList')) mp_renderPlaylists();
        mp_closeModal('mp_createPlaylistModal');
        console.log(`MP: Playlist "${name}" created with ${initialSongIds.length} songs.`);
    }

    function mp_deleteCurrentPlaylist() {
        if (!mp_currentPlaylistNameForView) return;
        if (confirm(`MP: Delete playlist "${mp_currentPlaylistNameForView}"?`)) {
            delete mp_playlists[mp_currentPlaylistNameForView];
            mp_saveDataToLocalStorage();
             if(mp_isInitialized && document.getElementById('mp_playlistsList')) mp_renderPlaylists();
            mp_closeModal('mp_viewPlaylistModal');
            console.log(`MP: Playlist "${mp_currentPlaylistNameForView}" deleted.`);
            mp_currentPlaylistNameForView = null;
        }
    }

    function mp_removeSongFromPlaylist(playlistName, songId) {
        if (!mp_playlists[playlistName]) return;
        mp_playlists[playlistName] = mp_playlists[playlistName].filter(id => id !== songId);
        mp_saveDataToLocalStorage();
        if (mp_isInitialized && document.getElementById('mp_playlistsList')) mp_renderPlaylists(); // Update counts
        // Refresh modal if open
        const viewModal = document.getElementById('mp_viewPlaylistModal');
        if (viewModal?.style.display === 'flex' && mp_currentPlaylistNameForView === playlistName) {
            mp_populateViewPlaylistModal(playlistName);
        }
    }

    function mp_populateViewPlaylistModal(playlistName) {
        const modalList = document.getElementById('mp_viewPlaylistModalList');
        if (!modalList) return;
        modalList.innerHTML = '';
        const songIds = mp_playlists[playlistName];
        if (!songIds || songIds.length === 0) {
            modalList.innerHTML = '<p class="placeholder-text">This playlist is empty.</p>'; return;
        }
        const songsInPlaylist = songIds.map(id => mp_findSongById(id)).filter(song => song)
                               .sort((a, b) => `${a.artist} - ${a.title}`.localeCompare(`${b.artist} - ${b.title}`));
        songsInPlaylist.forEach(song => {
            const div = document.createElement('div');
            div.className = 'list-item';
            div.style.cursor = 'default';
            div.innerHTML = `
                <span>${escapeHtml(song.artist)} - ${escapeHtml(song.title)}</span>
                <button onclick="mp_removeSongFromPlaylist('${escapeHtml(playlistName)}', '${song.id}')" title="Remove from Playlist">Remove</button>`;
            modalList.appendChild(div);
        });
    }

    function mp_openViewPlaylistModal(playlistName) {
        const nameEl = document.getElementById('mp_viewPlaylistName');
        if (nameEl) nameEl.textContent = `Playlist: ${playlistName}`;
        mp_currentPlaylistNameForView = playlistName;
        mp_populateViewPlaylistModal(playlistName);
        mp_openModal('mp_viewPlaylistModal');
    }

    function mp_openModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) modal.style.display = 'flex';
    }

    function mp_closeModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) modal.style.display = 'none';
        // Clear specific modal content on close
        if (modalId === 'mp_viewPlaylistModal') {
            mp_currentPlaylistNameForView = null;
            const list = document.getElementById('mp_viewPlaylistModalList');
            if(list) list.innerHTML = '';
        } else if (modalId === 'mp_removeSongsModal') {
            const list = document.getElementById('mp_removeSongsModalList');
             if(list) list.innerHTML = '';
        } else if (modalId === 'mp_createPlaylistModal') {
            const list = document.getElementById('mp_createPlaylistSongList');
            if(list) list.innerHTML = '';
            const nameInput = document.getElementById('mp_newPlaylistName');
            if (nameInput) nameInput.value = '';
        }
    }

    function mp_openRemoveSongsModal() {
        const modalList = document.getElementById('mp_removeSongsModalList');
        if (!modalList) return; // Exit if element not ready
        modalList.innerHTML = ''; // Clear previous list
    
        // Get the search input for the modal
        const searchInput = document.getElementById('mp_removeSongsSearch');
        if (searchInput) searchInput.value = ''; // Clear search input on open
    
        // Populate the list with no filter initially and add click listeners
        mp_populateRemoveSongsModal(document.getElementById('mp_removeSongsSearch')?.value || ''); // Call populate function
    
        mp_openModal('mp_removeSongsModal');
    }
    
    // NEW Function: mp_populateRemoveSongsModal to handle filtering and rendering
function mp_populateRemoveSongsModal(filter = '') {
        const modalList = document.getElementById('mp_removeSongsModalList');
        if (!modalList) return;
        modalList.innerHTML = ''; // Clear previous list

        const lowerFilter = filter.toLowerCase(); // Convert filter to lowercase

        // Filter the library based on the search input
        const filteredLibrary = mp_musicLibrary.filter(song => {
            // Ensure properties exist before calling toLowerCase or includes
            const titleMatch = song.title && song.title.toLowerCase().includes(lowerFilter);
            const artistMatch = song.artist && song.artist.toLowerCase().includes(lowerFilter);
            const fileNameMatch = song.fileName && song.fileName.toLowerCase().includes(lowerFilter); // Include filename search (check if exists)
            const videoIdMatch = song.isYouTube && song.videoId && song.videoId.toLowerCase().includes(lowerFilter); // Search by video ID for YouTube

            return titleMatch || artistMatch || fileNameMatch || videoIdMatch;
        }).sort((a, b) => {
             // Handle potential missing artist/title when sorting
             const nameA = `${a.artist || ''} - ${a.title || ''}`.trim();
             const nameB = `${b.artist || ''} - ${b.title || ''}`.trim();
             // Fallback to fileName if both artist and title are missing, or for YouTube use videoId if artist/title missing?
              const sortKeyA = nameA || a.fileName || a.videoId || a.id;
              const sortKeyB = nameB || b.fileName || b.videoId || b.id;

             return sortKeyA.localeCompare(sortKeyB);
        });


        if (filteredLibrary.length === 0) {
             const message = mp_musicLibrary.length === 0
                ? 'No songs in library.'
                : (filter ? 'No songs match search.' : 'No songs in library.'); // Message based on whether filter is active or library is empty
            modalList.innerHTML = `<p class="placeholder-text">${message}</p>`;
        } else {
            const fragment = document.createDocumentFragment();
            filteredLibrary.forEach(song => {
                const div = document.createElement('div');
                div.className = 'list-item';
                div.setAttribute('role', 'option'); // Add ARIA role
                div.setAttribute('tabindex', '0'); // Make keyboard focusable
                div.style.cursor = 'pointer'; // Make item clickable
                div.dataset.songId = song.id; // Store the song ID on the list item

                // Add YouTube icon if it's a YouTube song
                if (song.isYouTube) {
                    const youtubeIcon = document.createElement('i');
                    youtubeIcon.className = 'fab fa-youtube youtube-icon'; // Assuming you have Font Awesome loaded
                    youtubeIcon.title = 'YouTube'; // Tooltip
                    div.appendChild(youtubeIcon);
                }

                // Create span for the text content
                const textSpan = document.createElement('span');
                textSpan.textContent = `${escapeHtml(song.artist || 'Unknown Artist')} - ${escapeHtml(song.title || 'Unknown Title')}`; // Add fallback text and escape HTML
                textSpan.title = `${escapeHtml(song.artist || 'Unknown Artist')} - ${escapeHtml(song.title || 'Unknown Title')} (${song.isYouTube ? 'YouTube' : escapeHtml(song.fileName || 'Unknown File')})`; // Update title logic and escape HTML
                textSpan.style.flexGrow = '1'; // Allow span to take space
                textSpan.style.overflow = 'hidden';
                textSpan.style.textOverflow = 'ellipsis';
                textSpan.style.whiteSpace = 'nowrap';

                // Append the text span
                div.appendChild(textSpan);

                // Add click listener to the div (list item) to toggle selection highlight
                div.addEventListener('click', () => {
                    div.classList.toggle('selected-for-action'); // Toggle the new highlight class
                     // Optional: Provide visual/aria feedback for selection
                     if (div.classList.contains('selected-for-action')) {
                         div.setAttribute('aria-selected', 'true');
                     } else {
                          div.setAttribute('aria-selected', 'false');
                     }
                });

                // Add keyboard accessibility for Enter/Space keys to select
                div.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter' || event.key === ' ') {
                         event.preventDefault(); // Prevent default space/enter behavior (like scrolling)
                         event.target.click(); // Simulate a click to toggle selection
                    }
                });

                fragment.appendChild(div);
            });
            modalList.appendChild(fragment);
             // Optional: Focus the first item for keyboard navigation
             if (filteredLibrary.length > 0 && modalList.firstChild) {
                  modalList.firstChild.focus();
             }
        }
         console.log(`MP: Populated Remove Songs modal list with ${filteredLibrary.length} songs (filter: "${filter}").`);
    }

    
    // mp_removeSelectedSongs logic remains the same - it reads checked checkboxes
    // No change needed for mp_removeSelectedSongs if you keep using checkboxes.

async function mp_removeSelectedSongs() { // Make it async
        const selectedListItems = document.querySelectorAll('#mp_removeSongsModalList .list-item.selected-for-action');
        const idsToRemove = Array.from(selectedListItems).map(item => item.dataset.songId);

        if (idsToRemove.length === 0) {
            alert("MP: No songs selected.");
            return;
        }

        if (confirm(`MP: Remove ${idsToRemove.length} song(s)? This cannot be undone.`)) {
            let stoppedPlayback = false;
            // Check if playing song is being removed
            if (mp_currentSong && idsToRemove.includes(mp_currentSong.id)) {
                 mp_stopPlaybackAndClearUI(); // Stop playback, revoke URL (for local), stop YT player
                 stoppedPlayback = true;
            }

            // Remove from in-memory library
            const initialLibLength = mp_musicLibrary.length;
            mp_musicLibrary = mp_musicLibrary.filter(song => !idsToRemove.includes(song.id));
            const removedLibCount = initialLibLength - mp_musicLibrary.length;

            // Remove from in-memory recently played
            const initialRecentLength = mp_recentlyPlayed.length;
            mp_recentlyPlayed = mp_recentlyPlayed.filter(id => !idsToRemove.includes(id));
            const removedRecentCount = initialRecentLength - mp_recentlyPlayed.length;

            // Remove from in-memory all playlists
            let removedPlaylistCount = 0;
            Object.keys(mp_playlists).forEach(pName => {
                 const initialPListLength = mp_playlists[pName].length;
                 mp_playlists[pName] = mp_playlists[pName].filter(id => !idsToRemove.includes(id));
                 removedPlaylistCount += (initialPListLength - mp_playlists[pName].length);
            });

            try {
                // ***** MODIFIED SECTION (Ensure await for DB deletion) *****
                await mp_dbDeleteSongs(idsToRemove); // Delete from IndexedDB first
                await mp_saveMusicData(); // Then save all updated states (library to IDB, recents/playlists to LS)
                // **************************
                console.log(`MP: Removed ${removedLibCount} from library, ${removedRecentCount} from recents, ${removedPlaylistCount} from playlists. Data saved.`);
                 showIndividualNotification('Success', `Removed ${removedLibCount} song(s).`, 3000);
            } catch (error) {
                console.error("MP: Error during song removal and saving:", error);
                alert("An error occurred while removing songs. Changes might not be fully saved.");
                 showIndividualNotification('Error', 'Error removing songs.', 5000);
            }

            // Re-render lists if they are currently displayed
            if (mp_isInitialized) {
                if (document.getElementById('mp_songsList')) mp_renderSongsList();
                if (document.getElementById('mp_recentlyPlayedList')) mp_renderRecentlyPlayed();
                if (document.getElementById('mp_playlistsList')) mp_renderPlaylists();
            }
            mp_closeModal('mp_removeSongsModal');
        }
    }

    // --- Rendering Functions ---

    // Helper to create list items
    function mp_createListItem(song, onClickCallback) {
        const listItem = document.createElement('div');
        listItem.className = 'list-item';
        listItem.setAttribute('role', 'option'); // Role for items in a listbox
        listItem.setAttribute('tabindex', '0'); // Make it focusable

         // Add YouTube icon if it's a YouTube song
         if (song.isYouTube) {
             const youtubeIcon = document.createElement('i');
             youtubeIcon.className = 'fab fa-youtube youtube-icon'; // Use the youtube-icon class defined in CSS
             youtubeIcon.title = 'YouTube'; // Tooltip
             listItem.appendChild(youtubeIcon);
         }

        // Use a span for the text content for better control and potential icon addition
        const textSpan = document.createElement('span');
        textSpan.className = 'list-item-text';
        // Use fallback text in case metadata is incomplete
        textSpan.textContent = `${escapeHtml(song.artist || 'Unknown Artist')} - ${escapeHtml(song.title || 'Unknown Title')}`;

        listItem.appendChild(textSpan);

        // Add a detailed title on hover
        listItem.title = `${escapeHtml(song.artist || 'Unknown Artist')} - ${escapeHtml(song.title || 'Unknown Title')} (${song.isYouTube ? 'YouTube' : escapeHtml(song.fileName || 'Unknown File')})`; // Update title logic

        listItem.dataset.songId = song.id; // Store the song ID

        listItem.onclick = onClickCallback; // Assign the click callback
        // Add keyboard accessibility for Enter/Space keys
        listItem.onkeydown = (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault(); // Prevent page scroll on Space
                onClickCallback(); // Trigger the click behavior
            }
        };
        return listItem;
    }


    // Updates playing indicator across all lists
    function mp_updatePlayingIndicator() {
        // Find all list items with song IDs across potentially visible lists
        document.querySelectorAll('#mp_songsList .list-item[data-song-id], #mp_recentlyPlayedList .list-item[data-song-id]').forEach(item => {
            item.classList.remove('playing');
            if (mp_currentSong && mp_isPlaying && item.dataset.songId === mp_currentSong.id) {
                item.classList.add('playing');
            }
        });
    }

    function mp_renderSongsList(filter = '') {
        if (!mp_songsList) {
            // Don't log error repeatedly if called when page not visible
            return;
        }
        mp_songsList.innerHTML = ''; // Clear previous list
        const lowerFilter = filter.toLowerCase();

        // Filter the library
        const filteredLibrary = mp_musicLibrary.filter(song =>
            song.title.toLowerCase().includes(lowerFilter) ||
            song.artist.toLowerCase().includes(lowerFilter) ||
            song.fileName.toLowerCase().includes(lowerFilter)
        ).sort((a, b) => `${a.artist} - ${a.title}`.localeCompare(`${b.artist} - ${b.title}`)); // Sort consistently

        // Display songs or placeholder
        if (filteredLibrary.length === 0) {
            mp_songsList.innerHTML = `<p class="placeholder-text">${mp_musicLibrary.length === 0 ? 'Upload songs to see your library' : (filter ? 'No songs match search' : 'Library empty?')}</p>`;
        } else {
            const fragment = document.createDocumentFragment(); // Use fragment for performance
            filteredLibrary.forEach(song => {
                // Pass the correct callback function
                const listItem = mp_createListItem(song, () => mp_playSongFromLibrary(song.id));
                fragment.appendChild(listItem);
            });
            mp_songsList.appendChild(fragment); // Append fragment once
        }
        mp_updatePlayingIndicator(); // Update playing class
    }

    function mp_renderRecentlyPlayed() {
        const recentlyPlayedList = document.getElementById('mp_recentlyPlayedList');
        const searchInput = document.getElementById('mp_recentlyPlayedSearch'); // Get the search input
        if (!recentlyPlayedList) return; // Exit if element not ready
    
        const filter = searchInput ? searchInput.value.toLowerCase() : ''; // Get filter value
        recentlyPlayedList.innerHTML = ''; // Clear previous list
    
        if (mp_recentlyPlayed.length === 0) {
            recentlyPlayedList.innerHTML = '<p class="placeholder-text">Play a song to see it here</p>';
            return;
        }
    
        const fragment = document.createDocumentFragment();
        mp_recentlyPlayed.forEach(songId => {
            const song = mp_findSongById(songId);
            if (song) {
                // Add filtering logic here
                const songText = `${song.artist} - ${song.title} ${song.fileName}`.toLowerCase();
                if (songText.includes(filter)) {
                    // Pass the correct callback function
                    const listItem = mp_createListItem(song, () => mp_playSongFromLibrary(song.id));
                    fragment.appendChild(listItem);
                }
            } else {
                 console.warn("MP: Recently played song ID not found in library:", songId);
            }
        });
    
        if (fragment.children.length === 0 && filter) {
             recentlyPlayedList.innerHTML = '<p class="placeholder-text">No recently played songs match search</p>';
        } else {
            recentlyPlayedList.appendChild(fragment);
        }
    
        mp_updatePlayingIndicator(); // Update playing class
    }

    function mp_renderPlaylists() {
        const playlistsList = document.getElementById('mp_playlistsList');
        if (!playlistsList) return; // Exit if element not ready
        playlistsList.innerHTML = ''; // Clear previous list
        const playlistNames = Object.keys(mp_playlists).sort((a, b) => a.localeCompare(b)); // Sort names
    
        if (playlistNames.length === 0) {
            playlistsList.innerHTML = '<p class="placeholder-text" style="grid-column: 1 / -1;">Create a playlist to see it here</p>'; // Center placeholder in grid
            return;
        }
    
        const fragment = document.createDocumentFragment();
        playlistNames.forEach(name => {
            const songCount = mp_playlists[name]?.length || 0;
            const listItem = document.createElement('div');
            // Use a new class name for clarity if you prefer, or stick to list-item
            // listItem.className = 'playlist-card';
            listItem.className = 'list-item'; // Keep list-item class to match existing CSS rules if not renaming
            listItem.setAttribute('role', 'option'); // Keep list item roles for accessibility
            listItem.setAttribute('tabindex', '0'); // Make it focusable
    
            // Add click listener to the entire card (excluding the settings icon)
            listItem.onclick = (event) => {
                // Check if the click target was the settings icon or its parent
                if (event.target.closest('.fa-cog')) {
                    event.stopPropagation(); // Prevent the card click if settings icon was clicked
                    return;
                }
                mp_playPlaylist(name); // Play the playlist when the card is clicked
            };
            // Add keyboard accessibility for Enter/Space keys
            listItem.onkeydown = (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault(); // Prevent page scroll on Space
                     // Trigger the card click behavior (play playlist)
                     mp_playPlaylist(name);
                }
            };
    
    
            // --- Get Album Art for the first song ---
            let albumArtContentHtml = ''; // HTML for the image or placeholder
            const songIds = mp_playlists[name] || [];
            const firstSongId = songIds.length > 0 ? songIds[0] : null;
            const firstSong = firstSongId ? mp_findSongById(firstSongId) : null;
    
            // Generate HTML for the image area
            if (firstSong && firstSong.albumArtUrl) {
                 albumArtContentHtml = `<img src="${escapeHtml(firstSong.albumArtUrl)}" alt="Album art for ${escapeHtml(firstSong.title)}" title="${escapeHtml(firstSong.artist)} - ${escapeHtml(firstSong.title)}">`;
             } else {
                 // Placeholder if first song has no art, playlist empty, or first song missing
                 albumArtContentHtml = `<i class="fas fa-music placeholder-icon" title="${firstSong ? 'No album art' : (songIds.length === 0 ? 'Empty Playlist' : 'Missing song')}"></i>`;
             }
            // --- End of getting album art ---
    
    
            // --- Generate the new HTML structure ---
            listItem.innerHTML = `
                <div class="playlist-card-image-area">
                    ${albumArtContentHtml} </div>
                <div class="playlist-card-info">
                     <i class="fas fa-cog"
                        title="Edit Playlist"
                        onclick="event.stopPropagation(); mp_openViewPlaylistModal('${escapeHtml(name)}')">
                     </i>
    
                     <span>
                         ${escapeHtml(name)} (${songCount} ${songCount === 1 ? 'song' : 'songs'})
                     </span>
                </div>`;
    
            fragment.appendChild(listItem);
        });
        playlistsList.appendChild(fragment);
         console.log("MP: Rendered playlists list as grid cards.");
    }


    // --- Initialization and Event Listeners ---

    // Sets up listeners for the persistent playback bar
    // Sets up listeners for the persistent playback bar
// Sets up listeners for the persistent playback bar
    // isSeeking flag should be declared in a scope accessible by its listeners and mp_updateSeekBar

    function mp_initializePlaybackBar() {
         if (mp_playbackBarInitialized) return; // Run only once
         console.log("MP: Initializing Playback Bar Listeners...");

         // Get references AFTER DOM is loaded
         mp_playPauseButton = document.getElementById('mp_playPauseButton');
         mp_prevButton = document.getElementById('mp_prevButton');
         mp_nextButton = document.getElementById('mp_nextButton');
         mp_seekBar = document.getElementById('mp_seekBar');
         mp_currentTime = document.getElementById('mp_currentTime');
         mp_totalDuration = document.getElementById('mp_totalDuration');
         mp_currentSongInfo = document.getElementById('mp_currentSongInfo');
         mp_volumeSlider = document.getElementById('mp_volumeSlider');
         mp_muteButton = document.getElementById('mp_muteButton');
         mp_volumePercentage = document.getElementById('mp_volumePercentage');

         // Check if all elements were found
         if (!mp_playPauseButton || !mp_prevButton || !mp_nextButton || !mp_seekBar || !mp_volumeSlider || !mp_muteButton || !mp_audioPlayer || !mp_volumePercentage || !mp_currentTime || !mp_totalDuration || !mp_currentSongInfo) {
             console.error("MP: Failed to find one or more essential playback control elements. Cannot initialize bar fully.");
             return; // Stop initialization if elements missing
         }

         // Attach listeners for the main playback bar controls
         mp_playPauseButton.addEventListener('click', mp_togglePlayPause);
         mp_nextButton.addEventListener('click', mp_playNextSong);
         mp_prevButton.addEventListener('click', mp_playPrevSong);

         // --- Seek bar listeners for the main bar ---
         mp_seekBar.addEventListener('mousedown', () => { isSeeking = true; }); // Start seeking flag
         mp_seekBar.addEventListener('mouseup', () => { isSeeking = false; }); // End seeking flag
         mp_seekBar.addEventListener('touchstart', () => { isSeeking = true; }); // Mobile touch start
         mp_seekBar.addEventListener('touchend', () => { isSeeking = false; }); // Mobile touch end


         mp_seekBar.addEventListener('input', () => {
              // Only update time if the main seek bar is being dragged AND a song is loaded
              if (!mp_currentSong || !mp_audioPlayer && !mp_youtubePlayer) return; // Check for loaded song/player

              let duration = 0;
               // Get duration from the active player
               if (mp_currentSong.isYouTube && mp_youtubePlayer && typeof mp_youtubePlayer.getDuration === 'function') {
                   duration = mp_youtubePlayer.getDuration();
               } else if (!mp_currentSong.isYouTube && mp_audioPlayer && !isNaN(mp_audioPlayer.duration)) {
                   duration = mp_audioPlayer.duration;
               } else {
                    console.warn("MP: Seek bar input, but duration not available from active player.");
                    return; // Cannot seek if duration is unknown
               }

             if (duration <= 0) return; // Cannot seek if duration is 0

             const seekTime = (mp_seekBar.value / 100) * duration; // Assuming max=100

              // Set current time/seek for the active player
              if (mp_currentSong.isYouTube && mp_youtubePlayer && typeof mp_youtubePlayer.seekTo === 'function') {
                  mp_youtubePlayer.seekTo(seekTime, true); // Seek to time, true = allow seek ahead
                   // Ensure player is playing after seeking if it was before or if it was paused by seeking
                   if (mp_youtubePlayer.getPlayerState() !== YT.PlayerState.PLAYING && mp_youtubePlayer.getPlayerState() !== YT.PlayerState.BUFFERING) {
                        mp_youtubePlayer.playVideo();
                   }
              } else if (!mp_currentSong.isYouTube && mp_audioPlayer && !isNaN(seekTime)) {
                  mp_audioPlayer.currentTime = seekTime;
                   // Ensure player is playing after seeking if it was before or if it was paused by seeking
                   if (mp_audioPlayer.paused && !mp_audioPlayer.ended) {
                        mp_audioPlayer.play().catch(error => console.error("MP: Audio play after seek failed:", error));
                   }
              }


              // Update time display immediately while scrubbing (main bar)
             if(mp_currentTime) mp_currentTime.textContent = mp_formatTime(seekTime);
             // The mp_updateSeekBar function will handle syncing the hover overlay scroller on the next timeupdate event
         });

         // Volume slider listener for the main bar
         mp_volumeSlider.addEventListener('input', () => {
             // Call the new mp_setVolume function
             mp_setVolume(parseFloat(mp_volumeSlider.value)); // Pass the slider value (0-1)
         });

         // Mute button listener for the main bar
         mp_muteButton.addEventListener('click', () => {
              // Get current muted state from the active player or assume based on UI
              let currentMutedState = false;
               if (mp_currentSong?.isYouTube && mp_youtubePlayer && typeof mp_youtubePlayer.isMuted === 'function') {
                  currentMutedState = mp_youtubePlayer.isMuted();
               } else if (!mp_currentSong?.isYouTube && mp_audioPlayer) {
                  currentMutedState = mp_audioPlayer.muted;
               } else {
                   // If no player active, use the UI state as a fallback? Or just do nothing?
                   // Let's check the UI icon as a fallback if no player state available
                   if (mp_muteButton.innerHTML.includes('volume-mute')) {
                       currentMutedState = true;
                   } else {
                       currentMutedState = false;
                   }
                   console.warn("MP: Mute toggle clicked, but no active player state could be determined. Using UI state.");
               }

              // Toggle the muted state using the new function
              mp_setMuted(!currentMutedState);
         });


         // Audio element listeners (These handle core audio events and trigger UI updates)
         // These listeners now rely on mp_updateSeekBar, mp_updatePlaybackControls, mp_updateVolumeControls
         // which are modified to check the active player type.
          mp_audioPlayer.addEventListener('seeking', () => { /* isSeeking = true; */ }); // Handled by mousedown/touchstart now
          mp_audioPlayer.addEventListener('seeked', () => { /* isSeeking = false; */ }); // Handled by mouseup/touchend now

         mp_audioPlayer.addEventListener('timeupdate', mp_updateSeekBar); // Update time and seek bar

         mp_audioPlayer.addEventListener('loadedmetadata', () => {
             console.log("MP: loadedmetadata fired. Duration:", mp_audioPlayer.duration);
             // mp_updateSeekBar handles updating duration display and slider max now
              mp_updateSeekBar(); // Call update to refresh duration and current time (will be 0 initially)
         });

         mp_audioPlayer.addEventListener('ended', mp_playNextSong); // Play next song when current one ends

         mp_audioPlayer.addEventListener('error', (e) => {
             console.error("MP: Audio Player Error Event:", mp_audioPlayer.error, e);
             let errorMsg = "Unknown playback error.";
             if (mp_audioPlayer.error) {
                  switch (mp_audioPlayer.error.code) {
                      case MediaError.MEDIA_ERR_ABORTED: errorMsg = 'Playback aborted.'; break;
                      case MediaError.MEDIA_ERR_NETWORK: errorMsg = 'Network error caused download failure.'; break;
                      case MediaError.MEDIA_ERR_DECODE: errorMsg = 'Error decoding the audio file.'; break;
                      case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: errorMsg = 'Audio format not supported.'; break;
                      default: errorMsg = `An unknown error occurred (Code ${mp_audioPlayer.error.code})`;
                  }
             }
             // Update main bar song info display with error
             if(mp_currentSongInfo) mp_currentSongInfo.textContent = `Error: ${errorMsg}`;
             // Show notification
             showIndividualNotification("Playback Error", `Could not play "${mp_currentSong?.title || 'song'}": ${errorMsg}`, 6000);
             // Decide how to handle errors - stopping or skipping to next song
             console.log("MP Audio Player: Attempting to play the next song after error.");
             mp_playNextSong(); // Try playing the next song
         });

         // Update button states when playback starts/pauses
         mp_audioPlayer.addEventListener('play', () => {
              mp_isPlaying = true;
              mp_updatePlaybackControls(); // Corrected function name
              console.log("MP: Audio 'play' event. mp_isPlaying:", mp_isPlaying); // Add console log for debugging
         });
         mp_audioPlayer.addEventListener('pause', () => {
              mp_isPlaying = false;
              mp_updatePlaybackControls(); // Corrected function name
              console.log("MP: Audio 'pause' event. mp_isPlaying:", mp_isPlaying); // Add console log for debugging
         });

         // Update volume UI when volume changes (e.g., system volume controls)
         mp_audioPlayer.addEventListener('volumechange', mp_updateVolumeControls); // This should handle both bars if needed


         // Initial UI setup based on current state (useful on page load if audio was playing before)
         // Ensure these calls happen AFTER element references are obtained
         mp_updateVolumeControls(); // Initial volume UI setup (should handle both bars if needed)
         mp_updatePlaybackControls(); // Initial button state (call the combined function)
         mp_updateSeekBar(); // Initial time/scroller state

         mp_playbackBarInitialized = true;
         console.log("MP: Playback Bar Initialized.");
     }

function mp_initializeMusicPlayerPage() {
         console.log("MP: mp_initializeMusicPlayerPage called. Setting timeout for DOM ready.");

         // Use a small timeout to ensure the page content is rendered after switchPage
         setTimeout(async () => { // Make it async if it needs to await permissions
             console.log("MP: Timeout fired. Attempting to get music page elements...");

             // Get references to essential music page elements
             mp_songsList = document.getElementById('mp_songsList');
             mp_recentlyPlayedList = document.getElementById('mp_recentlyPlayedList');
             mp_playlistsList = document.getElementById('mp_playlistsList');
             mp_songSearch = document.getElementById('mp_songSearch');
             const mp_recentlyPlayedSearch = document.getElementById('mp_recentlyPlayedSearch');

             // Get modal search inputs (they exist even when modal is hidden)
             const mp_createPlaylistSearch = document.getElementById('mp_createPlaylistSearch'); // Get element
             const mp_removeSongsSearch = document.getElementById('mp_removeSongsSearch'); // Get element

             // *** NEW: Get the "Search for Music" button and the YouTube modal elements ***
             const mp_searchYoutubeButton = document.getElementById('mp_searchYoutubeButton');
             const mp_youtubeSearchInput = document.getElementById('mp_Youtube-input');
             const mp_youtubeSearchButton = document.getElementById('mp_Youtube-button');
             // *** END NEW ***


             // --- Check if ALL essential elements for RENDERING the Music page were found AFTER the timeout ---
             // Add modal search inputs and the new YouTube elements to the check
             if (!mp_songsList || !mp_recentlyPlayedList || !mp_playlistsList || !mp_songSearch || !mp_recentlyPlayedSearch ||
                 !mp_createPlaylistSearch || !mp_removeSongsSearch || !mp_searchYoutubeButton ||
                 !mp_youtubeSearchInput || !mp_youtubeSearchButton)
             {
                 console.error("MP: Failed to find one or more essential music page elements AFTER timeout. Cannot initialize page fully.");
                 console.error("Missing element(s):",
                     !mp_songsList ? '#mp_songsList' : '',
                     !mp_recentlyPlayedList ? '#mp_recentlyPlayedList' : '',
                     !mp_playlistsList ? '#mp_playlistsList' : '',
                     !mp_songSearch ? '#mp_songSearch' : '',
                     !mp_recentlyPlayedSearch ? '#mp_recentlyPlayedSearch' : '',
                     !mp_createPlaylistSearch ? '#mp_createPlaylistSearch (Modal)' : '', // Add modal checks
                     !mp_removeSongsSearch ? '#mp_removeSongsSearch (Modal)' : '', // Add modal checks
                     !mp_searchYoutubeButton ? '#mp_searchYoutubeButton' : '', // Add YouTube elements check
                     !mp_youtubeSearchInput ? '#mp_Youtube-input' : '',
                     !mp_youtubeSearchButton ? '#mp_Youtube-button' : ''
                 );
                 mp_isInitialized = false; // Ensure flag is false if elements are missing
                 const musicPageContainer = document.querySelector('.music-page-container');
                 if (musicPageContainer) {
                     musicPageContainer.innerHTML = '<div class="panel" style="text-align: center; color: red;">Error loading Music Player. Some elements were not found. Please check the console for details.</div>';
                 }
                 return; // Stop initialization if elements are missing
             }
             console.log("MP: Successfully found all essential music page elements for rendering.");

             // --- Attach listeners only if NOT already initialized (moved inside timeout) ---
             if (!mp_isInitialized) {
                 console.log("MP: Initializing Music Player Page Content Listeners (first time)...");
                 // mp_fileInput.addEventListener('change', mp_handleFileSelect); // This listener should be attached in DOMContentLoaded

                 // Listeners for search inputs within the main page content
                 mp_songSearch.addEventListener('input', () => {
                     mp_renderSongsList(mp_songSearch.value);
                 });
                 mp_recentlyPlayedSearch.addEventListener('input', () => {
                     mp_renderRecentlyPlayed();
                 });

                 // Listeners for modal search inputs
                 mp_createPlaylistSearch.addEventListener('input', () => {
                     mp_populateCreatePlaylistModalSongs(mp_createPlaylistSearch.value);
                 });
                 mp_removeSongsSearch.addEventListener('input', () => {
                     mp_populateRemoveSongsModal(mp_removeSongsSearch.value);
                 });

                 // *** NEW: Attach listeners for the Youtube button and input ***
                 mp_searchYoutubeButton.addEventListener('click', mp_openYoutubeSearchModal);

                 mp_youtubeSearchInput.addEventListener('keypress', (event) => {
                     if (event.key === 'Enter') {
                         event.preventDefault(); // Prevent default form submission
                         performYouTubeSearch(); // Call the search function
                     }
                 });

                 mp_youtubeSearchButton.addEventListener('click', performYouTubeSearch);
                 console.log('MP: Youtube button and input listeners attached.');
                 // *** END NEW ***


                 mp_isInitialized = true; // Set flag after attaching listeners
                 console.log("MP: Music Page Listeners Initialized.");
             } else {
                 console.log("MP: Music Player page already initialized listeners.");
             }

             // --- Always render the lists and update UI states when the page is initialized/activated ---
             console.log("MP: Rendering music lists and updating UI states...");
             mp_renderSongsList(mp_songSearch.value); // Use current search value
             mp_renderRecentlyPlayed();
             mp_renderPlaylists();
             // Update permission UI status based on the current handle state
             mp_updatePermissionUI(!!mp_currentDirectoryHandle, mp_currentDirectoryHandle && await mp_currentDirectoryHandle.queryPermission({mode:'read'}) === 'prompt' ? mp_currentDirectoryHandle : null); // Use await for permission check


              if (mp_playbackControlsBar) {
                  // Show playback bar if a song is currently loaded OR if there are any songs in the library
                  // This makes the bar visible even if playback hasn't started yet,
                  // if there's music available.
                  if (mp_currentSong || mp_musicLibrary.length > 0) {
                      mp_playbackControlsBar.style.display = 'flex';
                  } else {
                      mp_playbackControlsBar.style.display = 'none';
                  }
              }

             console.log("MP: Music Player Page Initialization/Activation Complete.");

         }, 150); // Match this delay to your CSS transition duration for fade-out
     }

    // --- END OF MUSIC PLAYER JAVASCRIPT ---


    // --- VANTA.JS HELPER ---
    function colorToVantaFormat(colorString) {
       // ... (keep your existing colorToVantaFormat function) ...
        if (!colorString) {
            console.warn("colorToVantaFormat received empty color string. Defaulting to black.");
            return 0x000000; // Default to black if color is missing
        }
        if (colorString.startsWith('#')) {
            let hex = colorString.substring(1);
            if (hex.length === 3) {
                hex = hex.split('').map(char => char + char).join('');
            }
            try {
                 return parseInt(`0x${hex}`);
            } catch (e) {
                 console.error(`Failed to parse hex color "${colorString}":`, e);
                 return 0x000000;
            }
        }
        const rgbMatch = colorString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (rgbMatch) {
            const r = parseInt(rgbMatch[1]); const g = parseInt(rgbMatch[2]); const b = parseInt(rgbMatch[3]);
            return (r << 16) + (g << 8) + b;
        }
        try {
            const tempDiv = document.createElement('div'); tempDiv.style.color = colorString;
            document.body.appendChild(tempDiv); const computedColor = getComputedStyle(tempDiv).color;
            document.body.removeChild(tempDiv);
            return colorToVantaFormat(computedColor);
        } catch (e) {
             console.warn(`Could not parse color: ${colorString}. Defaulting to black.`);
             return 0x000000;
        }
    }

    function initializeVanta() {
       // ... (keep your existing initializeVanta function) ...
        console.log('Entering initializeVanta() function.');
        try {
            const computedStyle = getComputedStyle(document.body);
            const themeBgDark = computedStyle.getPropertyValue('--bg-dark').trim();
            console.log('Computed --bg-dark for initial theme:', themeBgDark);
            const themeBaseColor = colorToVantaFormat(themeBgDark);
            console.log('Converted Vanta.js baseColor:', '0x' + themeBaseColor.toString(16));

            if (vantaEffect) {
                console.log('Destroying existing Vanta effect.');
                vantaEffect.destroy();
            }

            console.log('Creating new VANTA.FOG instance...');
            vantaEffect = VANTA.FOG({
              el: "body", mouseControls: true, touchControls: true, gyroControls: false,
              minHeight: 200.00, minWidth: 200.00,
              highlightColor: 0x0, midtoneColor: 0x0, lowlightColor: 0x0,
              baseColor: themeBaseColor, // baseColor will change with the theme
              blurFactor: 0.56, speed: 1.10, zoom: 1.20
            });
             console.log('VANTA.FOG instance creation attempted.');

        } catch (error) {
            console.error("Error initializing Vanta.js:", error);
            vantaEffect = null;
        }
    }

    // --- Notification Functions ---
    function showIndividualNotification(title, body, duration = 8000) {
       // ... (keep your existing showIndividualNotification function) ...
        const container = document.getElementById('notificationContainer');
        if (!container) { console.error("Notification container not found."); return; }
        const notificationElement = document.createElement('div');
        notificationElement.classList.add('sliding-notification');
        const notificationId = `notification-${Date.now()}-${Math.random().toString(36).substring(7)}`;
        notificationElement.id = notificationId;
        notificationElement.setAttribute('data-hide-timeout-id', '');
        notificationElement.style.display = 'block';
        notificationElement.innerHTML = `
            <button class="notification-close-button" onclick="hideIndividualNotification('${notificationId}')" title="Dismiss">&times;</button>
            <h3>${escapeHtml(title)}</h3>
            <div>${processLinkedText(body)}</div>
            <div class="notification-progress-bar"></div>
        `;
        container.appendChild(notificationElement);
        // console.log(`Created and appended new notification: ${notificationId}`);
        setTimeout(() => {
             notificationElement.classList.add('show');
             const progressBarElement = notificationElement.querySelector('.notification-progress-bar');
             if (progressBarElement) {
                 progressBarElement.style.transitionDuration = '0ms'; progressBarElement.style.width = '100%';
                 setTimeout(() => { progressBarElement.style.transitionDuration = `${duration}ms`; progressBarElement.style.width = '0%'; }, 50);
             }
             const hideTimeoutId = setTimeout(() => { hideIndividualNotification(notificationId); }, duration);
             notificationElement.setAttribute('data-hide-timeout-id', hideTimeoutId);
             activeNotifications[notificationId] = hideTimeoutId;
             // console.log(`Notification ${notificationId} set to hide in ${duration}ms.`);
        }, 20);
        return notificationElement;
    }
    function hideIndividualNotification(notificationId, immediate = false) {
       // ... (keep your existing hideIndividualNotification function) ...
         const notificationElement = document.getElementById(notificationId);
         if (!notificationElement) {
             if (activeNotifications[notificationId]) { clearTimeout(activeNotifications[notificationId]); delete activeNotifications[notificationId]; }
             return;
         }
         const hideTimeoutId = parseInt(notificationElement.getAttribute('data-hide-timeout-id'));
         if (!isNaN(hideTimeoutId)) { clearTimeout(hideTimeoutId); }
         if (activeNotifications[notificationId]) { delete activeNotifications[notificationId]; }
         notificationElement.classList.remove('show');
         const transitionDuration = 500; const delay = immediate ? 0 : transitionDuration;
         if (notificationElement.hideDisplayTimeout) { clearTimeout(notificationElement.hideDisplayTimeout); notificationElement.hideDisplayTimeout = null; }
         notificationElement.hideDisplayTimeout = setTimeout(() => { if (notificationElement.parentNode) { notificationElement.parentNode.removeChild(notificationElement); } }, delay);
    }
    function hideAllNotifications() {
       // ... (keep your existing hideAllNotifications function) ...
         for (const id in activeNotifications) { if (Object.prototype.hasOwnProperty.call(activeNotifications, id)) { hideIndividualNotification(id, true); } }
    }
    function processLinkedText(text) {
       // ... (keep your existing processLinkedText function) ...
        let processedText = text;
        const linkRegex = /;(\w+);/g;
        processedText = processedText.replace(linkRegex, (match, pageName) => `<a href="#" onclick="switchPage('${escapeHtml(pageName.charAt(0).toUpperCase() + pageName.slice(1))}'); return false;" style="color: var(--accent); text-decoration: underline;">${escapeHtml(pageName)}</a>`);
        const sizeRegex = /\[\[size:(.*?)\]\](.*?)\[\[\/size\]\]/g; processedText = processedText.replace(sizeRegex, '<span style="font-size: $1;">$2</span>');
        const boldRegex = /\*\*(.*?)\*\*/g; processedText = processedText.replace(boldRegex, '<strong>$1</strong>');
        const italicRegex = /\*(.*?)\*/g; processedText = processedText.replace(italicRegex, '<em>$1</em>');
        return processedText;
    }
    async function checkNotifications() {
       // ... (keep your existing checkNotifications function) ...
        // console.log("Checking for multiple notifications..."); // Less verbose
        const notificationURL = "https://hostfilez.glitch.me/notification.txt";
        const container = document.getElementById('notificationContainer');
        if (!container) { console.error("Notification container not found."); return; }
        try {
            const response = await fetch(notificationURL, { cache: "no-store" });
            const notificationText = response.ok ? (await response.text()).trim() : '';
            if (!response.ok || !notificationText) { hideAllNotifications(); return; }
            const notificationBlocks = notificationText.split('_').map(block => block.trim()).filter(block => block.length > 0);
            const currentNotificationBlocksContent = new Set(notificationBlocks);
            container.querySelectorAll('.sliding-notification').forEach(element => {
                const originalContent = element.getAttribute('data-original-content');
                if (originalContent && !currentNotificationBlocksContent.has(originalContent)) { hideIndividualNotification(element.id, true); }
            });
            notificationBlocks.forEach(trimmedBlock => {
                if (trimmedBlock.includes('~true~')) {
                    if (shownNotificationContentSet.has(trimmedBlock)) return;
                    shownNotificationContentSet.add(trimmedBlock);
                    let notificationTitle = "Notification"; let notificationBody = trimmedBlock;
                    let contentAfterTrigger = trimmedBlock.replace(/~true~|~false~/g, '').trim(); // Use regex replace
                    const titleRegex = /`([^`]+)`/; const titleMatch = contentAfterTrigger.match(titleRegex);
                    if (titleMatch && titleMatch[1]) {
                        notificationTitle = titleMatch[1].trim();
                        notificationBody = contentAfterTrigger.substring(contentAfterTrigger.indexOf(titleMatch[0]) + titleMatch[0].length).trim();
                    } else { notificationBody = contentAfterTrigger; }
                    if (!notificationBody) notificationBody = "No message provided.";
                    const displayDuration = Math.max(6000, notificationBody.split(/\s+/).filter(Boolean).length * 400);
                    const newNotificationElement = showIndividualNotification(notificationTitle, notificationBody, displayDuration);
                    if (newNotificationElement) { newNotificationElement.setAttribute('data-original-content', trimmedBlock); }
                }
            });
        } catch (err) { console.error("Failed to check/parse notifications:", err); hideAllNotifications(); }
    }

    // --- Other App Functions (Themes, Games, Library, Settings, etc.) ---
    // ... (Keep ALL your other functions like setTheme, loadData, saveGames, updateGamesPage,
    //      setupDragAndDrop, updateLibraryPage, loadGame, toggleFavoriteGame, resetApp,
    //      panic key functions, setupEventListeners, etc.) ...
    // ... Make sure they are complete and correct based on previous versions ...
    function setTheme(themeName) {
        // ... (Your existing setTheme function) ...
        console.log('Attempting to set theme:', themeName);
        const selectedTheme = themes.find(theme => theme.name === themeName);
        if (!selectedTheme) { console.error('Theme not found:', themeName); return; }
        for (const [variable, value] of Object.entries(selectedTheme.variables)) {
            document.documentElement.style.setProperty(variable, value);
        }
        currentThemeName = themeName;
        localStorage.setItem('theme', themeName);
        console.log('Theme applied and saved:', themeName);
        document.querySelectorAll('.theme-option').forEach(option => {
            option.classList.remove('selected');
            if (option.classList.contains(selectedTheme.previewClass)) {
                option.classList.add('selected');
            }
        });
        if (vantaEffect) {
            setTimeout(() => {
                const computedStyle = getComputedStyle(document.documentElement);
                const themeBgDark = computedStyle.getPropertyValue('--bg-dark').trim();
                const newThemeBaseColor = colorToVantaFormat(themeBgDark);
                vantaEffect.setOptions({ baseColor: newThemeBaseColor /* other params */ });
                console.log('Vanta.js options updated for theme.');
            }, 50);
        }
    }

    function escapeHtml(unsafe) {
        if (!unsafe) return '';
        return unsafe
             .replace(/&/g, "&amp;")
             .replace(/</g, "&lt;")
             .replace(/>/g, "&gt;")
             .replace(/"/g, "&quot;")
             .replace(/'/g, "&#039;");
    }

    function loadData() {
        // ... (Your existing loadData function - it should NOT load the handle) ...
        console.log('Loading data from localStorage...');
        const savedThemeName = localStorage.getItem('theme') || 'default';
        currentThemeName = savedThemeName;
        setTheme(currentThemeName); // Apply theme variables
        console.log('Theme data loaded. Initial theme:', currentThemeName);

        const aboutBlankPref = localStorage.getItem('aboutBlankOnStartup');
        const shouldOpenInAboutBlank = aboutBlankPref !== 'false';
        // Logic for about:blank handled elsewhere maybe

        const savedGames = localStorage.getItem('games');
        const userGames = savedGames ? JSON.parse(savedGames) : [];
        games = [...defaultGames];
        const gameNames = new Set(defaultGames.map(g => g.name));
        userGames.forEach(g => { if (!gameNames.has(g.name)) { games.push(g); gameNames.add(g.name); } });
        console.log('Games loaded:', games.length);

        const savedLibrary = localStorage.getItem('library');
        library = savedLibrary ? JSON.parse(savedLibrary) : [];
        console.log('Library loaded:', library.length);

        const savedFavoriteGames = localStorage.getItem('favoriteGames');
        favoriteGames = savedFavoriteGames ? JSON.parse(savedFavoriteGames) : [];
        console.log('Favorite games loaded:', favoriteGames.length);

        const savedAppSettings = localStorage.getItem('appSettings');
        if (savedAppSettings) { applyAppSettings(JSON.parse(savedAppSettings)); }
        else { applyAppSettings({ tabTitle: 'Underground', faviconUrl: '' }); }
        console.log('App Settings loaded/applied.');
        console.log('Data loading complete.');
    }

    function applyAppSettings(settings) {
    console.log('Applying app settings:', settings);
    // Apply Tab Title
    if (settings.tabTitle !== undefined) { // Check if setting exists
        document.title = settings.tabTitle;
        console.log('Applied app tab title:', settings.tabTitle);
    }

    // Apply Favicon
    let link = document.querySelector("link[rel~='icon']");
    if (settings.faviconUrl) { // Check if a URL is provided
        if (!link) {
            link = document.createElement('link');
            link.rel = 'icon';
            document.getElementsByTagName('head')[0].appendChild(link);
             console.log('Created favicon link element.');
        }
        link.href = settings.faviconUrl;
        console.log('Applied app favicon URL:', settings.faviconUrl);
    } else {
         // If no favicon URL is provided, remove the link element to use browser default
        if (link) {
             link.remove(); // Remove the custom favicon link
             console.log('Removed custom favicon, using browser default.');
        }
    }

    // Update the UI elements on the Settings page if they exist
    const appTabTitleInput = document.getElementById('appTabTitleInput');
    const appFaviconUrlInput = document.getElementById('appFaviconUrlInput');

    if (appTabTitleInput && settings.tabTitle !== undefined) {
         appTabTitleInput.value = settings.tabTitle;
    }
     if (appFaviconUrlInput && settings.faviconUrl !== undefined) {
        appFaviconUrlInput.value = settings.faviconUrl;
     }
     console.log('Updated app settings page UI elements.');
}
    
    function saveAppSettings() {
    console.log('Saving app settings...');
    const appTabTitleInput = document.getElementById('appTabTitleInput');
    const appFaviconUrlInput = document.getElementById('appFaviconUrlInput');

    if (!appTabTitleInput || !appFaviconUrlInput) {
        console.error("App settings input elements not found, cannot save.");
        alert("Error: App Settings page elements not found.");
        return;
    }

    const appSettingsToSave = {
        tabTitle: appTabTitleInput.value.trim(),
        faviconUrl: appFaviconUrlInput.value.trim()
    };

    localStorage.setItem('appSettings', JSON.stringify(appSettingsToSave)); // Use 'appSettings' key
    console.log('App settings saved to localStorage:', appSettingsToSave);

    // Apply the newly saved settings immediately
    applyAppSettings(appSettingsToSave);

    alert('App Settings saved!');
}
    
    function openAppInAboutBlank() {
            console.log('Attempting to open app in about:blank window by getting current document HTML and writing, setting opener to null.');
            // Get the full HTML content of the current page
            const htmlContent = document.documentElement.outerHTML;
            const currentAppUrl = window.location.href; // Still useful context, though not fetched
    
            const newWindow = window.open('about:blank', '_blank');
    
            if (newWindow) {
                console.log('Opened new about:blank window.');
    
                // Set opener to null immediately to try and break the link
                try {
                    newWindow.opener = null;
                    console.log('Set new window opener to null.');
                } catch (e) {
                    console.warn('Failed to set new window opener to null:', e);
                }
    
    
                // Use setTimeout to allow the window document to be ready for writing
                setTimeout(() => {
                    try {
                        // Write the obtained HTML content into the new window's document
                        newWindow.document.open();
                        newWindow.document.write(htmlContent);
                        newWindow.document.close();
    
                        console.log('Successfully wrote current document HTML to about:blank window.');
    
                        // Optional: You might want to set the new window's history or URL to the original URL
                        // This can sometimes help with relative paths but might re-introduce detection issues
                        try {
                             // Setting history.pushState is cleaner than changing location.href directly if you want to spoof the URL
                             newWindow.history.pushState({}, '', currentAppUrl);
                             console.log('Attempted to set new window history state URL.');
                        } catch (e) {
                             console.warn('Failed to set new window history state URL:', e);
                        }
    
    
                    } catch (e) {
                        console.error('Failed to write HTML content to about:blank window:', e);
                         // This alert indicates that writing to the document itself failed
                         alert("Could not write app content to about:blank window.");
                    }
                }, 50); // Small delay
    
            } else {
                alert('Could not open a new window. Please check your browser popup blocker.');
                console.warn('Failed to open new window for about:blank.');
            }
        }
    
    function toggleAboutBlankStartup() {
        const toggle = document.getElementById('aboutBlankToggle');
        if (toggle) {
            const isEnabled = toggle.checked;
            localStorage.setItem('aboutBlankOnStartup', isEnabled);
            console.log('About:Blank on startup set to:', isEnabled);
            // Optional: Add user feedback like a small notification/alert
            // alert(`About:Blank on startup ${isEnabled ? 'enabled' : 'disabled'}.`);
        } else {
            console.error("About:Blank toggle element not found.");
        }
    }
    
    function handleReloadSiteClick() {
            console.log("Reload Site button clicked. Reloading page.");
            location.reload(); // Reload the current page
        }
    
    function handleDownloadOfflineClick() {
        if (updateDownloadUrl) {
            console.log("Download Offline button clicked. Downloading from:", updateDownloadUrl);
            // Create a temporary anchor element
            const link = document.createElement('a');
            link.href = updateDownloadUrl;
            // Set the download attribute with an optional filename
            link.setAttribute('download', 'Underground_Update.html'); // You can change the filename
            // Append to the body, trigger click, and remove
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            // Optionally close the update overlay after initiating download
            // document.getElementById("updateOverlay").style.display = 'none';

        } else {
            console.warn("Download Offline button clicked, but no download URL is available.");
            alert("Download link not found. Please try again or reload.");
        }
    }
    
    function hideUpdateOverlay() {
        const updateOverlay = document.getElementById("updateOverlay");
         if (updateOverlay) {
             updateOverlay.style.display = 'none';
             // Optionally reset the overlay content back to its initial state
             // (Less critical with the single overlay structure, but good practice)
             // document.getElementById("updateTitle").textContent = "New Update Available!";
             // document.getElementById("updateMessage").textContent = "A new version (vX.Y.Z) is available.";
             // const downloadButton = document.getElementById("downloadOfflineButton");
             // if (downloadButton) {
             //     downloadButton.disabled = false; // Reset disabled state
             //     downloadButton.title = ""; // Clear title
             // }
             updateDownloadUrl = null; // Clear the stored URL
             console.log("Update overlay hidden.");
         }
    }
    
    async function checkVersion() {
       console.log("Checking for latest version (triggered by interval or Home page switch)...");

       // Define the installed version here
       const installedVersion = "v1.0.0"; // <-- Set your installed version here

       const versionURL = "https://hostfilez.glitch.me/version.txt";
       let latestVersion = null;
       let fetchedDownloadUrl = null;
       let checkError = false;

       // --- Fetch Version and Extract Data ---
       try {
         const versionResponse = await fetch(versionURL, { cache: "no-store" }); // Avoid cache
         if (!versionResponse.ok) throw new Error(`HTTP error! status: ${versionResponse.status}`);
         const latestVersionText = (await versionResponse.text()).trim();

         // Extract just the version string (assuming it's the first part before any '(' or whitespace)
         const latestVersionMatch = latestVersionText.match(/^([^(\s]+)/);
         latestVersion = latestVersionMatch ? latestVersionMatch[1] : latestVersionText;

         // Extract the URL within parentheses
         const urlMatch = latestVersionText.match(/\((.*?)\)/);
         fetchedDownloadUrl = urlMatch && urlMatch[1] ? urlMatch[1].trim() : null;

         console.log("Fetched latest version text:", latestVersionText);
         console.log("Extracted latest version:", latestVersion);
         console.log("Extracted download URL:", fetchedDownloadUrl);

         updateDownloadUrl = fetchedDownloadUrl; // Store in the global variable

       } catch (err) {
         console.error("Failed to fetch or parse version:", err);
         checkError = true;
         latestVersion = "Error"; // Indicate error in UI if elements exist
         updateDownloadUrl = null; // Clear URL on error
       }

       // --- Update Home Page Elements (Only if they exist) ---
       // Do this AFTER fetching the version to minimize impact on fetch
       const homeVersionEl = document.getElementById("home-installed-version");
       const latestVersionEl = document.getElementById("home-latest-version");

       if (homeVersionEl) {
           homeVersionEl.textContent = installedVersion;
       }
       if (latestVersionEl) {
           latestVersionEl.textContent = latestVersion; // Will show version or "Error"
       }


       // --- Display/Hide Update Overlay (Independent of Home Page) ---
       // Get the update overlay elements
       const updateOverlay = document.getElementById("updateOverlay");
       const updateMessageEl = document.getElementById("updateMessage");
       const updateTitleEl = document.getElementById("updateTitle");
       const downloadButton = document.getElementById('downloadOfflineButton');

       // Check if overlay elements were successfully found before trying to manipulate them
       const canDisplayOverlay = updateOverlay && updateMessageEl && updateTitleEl && downloadButton;

       if (!canDisplayOverlay) {
            console.warn("Update overlay elements not found. Cannot display update notification.");
            // We can stop here if the overlay itself can't be shown
            return;
       }

       // Now that we know overlay elements exist, proceed with display logic
       if (latestVersion && latestVersion !== "Error" && latestVersion !== installedVersion) {
            console.log("New update available detected:", latestVersion);
            updateOverlay.style.display = 'flex'; // Show the update overlay
            updateTitleEl.textContent = "New Update Available!";
            updateMessageEl.textContent = `A new version (${latestVersion}) is available.`;

            // Enable or disable download button based on whether a URL was found
            downloadButton.disabled = !updateDownloadUrl;
            if (!updateDownloadUrl) {
                downloadButton.title = "Download link not found in version file.";
            } else {
                downloadButton.title = "";
            }

       } else {
           console.log("App is up to date or check failed, ensuring overlay is hidden.");
           updateOverlay.style.display = 'none'; // Ensure overlay is hidden
       }

       // If there was a fetch/parse error, the overlay will be hidden,
       // and the Home page status will show "Error".
       if (checkError) {
            console.log("Update check finished with errors.");
       } else if (latestVersion === installedVersion) {
            console.log("Update check finished: App is up to date.");
       } else if (latestVersion !== installedVersion && latestVersion !== "Error") {
            console.log("Update check finished: Update available.");
       }
     }
    
    function saveGames() {
      localStorage.setItem('games', JSON.stringify(games));
       console.log('Games data saved.');
    }

    function generateGamesHTML() {
       console.log('Generating Games HTML. Showing favorites:', isShowingFavoriteGames());
       const gamesToDisplay = isShowingFavoriteGames() ?
         games.filter(game => favoriteGames.some(fav => fav.name === game.name)) :
         games;

       // Generate the cards first
       const gameCardsHTML = gamesToDisplay.map((game, index) => {
         // Find original index to use for actions (like remove/favorite/proxy)
         const originalIndex = games.findIndex(g => g.name === game.name);
         // Ensure the index is valid before generating the card
         if (originalIndex === -1) return ''; // Skip if game not found in main list

         return `
           <div class="game-card" draggable="true" data-index="${originalIndex}">
             <div class="remove-icon" onclick="removeGame(event, ${originalIndex})" title="Remove Game">
               <i class="fas fa-times"></i>
             </div>
             <img src="${escapeHtml(game.icon)}" alt="${escapeHtml(game.name)}"
                  onerror="this.src='https://via.placeholder.com/150?text=No+Image'"
                  onclick="loadGame('${escapeHtml(game.name)}', '${escapeHtml(game.url)}')">
             <p onclick="loadGame('${escapeHtml(game.name)}', '${escapeHtml(game.url)}')">${escapeHtml(game.name)}</p>
             <div style="display: flex; flex-direction: column; gap: 5px; align-items: center; margin-top: 5px;">
               <button class="favorite-button" onclick="event.stopPropagation(); toggleFavoriteGame(${originalIndex})">
                 <i class="fas ${isFavoriteGame(game) ? 'fa-solid' : 'fa-regular'} fa-star" style="${isFavoriteGame(game) ? 'color: var(--accent);' : ''}"></i>
                 <span>${isFavoriteGame(game) ? 'Favorited' : 'Favorite'}</span>
               </button>
               ${game.proxiedUrl && game.proxiedUrl !== 'none' ? // Only show proxy toggle if proxy URL exists
                 `<button class="favorite-button" onclick="event.stopPropagation(); toggleProxied(${originalIndex})">
                   <i class="fas fa-shield-alt"></i>
                   <span>Proxy: ${game.proxied ? 'On' : 'Off'}</span>
                 </button>`
                 : ''
               }
             </div>
           </div>`;
         }).join('');


       // Return the full container HTML
       return `
         <input type="text" id="gameSearch" placeholder="Search Games" oninput="filterGames()" style="width: 90%; max-width: 400px; margin: 0 auto 1.5rem auto; display: block;">
         <div class="games-header">
           <div class="action-card" onclick="showAddGameModal()">
             <i class="fas fa-plus"></i>
             <p>Add Game</p>
           </div>
           <div class="action-card" onclick="toggleFavoriteGamesView()">
             <i class="fas fa-star" style="${isShowingFavoriteGames() ? 'color: var(--accent);' : ''}"></i>
             <p>${isShowingFavoriteGames() ? 'All Games' : 'Favorites'}</p>
           </div>
         </div>
         <div class="games-container" id="gamesContainerInner">
             ${gameCardsHTML || '<p class="no-games-message" style="color: var(--text-muted); width: 100%; text-align: center;">No games found.</p>'}
         </div>`;
     }
    
    function toggleProxied(index) {
      console.log('Toggling proxy for game index:', index);
      if (games[index] && games[index].proxiedUrl && games[index].proxiedUrl !== 'none') {
         games[index].proxied = !games[index].proxied;
         saveGames();
         console.log('Proxy toggled.');
    
         // Update UI immediately for the specific card
          // Check if the clicked button is within the Game of the Day container
         const gameOfTheDayContainer = document.getElementById('game-of-day-container');
         let button = null;
    
         if (gameOfTheDayContainer && gameOfTheDayContainer.contains(event.target)) {
             // If the clicked element is inside the Game of the Day container,
             // find the proxy button relative to the container.
             // This assumes there's only one proxy button within the game-of-day-container's .game-card
             button = gameOfTheDayContainer.querySelector('.favorite-button i.fa-shield-alt').closest('button'); // Find button by icon
             console.log('Updating proxy button in Game of the Day container.');
    
         } else {
             // Otherwise, assume it's a button on the main Games page
              button = document.querySelector(`.game-card[data-index="${index}"] .favorite-button i.fa-shield-alt`).closest('button'); // Find button by icon
              console.log('Updating proxy button on Games page.');
         }
    
    
         if (button) {
           const span = button.querySelector('span');
           if (span) {
             span.textContent = `Proxy: ${games[index].proxied ? 'On' : 'Off'}`;
              console.log('Proxy button text updated.');
           }
         } else {
            console.warn('Proxy button not found for index:', index);
         }
    
         // If currently showing all games or favorites on Games page, re-render (optional but good for consistency)
         // updateGamesPage(); // Decided not to re-render the whole games page on proxy toggle unless necessary
      } else {
         alert("This game does not have a proxy URL configured.");
         console.warn('Attempted to toggle proxy for game without proxiedUrl.');
      }
    }
    
    function loadViewerUrl(url = '', customTitle = 'Viewer', displayUrl = url, updateRecents = true) {
        console.log(`loadViewerUrl called. URL to load: "${url}", Custom Title: "${customTitle}", Display URL: "${displayUrl}"`);
    
        const iframe = document.getElementById('mainViewerIframe');
        const urlInput = document.getElementById('viewerUrlSearch'); // Get the input from the Viewer page structure
    
        if (!iframe) {
            console.error("CRITICAL: Viewer iframe (#mainViewerIframe) not found when loadViewerUrl was executed. Cannot load URL. This indicates the page structure might not be ready.");
            // You could alert the user or try to recover, but the callback in switchPage should prevent this.
            // alert("Error: The viewer component is not ready. Please try clicking the game again.");
            return;
        }
        console.log("Successfully found iframe #mainViewerIframe.");
    
        // Basic URL validation and prepend https if missing
        let finalUrl = url;
        if (finalUrl && !finalUrl.startsWith('http://') && !finalUrl.startsWith('https://') && !finalUrl.startsWith('about:')) {
            finalUrl = 'https://' + finalUrl;
            displayUrl = finalUrl; // Update display URL as well if we modified it
            console.log('Prepended "https://" to URL. New finalUrl:', finalUrl);
        }
    
        // If no URL provided after potential modifications, load about:blank and clear the input
        if (!finalUrl) {
            finalUrl = 'about:blank';
            displayUrl = ''; // Clear input if starting blank
            updateRecents = false; // Don't add about:blank to recents
            customTitle = 'Viewer'; // Reset title
            console.log('No valid URL provided, defaulting iframe to "about:blank".');
        } else {
            // Attempt to validate if it's not about:blank and not a data URI
            try {
                if (!finalUrl.startsWith('about:') && !finalUrl.startsWith('data:')) {
                    new URL(finalUrl); // Validate if it's a proper URL now
                    console.log(`URL "${finalUrl}" passed validation.`);
                }
            } catch (e) {
                // If still invalid, try searching it
                console.warn(`Invalid URL "${finalUrl}", attempting Google search. Error:`, e.message);
                const originalQueryForSearch = url; // Use the original 'url' param for the search query
                finalUrl = `https://www.google.com/search?q=${encodeURIComponent(originalQueryForSearch)}`;
                displayUrl = originalQueryForSearch; // Show the user's initial input in the box
                customTitle = `Search Results for "${escapeHtml(customTitle)}"`; // Escape customTitle if it's from user input
                updateRecents = false; // Don't add search results to recents typically
                console.log(`Performing search. New finalUrl: "${finalUrl}", Display URL: "${displayUrl}"`);
            }
        }
    
        // Set the iframe source
        console.log(`Setting iframe source to: "${finalUrl}"`);
        iframe.src = escapeHtml(finalUrl); // Still escape, as it's generally safer for src attributes
    
        // Update the URL input box on the Viewer page
        if (urlInput) {
            urlInput.value = escapeHtml(displayUrl);
            console.log('Updated Viewer URL search input value to:', displayUrl);
        } else {
            console.warn("Viewer URL input (#viewerUrlSearch) not found. Cannot update its value.");
        }
    
        // Update recently viewed if applicable
        if (updateRecents && finalUrl && finalUrl !== 'about:blank') {
            updateRecentlyViewed(finalUrl); // Assuming updateRecentlyViewed is defined elsewhere
            console.log('Updated recently viewed with URL:', finalUrl);
        }
    
        // Optionally update the main document title if you want the viewer title to reflect the site
        // document.title = customTitle + " - Underground"; // Example
        console.log(`loadViewerUrl finished. Iframe src should be set to "${iframe.src}".`);
    }
    
    function goBackToAppView() {
        console.log('Going back to app view.');
        // Hide iframe container
        const iframeContainer = document.getElementById('iframe-viewer-container');
        if (iframeContainer) {
            iframeContainer.style.display = 'none';
            iframeContainer.innerHTML = ''; // Clear content
            console.log('Hid and cleared iframe container.');
        }

        // Show sidebar and content again
        document.querySelector('.sidebar').style.display = 'flex'; // Or original display value
        pageContent.style.display = 'flex'; // Or original display value
        console.log('Showed sidebar and content.');


        // Restore the page title display based on the current page
        const currentPageKey = localStorage.getItem('lastActivePage') || 'Home';
         if (currentPageKey !== 'Home') {
              pageTitle.style.display = 'block';
              pageTitle.textContent = localStorage.getItem('lastActivePageTitle') || currentPageKey;
              console.log('Restored page title:', pageTitle.textContent);
         } else {
              pageTitle.style.display = 'none'; // Ensure title is hidden on Home
               console.log('Hid page title on Home page.');
         }


        // Optionally switch back to the last active page
        // switchPage(localStorage.getItem('lastActivePage') || 'Home'); // Decided against automatic page switch for simplicity
    }
    
    function loadViewer() {
        console.log('loadViewer() called.');
        const urlInput = document.getElementById('homeSearchInput'); // Get input from Home/Viewer page
        const url = urlInput ? urlInput.value.trim() : ''; // Get value, default to empty
        console.log('URL from home search input:', url);

        loadViewerFromLibrary(url, url, url); // Load the URL in the overlay
    }
    
    function updateRecentlyViewed(url) {
        if (!url || url === 'about:blank') {
            console.log("Skipping updateRecentlyViewed for empty or about:blank URL.");
            return; // Don't add empty or blank URLs
        }

        console.log('Updating recently viewed with URL:', url);
        const maxRecents = 10; // Set the maximum number of recently viewed items

        // Get existing recents from localStorage
        let recents = JSON.parse(localStorage.getItem('recentlyViewed') || '[]');

        // Remove the URL if it already exists (to bring it to the top)
        recents = recents.filter(item => item !== url);

        // Add the new URL to the beginning of the array
        recents.unshift(url);

        // Trim the array to the maximum size
        if (recents.length > maxRecents) {
            recents = recents.slice(0, maxRecents);
        }

        // Save the updated recents back to localStorage
        localStorage.setItem('recentlyViewed', JSON.stringify(recents));
        console.log('Recently viewed updated:', recents);

        // Optional: If the Library page is currently active, refresh its display
        if (currentPage === 'Library') { // Assuming you have a global 'currentPage' variable tracking the active page
             displayLibrary(); // Call the function that renders the library list
             console.log('Refreshed Library page display.');
        }
    }
    
    function goToViewerUrl() {
      console.log('goToViewerUrl() called.');
      const urlInput = document.getElementById('viewerUrlSearch'); // Get input from Viewer page structure
      const url = urlInput ? urlInput.value.trim() : ''; // Allow empty string

       // Call the shared loading function
      loadViewerUrl(url, url, url, true); // Pass URL 3 times (URL, Title, Display URL), update recents
    }
    
    function openViewerFullscreen() {
        console.log('Attempting fullscreen for Viewer page iframe.');
        const iframe = document.getElementById('mainViewerIframe'); // Get iframe from Viewer page structure

        if (!iframe) {
             console.error("Viewer iframe (#mainViewerIframe) not found. Cannot request fullscreen.");
             return;
        }

        if (iframe.requestFullscreen) {
            iframe.requestFullscreen().catch(err => {
                console.error("Fullscreen failed:", err, iframe.src);
                // Fallback: open in new tab if fullscreen API fails
                if (iframe.src && iframe.src !== 'about:blank') {
                    window.open(iframe.src, '_blank');
                     console.log('Fullscreen failed, opening in new tab as fallback.');
                }
            });
        } else {
             // Fallback for browsers not supporting requestFullscreen on iframe directly
             if (iframe.src && iframe.src !== 'about:blank') {
                 window.open(iframe.src, '_blank');
                 console.log('Browser does not support iframe fullscreen, opening in new tab.');
             } else {
                 console.warn('Cannot open fullscreen: Viewer iframe source is not available or is about:blank.');
             }
        }
    }
    
    function showAddGameModal() {
      console.log('Showing add game modal.');
      addGameModal.style.display = 'flex';
      document.getElementById('gameName').focus();
    }
    
    function closeModal() {
      console.log('Closing add game modal.');
      addGameModal.style.display = 'none';
       // Clear fields
       document.getElementById('gameName').value = '';
       document.getElementById('gameUrl').value = '';
       document.getElementById('gameIcon').value = '';
    }

    function addGame() {
      console.log('Attempting to add game.');
      const nameInput = document.getElementById('gameName');
      const urlInput = document.getElementById('gameUrl');
      const iconInput = document.getElementById('gameIcon');

      const name = nameInput.value.trim();
      const url = urlInput.value.trim();
      const icon = iconInput.value.trim();

      if (!name || !url) {
        alert('Please provide both a name and URL for the game');
        console.warn('Add game failed: Name or URL missing.');
        return;
      }

      // Simple URL validation
      if (!url.includes('.') || url.includes(' ')) {
         alert('Please enter a valid URL.');
          console.warn('Add game failed: Invalid URL format.');
         return;
      }
      let finalUrl = url;
       if (!url.startsWith('http://') && !url.startsWith('https://')) {
         finalUrl = 'https://' + url;
         console.log('Prepended https to game URL:', finalUrl);
       }


      games.push({
        name: name,
        url: finalUrl,
        icon: icon || 'https://via.placeholder.com/150?text=No+Image',
        proxied: false, // Default to not proxied
        proxiedUrl: 'none' // Default proxy URL
      });

      saveGames(); // Save immediately
      updateGamesPage(); // Refresh the view
      closeModal();
      console.log('Game added successfully:', name);
    }

    function removeGame(event, index) {
      event.stopPropagation(); // Prevent card click
      console.log('Attempting to remove game index:', index);
      if (index >= 0 && index < games.length) {
         const gameName = games[index].name;
         if (confirm(`Are you sure you want to remove ${gameName}?`)) {
           // Also remove from favorites if it's there
           favoriteGames = favoriteGames.filter(fav => fav.name !== gameName);
           localStorage.setItem('favoriteGames', JSON.stringify(favoriteGames));
            console.log('Removed game from favorites if present.');

           games.splice(index, 1);
           saveGames();
           updateGamesPage();
           console.log('Game removed successfully:', gameName);
         }
      } else {
         console.error("Invalid index for removeGame:", index);
      }
    }
    
     function setupDragAndDrop() {
         console.log('Setting up drag and drop.');
         // Use event delegation on the container
         const container = document.getElementById('gamesContainerInner'); // Target the inner container
         if (!container) {
            console.log('Games container not found, skipping drag and drop setup.');
            return;
         }

         // Remove previous listeners if re-setting up
         container.removeEventListener('dragstart', handleDragStart);
         container.removeEventListener('dragover', handleDragOver);
         container.removeEventListener('dragenter', handleDragEnter);
         container.removeEventListener('dragleave', handleDragLeave);
         container.removeEventListener('drop', handleDrop);
         container.removeEventListener('dragend', handleDragEnd);

         // Add new listeners
         container.addEventListener('dragstart', handleDragStart);
         container.addEventListener('dragover', handleDragOver);
         container.addEventListener('dragenter', handleDragEnter);
         container.addEventListener('dragleave', handleDragLeave);
         container.addEventListener('drop', handleDrop);
         container.addEventListener('dragend', handleDragEnd);
          console.log('Drag and drop event listeners added.');
     }

     function handleDragStart(e) {
         // Only allow dragging on .game-card elements
         if (e.target.classList.contains('game-card')) {
             draggedItem = e.target;
             draggedIndex = parseInt(draggedItem.getAttribute('data-index'));
             console.log('Drag started for index:', draggedIndex);
             // Use setTimeout to allow the browser to render the drag image before hiding/styling
             setTimeout(() => {
                 if (draggedItem) draggedItem.classList.add('dragging');
             }, 0);
             e.dataTransfer.effectAllowed = 'move';
             // Set dummy data for Firefox compatibility
             e.dataTransfer.setData('text/plain', draggedIndex);
         } else {
             e.preventDefault(); // Prevent dragging other elements within the container
         }
     }

     function handleDragOver(e) {
         e.preventDefault(); // Necessary to allow dropping
         e.dataTransfer.dropEffect = 'move';
         // Optional: Visual feedback for where the drop will occur
         const target = e.target.closest('.game-card');
         if (target && target !== draggedItem) {
             // Simple placeholder logic (can be improved)
             document.querySelectorAll('.game-card-placeholder').forEach(p => p.classList.remove('game-card-placeholder'));
             target.classList.add('game-card-placeholder');
         }
         return false;
     }


    function handleDragEnter(e) {
       // Added check to ensure we're entering a game card and not the dragged item itself
       const targetCard = e.target.closest('.game-card');
       if (targetCard && targetCard !== draggedItem) {
          targetCard.classList.add('game-card-placeholder');
       }
    }

    function handleDragLeave(e) {
       // Added check to ensure we're leaving a game card
        const targetCard = e.target.closest('.game-card');
        if (targetCard) {
           targetCard.classList.remove('game-card-placeholder');
        }
        // Also remove if leaving the container entirely but over an empty space
        if (!e.target.closest('.game-card') && e.relatedTarget && !e.relatedTarget.closest('.game-card')) {
           document.querySelectorAll('.game-card-placeholder').forEach(p => p.classList.remove('game-card-placeholder'));
        }
    }


    function handleDrop(e) {
       e.preventDefault(); // Prevent default drop behavior
       e.stopPropagation(); // Prevent drop event from bubbling up
       console.log('Drop handled.');

       const dropTarget = e.target.closest('.game-card');
       if (dropTarget && draggedItem && dropTarget !== draggedItem) {
          const dropIndex = parseInt(dropTarget.getAttribute('data-index'));

          // Reorder the 'games' array
          if (draggedIndex !== null && dropIndex !== null && draggedIndex !== dropIndex) {
             const itemToMove = games.splice(draggedIndex, 1)[0];
             games.splice(dropIndex, 0, itemToMove);
             saveGames(); // Save the new order
             updateGamesPage(); // Refresh the display
             console.log(`Dropped item from index ${draggedIndex} to ${dropIndex}. Games array reordered.`);
          }
       }
       // Clean up placeholder classes even if drop wasn't on a valid target
       document.querySelectorAll('.game-card-placeholder').forEach(p => p.classList.remove('game-card-placeholder'));
        console.log('Drag and drop cleanup complete.');

       return false;
    }


     function handleDragEnd(e) {
         console.log('Drag ended.');
         // Use setTimeout to ensure cleanup happens after potential drop event processing
         setTimeout(() => {
             if (draggedItem) {
                 draggedItem.classList.remove('dragging');
             }
             document.querySelectorAll('.game-card-placeholder').forEach(p => p.classList.remove('game-card-placeholder'));
             draggedItem = null; // Reset dragged item
             draggedIndex = null;
             console.log('Drag end cleanup complete.');
         }, 0);
     }
    
    function filterGames() {
       const query = document.getElementById('gameSearch').value.toLowerCase();
       const container = document.getElementById('gamesContainerInner'); // Target inner container
       if (!container) {
         console.log('Games container not found for filtering.');
         return;
       }
       console.log('Filtering games with query:', query);


       const allCards = container.querySelectorAll('.game-card');
       let foundMatch = false;

       allCards.forEach(card => {
          const name = card.querySelector('p')?.textContent.toLowerCase();
          const matches = name ? name.includes(query) : false;
          card.style.display = matches ? '' : 'none';
          if (matches) foundMatch = true;
       });

        // Show "No games found" message if needed
        let noGamesMessage = container.querySelector('.no-games-message');
        const gamesToConsider = isShowingFavoriteGames() ? games.filter(game => favoriteGames.some(fav => fav.name === game.name)) : games;

        if (!foundMatch && gamesToConsider.length > 0 && !noGamesMessage && query) {
            // Filter active, no matches, but games exist
             noGamesMessage = document.createElement('p');
             noGamesMessage.className = 'no-games-message';
             noGamesMessage.style.color = 'var(--text-muted)';
             noGamesMessage.style.width = '100%';
             noGamesMessage.style.textAlign = 'center';
             container.appendChild(noGamesMessage);
        } else if ((foundMatch || !query) && noGamesMessage) {
             // Filter not active or matches found, remove message
             noGamesMessage.remove();
             noGamesMessage = null; // Reset variable
        }

        // Update message text based on state
        if (!foundMatch && noGamesMessage) {
             noGamesMessage.textContent = isShowingFavoriteGames() ? 'No favorite games match your search.' : 'No games match your search.';
        } else if (!foundMatch && !query && !noGamesMessage && gamesToConsider.length === 0) {
             // No filter, no games, no message exists yet - create it
              noGamesMessage = document.createElement('p');
              noGamesMessage.className = 'no-games-message';
              noGamesMessage.style.color = 'var(--text-muted)';
              noGamesMessage.style.width = '100%';
              noGamesMessage.style.textAlign = 'center';
              container.appendChild(noGamesMessage);
             noGamesMessage.textContent = isShowingFavoriteGames() ? 'No favorite games found.' : 'No games found.';
        }
        console.log('Game filtering complete. Found matches:', foundMatch);

    }

    function updateGamesPage() {
           console.log('Updating Games page content. Showing favorites:', isShowingFavoriteGames());
           const gamesToDisplay = isShowingFavoriteGames() ?
             games.filter(game => favoriteGames.some(fav => fav.name === game.name)) :
             games;
    
           // Generate the cards first
           const gameCardsHTML = gamesToDisplay.map((game, index) => {
             // Find original index to use for actions (like remove/favorite/proxy)
             const originalIndex = games.findIndex(g => g.name === game.name);
             // Ensure the index is valid before generating the card
             if (originalIndex === -1) return ''; // Skip if game not found in main list
    
             return `
               <div class="game-card" draggable="true" data-index="${originalIndex}">
                 <div class="remove-icon" onclick="removeGame(event, ${originalIndex})" title="Remove Game">
                   <i class="fas fa-times"></i>
                 </div>
                 <img src="${escapeHtml(game.icon)}" alt="${escapeHtml(game.name)}"
                      onerror="this.src='https://via.placeholder.com/150?text=No+Image'"
                      onclick="loadGame('${escapeHtml(game.name)}', '${escapeHtml(game.url)}')">
                 <p onclick="loadGame('${escapeHtml(game.name)}', '${escapeHtml(game.url)}')">${escapeHtml(game.name)}</p>
                 <div style="display: flex; flex-direction: column; gap: 5px; align-items: center; margin-top: 5px;">
                   <button class="favorite-button" onclick="event.stopPropagation(); toggleFavoriteGame(${originalIndex})">
                     <i class="fas ${isFavoriteGame(game) ? 'fa-solid' : 'fa-regular'} fa-star" style="${isFavoriteGame(game) ? 'color: var(--accent);' : ''}"></i>
                     <span>${isFavoriteGame(game) ? 'Favorited' : 'Favorite'}</span>
                   </button>
                   ${game.proxiedUrl && game.proxiedUrl !== 'none' ? // Only show proxy toggle if proxy URL exists
                     `<button class="favorite-button" onclick="event.stopPropagation(); toggleProxied(${originalIndex})">
                       <i class="fas fa-shield-alt"></i>
                       <span>Proxy: ${game.proxied ? 'On' : 'Off'}</span>
                     </button>`
                     : ''
                   }
                 </div>
               </div>`;
             }).join('');
    
    
           // Return the full container HTML
           const gamesContent = `
             <input type="text" id="gameSearch" placeholder="Search Games" oninput="filterGames()" style="width: 90%; max-width: 400px; margin: 0 auto 1.5rem auto; display: block;">
             <div class="games-header">
               <div class="action-card" onclick="showAddGameModal()">
                 <i class="fas fa-plus"></i>
                 <p>Add Game</p>
               </div>
               <div class="action-card" onclick="toggleFavoriteGamesView()">
                 <i class="fas fa-star" style="${isShowingFavoriteGames() ? 'color: var(--accent);' : ''}"></i>
                 <p>${isShowingFavoriteGames() ? 'All Games' : 'Favorites'}</p>
               </div>
             </div>
             <div class="games-container" id="gamesContainerInner">
                 ${gameCardsHTML || '<p class="no-games-message" style="color: var(--text-muted); width: 100%; text-align: center;">No games found.</p>'}
             </div>`;
    
    
          // Update the page content ONLY if we are currently displaying the Games or Favorite Games view
           // Check the actual pageTitle text to know if we are *conceptually* on the games page view
          if (pageTitle.textContent === 'Games' || pageTitle.textContent === 'Favorite Games') {
             pageContent.innerHTML = gamesContent; // Set the innerHTML
             console.log('Games page HTML updated.');
             // Re-run setup for drag/drop as elements were replaced
             setupDragAndDrop();
             // Restore search term if it exists
             const searchInput = document.getElementById('gameSearch');
             if (searchInput && searchInput.value) {
                filterGames(); // Re-apply filter
             } else {
                 // If no search term, ensure initial "No games found" message is correct
                 const container = document.getElementById('gamesContainerInner');
                  const gamesToConsider = isShowingFavoriteGames() ? games.filter(game => favoriteGames.some(fav => fav.name === game.name)) : games;
                 if (container && gamesToConsider.length === 0 && !container.querySelector('.no-games-message')) {
                     let noGamesMessage = document.createElement('p');
                     noGamesMessage.className = 'no-games-message';
                     noGamesMessage.style.color = 'var(--text-muted)'; // This line was potentially the issue or nearby
                     noGamesMessage.style.width = '100%';
                     noGamesMessage.style.textAlign = 'center';
                     noGamesMessage.textContent = isShowingFavoriteGames() ? 'No favorite games found.' : 'No games found.';
                     container.appendChild(noGamesMessage);
                      console.log('Displayed initial "No games found" message.');
                 } else if (container && gamesToConsider.length > 0 && container.querySelector('.no-games-message') && !searchInput.value) {
                     // Games now exist, and no filter is active, remove the "No games found" message
                     container.querySelector('.no-games-message').remove();
                      console.log('Removed "No games found" message as games are present.');
                 }
    
             }
          } else {
              console.log('Not on Games or Favorite Games page, skipping content update.');
          }
          // Updating pages.Games might not be necessary if content is always generated
          // pages.Games = gamesContent;
        }


    // --- Library Page ---
     function updateLibraryPage() {
       console.log('Updating Library page content.');
       const favoritedWebsitesContainer = document.getElementById('favoritedWebsites');
       const recentlyViewedContainer = document.getElementById('recentlyViewed');

       if (!favoritedWebsitesContainer || !recentlyViewedContainer) {
         console.log('Library containers not found, skipping update.');
         return;
       }

       const favoritedWebsites = library; // Already loaded in loadData
       const recentlyViewed = JSON.parse(localStorage.getItem('recentlyViewed')) || [];

       favoritedWebsitesContainer.innerHTML = favoritedWebsites.length > 0 ? favoritedWebsites.map((item, index) => `
         <div class="library-item" data-url="${escapeHtml(item)}">
           <div class="remove-icon" onclick="removeLibraryItem(event, ${index})" title="Remove Favorite">
             <i class="fas fa-times"></i>
           </div>
           <div class="library-item-content" onclick="loadViewerFromLibrary('${escapeHtml(item)}', '${escapeHtml(item)}')">
             ${escapeHtml(item)}
           </div>
         </div>
       `).join('') : '<p class="no-results-message" style="color: var(--text-muted); text-align: center;">No favorites added yet.</p>'; // Added class here

       recentlyViewedContainer.innerHTML = recentlyViewed.length > 0 ? recentlyViewed.slice(0, 10).map(item => `
         <div class="library-item">
           <div class="library-item-content" onclick="loadViewerFromLibrary('${escapeHtml(item)}', '${escapeHtml(item)}')">
             ${escapeHtml(item)}
           </div>
         </div>
       `).join('') : '<p style="color: var(--text-muted); text-align: center;">No recently viewed sites.</p>';

        console.log('Library HTML updated.');

       // Re-apply filter if search box has value
       const searchInput = document.getElementById('librarySearch');
       if (searchInput && searchInput.value) {
          filterLibrary();
       }
     }
    
    function loadGame(name, url) {
        console.log('loadGame() called for:', name, url);
        const game = games.find(g => g.name === name);
    
        if (!game) {
            console.error("Game not found in 'games' array:", name);
            // Optionally show a user-facing error or switch to a default page
            // showIndividualNotification('Error', `Game "${escapeHtml(name)}" not found.`, 'error');
            // switchPage('Games'); // Or 'Home'
            return;
        }
    
        const useProxy = game.proxied && game.proxiedUrl && game.proxiedUrl !== 'none';
        const targetUrl = useProxy ? game.proxiedUrl : url;
        const displayUrl = useProxy ? "Proxy Active" : (game.name || url); // Display game name or URL
    
        console.log(`Preparing to load game: "${name}". Target URL: "${targetUrl}". Using proxy: ${useProxy}`);
    
        // Switch to the Viewer page and pass a callback function
        // This callback will execute AFTER the Viewer page's HTML (including the iframe) is in the DOM
        switchPage('Viewer', () => {
            console.log('switchPage callback executed: Attempting to load game into viewer iframe.');
            if (useProxy) {
                console.log(`Proxy mode active for "${name}". Loading proxied URL: ${targetUrl}`);
                loadViewerUrl(targetUrl, name, displayUrl, true);
            } else {
                console.log(`Direct load for "${name}". Loading URL: ${targetUrl}`);
                loadViewerUrl(targetUrl, name, displayUrl, true);
            }
        });
    }



    // --- Favorites ---
    function toggleFavoriteGame(index) {
      console.log('Toggling favorite for game index:', index);
      if (index < 0 || index >= games.length) {
        console.error("Invalid index for toggleFavoriteGame:", index);
        return; // Index check
      }
    
      const game = games[index];
      const gameName = game.name; // Use name for consistency
      const isCurrentlyFavorite = favoriteGames.some(favGame => favGame.name === gameName);
    
      if (isCurrentlyFavorite) {
        favoriteGames = favoriteGames.filter(favGame => favGame.name !== gameName);
        console.log('Removed game from favorites.');
      } else {
        // Add a minimal representation to favorites if not already there
         if (!favoriteGames.some(fav => fav.name === gameName)) {
           favoriteGames.push({ name: gameName }); // Store only name or minimal needed data
           console.log('Added game to favorites.');
         } else {
            console.log('Game was already in favorites list (check logic).');
         }
      }
      localStorage.setItem('favoriteGames', JSON.stringify(favoriteGames));
       console.log('Favorite games saved:', favoriteGames.length);
    
    
      // Update UI immediately for the specific card
      // Check if the clicked button is within the Game of the Day container
      const gameOfTheDayContainer = document.getElementById('game-of-day-container');
      let button = null;
    
      if (gameOfTheDayContainer && gameOfTheDayContainer.contains(event.target)) {
          // If the clicked element is inside the Game of the Day container,
          // find the favorite button relative to the container.
          // This assumes there's only one favorite button within the game-of-day-container's .game-card
          button = gameOfTheDayContainer.querySelector('.favorite-button');
          console.log('Updating favorite button in Game of the Day container.');
    
      } else {
          // Otherwise, assume it's a button on the main Games page
           button = document.querySelector(`.game-card[data-index="${index}"] .favorite-button`);
           console.log('Updating favorite button on Games page.');
      }
    
    
      if (button) {
        const icon = button.querySelector('i.fa-star');
        const span = button.querySelector('span');
        const isFavoriteNow = isFavoriteGame(game); // Check the state again after toggling
        if (isFavoriteNow) {
           if(icon) {
             icon.classList.remove('fa-regular');
             icon.classList.add('fa-solid'); // Add solid class for filled
             icon.style.color = 'var(--accent)'; // Accent color for filled star
           }
           if(span) span.textContent = 'Favorited';
        } else {
           if(icon) {
             icon.classList.remove('fa-solid');
             icon.classList.add('fa-regular'); // Add regular class for outline
             icon.style.color = ''; // Reset color
           }
           if(span) span.textContent = 'Favorite';
        }
         console.log('Favorite button UI updated.');
      } else {
         console.warn('Favorite button not found for index:', index);
      }
    
    
      // If currently showing favorites view on the Games page, re-render
       if (isShowingFavoriteGames() && pageTitle.textContent === 'Favorite Games') { // Check state and current page title
          console.log('Currently showing favorites view on Games page, re-rendering.');
          updateGamesPage(); // Re-render the list based on the updated favoriteGames array
       } else {
           console.log('Not on Favorite Games page or showing all games, skipping full re-render.');
       }
    }


    function isFavoriteGame(game) {
       // Check against the favoriteGames array (which might store just names or full objects)
       return favoriteGames.some(fav => fav.name === game.name);
    }

    function isShowingFavoriteGames() {
      return showingFavorites; // Check the state variable
    }
    
    function toggleFavoriteGamesView() {
      showingFavorites = !showingFavorites; // Flip state
      console.log('Toggling favorite games view. showingFavorites:', showingFavorites);

      // Update the action card's appearance (Favorites/All Games button)
      const favActionCard = document.querySelector('.games-header .action-card:nth-child(2)'); // Target the Favorites/All Games action card

      if (favActionCard) {
          const icon = favActionCard.querySelector('i.fa-star');
          const textP = favActionCard.querySelector('p');

          if (showingFavorites) {
               if (icon) {
                   icon.classList.remove('fa-regular');
                   icon.classList.add('fa-solid'); // Use fa-solid for filled star
                   icon.style.color = 'var(--accent)'; // Apply accent color
               }
               if (textP) textP.textContent = 'All Games';
               console.log('Updated action card to show All Games.');
          } else {
               if (icon) {
                   icon.classList.remove('fa-solid');
                   icon.classList.add('fa-regular'); // Use fa-regular for outline star
                    icon.style.color = ''; // Remove accent color
               }
               if (textP) textP.textContent = 'Favorites';
                console.log('Updated action card to show Favorites.');
          }
      } else {
         console.warn('Favorite games action card not found.');
      }


      // Update the page title based on the new state - HIDE for Home page
       if (pageTitle.textContent !== 'Home') {
         pageTitle.textContent = showingFavorites ? 'Favorite Games' : 'Games';
         pageTitle.style.display = 'block'; // Show title for Games/Favorites page
         console.log('Updated page title:', pageTitle.textContent);
       } else {
          pageTitle.style.display = 'none';
          console.log('Hid page title on Home.');
       }


      // Re-render the games list based on the new state
      updateGamesPage();
    }
    const cloakPresets = {
        goguardian: { title: 'GoGuardian Admin', favicon: 'https://www.goguardian.com/favicon.ico' },
        drive: { title: 'My Drive - Google Drive', favicon: 'https://ssl.gstatic.com/images/branding/product/1x/drive_2020q4_32dp.png' },
        classroom: { title: 'Classes', favicon: 'https://ssl.gstatic.com/classroom/favicon.png' },
        custom: { title: null, favicon: null } // Placeholder
    };
    
    function applyPresetCloak() {
        const select = document.getElementById('tabCloakSelect');
        if (!select) {
            console.error("Tab cloak select element not found.");
            alert("Error: Could not find tab cloak dropdown.");
            return;
        }
        const selectedValue = select.value;
        let settingsToApply;

        if (selectedValue === 'custom') {
            // Load custom settings from localStorage
            const savedAppSettings = localStorage.getItem('appSettings');
            settingsToApply = savedAppSettings ? JSON.parse(savedAppSettings) : { title: 'Underground', favicon: '' }; // Default if no custom saved
             console.log('Applying custom cloak settings from App Appearance.');
        } else if (cloakPresets[selectedValue]) {
            settingsToApply = {
                tabTitle: cloakPresets[selectedValue].title,
                faviconUrl: cloakPresets[selectedValue].favicon
            };
             console.log(`Applying preset cloak: ${selectedValue}`);
        } else {
             console.error(`Invalid cloak preset selected: ${selectedValue}`);
             alert("Invalid cloak option selected.");
             return;
        }

        // Apply the settings
        applyAppSettings(settingsToApply);

        // Save the *choice* of preset (or 'custom') so it can be re-selected on load
        localStorage.setItem('currentCloakPreset', selectedValue);

        alert(`Tab cloak applied: ${select.options[select.selectedIndex].text}`);
    }

    function resetCloak() {
        console.log('Resetting tab cloak to default (Underground).');
        // Reset to the application's default title and potentially remove favicon
        const defaultSettings = {
            tabTitle: 'Underground', // Your app's default name
            faviconUrl: '' // Default (no favicon)
        };
        applyAppSettings(defaultSettings);

        // Remove the saved preset choice and custom settings
        localStorage.removeItem('currentCloakPreset');
        // Optionally, you might want to keep custom settings but just un-apply the cloak:
        // localStorage.setItem('currentCloakPreset', 'custom'); // Revert selection to custom
        // const savedAppSettings = localStorage.getItem('appSettings');
        // if (savedAppSettings) applyAppSettings(JSON.parse(savedAppSettings));

        // Update the dropdown selection
        const select = document.getElementById('tabCloakSelect');
        if (select) {
            select.value = 'custom'; // Set dropdown to custom after reset
        }

        alert("Tab cloak reset to default.");
    }

    // Function to load and apply the saved cloak state when settings page loads
    function loadTabCloakSettings() {
        const savedPreset = localStorage.getItem('currentCloakPreset');
        const select = document.getElementById('tabCloakSelect');

        if (select && savedPreset) {
            select.value = savedPreset;
            console.log(`Loaded saved cloak preset selection: ${savedPreset}`);
            // Optional: Automatically re-apply the cloak based on saved preset?
            // applyPresetCloak(); // Be cautious if this has side effects on initial load
        } else if (select) {
             select.value = 'custom'; // Default to custom if nothing saved
              console.log('No saved cloak preset found, defaulting select to custom.');
        }
    }
      
    // --- Page Definitions & Switching ---
const pages = {
        Home: `
            <div class="home-layout">
                <div class="home-header">
                    <div class="home-logo">undergr0und</div>
                </div>
                <div class="home-main-section">
                     <button class="changelog-button" onclick="openChangelogModal()" title="View Changelog"><i class="fas fa-list-alt"></i> Changelog</button>
                     <div class="home-search-container">
                         <i class="fas fa-search search-icon"></i>
                         <input type="text" id="homeSearchInput" placeholder="Search or type a URL" onkeydown="if(event.key==='Enter') loadViewer()">
                     </div>
                     <div class="home-status">
                        <p>Hidden: <span style="color: red;">False</span></p>
                        <p>Installed: <span id="home-installed-version">v1.0.0</span></p>
                        <p>Latest: <span id="home-latest-version">Checking...</span></p>
                    </div>
                </div>

                <div class="home-bottom-section">
                    <div class="panel home-news-panel">
                        <h2>News</h2>
                        <pre id="news-content" style="white-space: pre-wrap; font-family: inherit; text-align: left;"></pre>
                    </div>
                    <div class="game-of-day-container" id="game-of-day-container">
                        </div>
                </div>
            </div>
        `,
        Library: `
            <div class="panel" style="width: 95%; max-width: 900px;">
              <h2>Library</h2>
              <input type="text" id="librarySearch" placeholder="Search Favorites" oninput="filterLibrary()">
              <div class="library-columns">
                <div class="library-column">
                  <h3><i class="fas fa-star" style="color:var(--accent); margin-right: 5px;"></i>Favorites</h3>
                  <div id="favoritedWebsites" style="max-height: 60vh; overflow-y: auto;"></div>
                </div>
                <div class="library-column">
                  <h3><i class="fas fa-history" style="color:var(--accent); margin-right: 5px;"></i>Recents</h3>
                  <div id="recentlyViewed" style="max-height: 60vh; overflow-y: auto;"></div>
                </div>
              </div>
            </div>`,
        Viewer: `
            <iframe id="mainViewerIframe" src="about:blank" frameborder="0" allowfullscreen></iframe>
            <div class="bottom-controls" id="viewer-bottom-controls">
                <input type="text" id="viewerUrlSearch" placeholder="Enter URL or Search" onkeydown="if(event.key==='Enter') goToViewerUrl()">
                <button class="go-button" onclick="goToViewerUrl()" title="Go"><i class="fas fa-check"></i></button>
                <button class="fullscreen-button" onclick="openViewerFullscreen()" title="Open Fullscreen"><i class="fas fa-expand"></i></button>
                <button onclick="addToLibraryFromViewerPage()" title="Add to Library"><i class="fas fa-bookmark"></i></button>
            </div>
            `,
        Games: ``, // Placeholder - content is dynamically generated
    Music: `
      <div class="music-page-container">
          <div class="music-main-column">
              <div class="music-section-box" id="music-library-box">
                  <h2><i class="fas fa-music-alt"></i> Your Library</h2>
                  <input type="search" id="mp_songSearch" placeholder="Search all songs" aria-label="Search all songs">
                  <div class="scrollable-list" id="mp_songsList" role="listbox" aria-label="All Songs">
                      <p class="placeholder-text">Upload songs to see your library</p>
                  </div>
              </div>

              <div class="music-section-box" id="music-recents-box">
                  <h2><i class="fas fa-history"></i> Recently Played</h2>
                  <input type="search" id="mp_recentlyPlayedSearch" placeholder="Search recently played" aria-label="Search recently played">
                  <div class="scrollable-list" id="mp_recentlyPlayedList" role="listbox" aria-label="Recently Played Songs">
                       <p class="placeholder-text">Play a song to see it here</p>
                  </div>
              </div>
          </div>

          <div class="music-sidebar-column">
              <div class="music-sidebar-top-row">
                    <div class="music-action-box" id="add-music-box">
                      <h2><i class="fas fa-folder-plus"></i> Add Music</h2>
                      <p>Select folder, search online, or remove songs.</p>
                      <button onclick="mp_selectMusicDirectory()" class="button-primary button-small">
                          <i class="fas fa-folder-open"></i> Select Folder
                      </button>
                       <div style="height: 5px;"></div>
                       <button id="mp_searchYoutubeButton" class="button-primary button-small">
                           <i class="fab fa-youtube"></i> Search for Music
                       </button>
                       <div style="height: 5px;"></div>
                       <button onclick="mp_openRemoveSongsModal()" class="button-secondary button-small">
                          <i class="fas fa-trash-alt"></i> Remove Songs
                      </button>
                       <div id="mp_permission_prompt" style="margin-top: 8px; font-size: 0.8em;"></div>
                  </div>

                  <div class="music-action-box" id="create-playlist-box">
                      <h2><i class="fas fa-plus-circle"></i> New Playlist</h2>
                      <p>Create a new playlist.</p>
                      <button onclick="mp_openCreatePlaylistModal()" class="button-primary button-small">
                          <i class="fas fa-plus-circle"></i> Create
                      </button>
                  </div>
              </div>


              <div class="music-section-box" id="playlists-list-box">
                  <h2><i class="fas fa-list-music"></i> Playlists</h2>
                  <div class="scrollable-list" id="mp_playlistsList" role="listbox" aria-label="Playlists">
                       <p class="placeholder-text">Create a playlist to see it here</p>
                  </div>
              </div>
          </div>
      </div>
    `,
        Updater: `
            <div class="panel">
              <h2>Updater</h2>
              <p>This section is for future update functionality.</p>
              <button onclick="checkForUpdatesManual()">Check Manually</button>
              <p id="update-status-message" style="color: var(--text-muted); margin-top: 1rem;">Status: Idle</p>
               <button onclick="openChangelogModal()" style="margin-top: 1rem;">View Changelog</button> </div>`,
        Settings: `
        <div class="settings-grid-container">
          <div class="settings-grid-item">
             <h2>Theme</h2>
             <h3>Theme Selection</h3>
              <div class="theme-selector" id="themeSelector">
                  ${themes.map(theme => `
                      <div class="theme-option ${theme.previewClass}"
                           onclick="setTheme('${theme.name}')"
                           title="${theme.name.charAt(0).toUpperCase() + theme.name.slice(1)}">
                      </div>
                  `).join('')}
              </div>
               <button class="setting-reset-button" onclick="resetThemeSettings()" title="Reset Theme to Default">
                   <i class="fas fa-undo"></i> Reset
               </button>
          </div>

          <div class="settings-grid-item">
            <h2>About:Blank</h2>
            <p>Cloak the site in an about:blank page and toggle about:blank on startup.</p>
            <div style="display: flex; align-items: center; gap: 10px; justify-content: center; flex-direction: column; height: 100%;">
                <div style="display: flex; align-items: center; gap: 10px;">
                     <label class="switch">
                       <input type="checkbox" id="aboutBlankToggle" onclick="toggleAboutBlankStartup()" checked>
                       <span class="slider round"></span>
                     </label>
                     <span>Enabled on Startup</span>
                </div>
                <button onclick="openAppInAboutBlank()">Open Popup Now</button>
            </div>
               <button class="setting-reset-button" onclick="resetAboutBlankSettings()" title="Reset About:Blank Setting">
                   <i class="fas fa-undo"></i> Reset
               </button>
          </div>

          <div class="settings-grid-item">
            <h2>Panic Key</h2>
             <p>Quick open another site with one press.</p>
             <input type="text" id="panicKeyInput" placeholder="Enter Key (e.g., Escape, Alt+Q)">
             <input type="text" id="panicUrlInput" placeholder="Redirect URL (e.g., https://google.com)">
             <button onclick="savePanicKeySettings()">Save Panic Key</button>
               <button class="setting-reset-button" onclick="resetPanicKeySettings()" title="Reset Panic Key">
                   <i class="fas fa-undo"></i> Reset
               </button>
          </div>

          <div class="settings-grid-item">
            <h2>Presets</h2>
            <p>Change the title and icon using presets.</p>
             <select id="tabCloakSelect">
              <option value="goguardian">GoGuardian Admin Block</option>
              <option value="drive">Google Drive</option>
              <option value="classroom">Google Classroom</option>
              <option value="custom">Custom (Use App Appearance)</option>
            </select>
            <button onclick="applyPresetCloak()">Apply Cloak</button>
            <button class="setting-reset-button" onclick="resetCloak()" title="Reset Tab Cloak to Default">
                <i class="fas fa-undo"></i> Reset
            </button>
             </div>

          <div class="settings-grid-item">
               <h2>App Appearance</h2>
               <p>Set a custom title and icon (favicon). Used by 'Custom' cloak.</p>
               <input type="text" id="appTabTitleInput" placeholder="Custom Tab Title">
               <input type="text" id="appFaviconUrlInput" placeholder="Custom Favicon URL">
               <button onclick="saveAppSettings()">Save App Appearance</button>
               <button class="setting-reset-button" onclick="resetAppAppearanceSettings()" title="Reset App Appearance to Default">
                   <i class="fas fa-undo"></i> Reset
               </button>
          </div>


           <div class="settings-grid-item">
            <h2>Reset All Data
                </h2>
            <p>This deletes all saved data (games, library, all settings).</p>
            <button class="reset-button" onclick="resetApp()">
              <i class="fas fa-trash-alt"></i> Reset App Data
            </button>
           </div>

           </div>
    `,
       About: `
            <div class="panel" style="max-width: 500px; text-align: left;">
              <h2>About Underground</h2>
              <p>Underground is a fully custom game launcher and viewer focused on providing a simple, user-friendly interface for accessing online games and websites to circumvent internet censorship</p>
              <p>Version: <span id="about-version">1.0.0</span></p>
              <p>Created by: Zerone</p>
              <p>
                <a href="#" onclick="openChangelogModal(); return false;" style="color: var(--accent); text-decoration: none;">View Changelog</a> |
                <a href="https://github.com/ZeroneV1" style="color: var(--accent); text-decoration: none;">Contact</a>
              </p>
              <h3 style="margin-top: 1rem;">Credits:</h3>
              <p style="font-size: 0.9rem;">
                Uses: Vanta.js, Three.js, Font Awesome.<br>
              </p>
              <h3 style="margin-top: 1rem;">Disclaimer:</h3>
              <p style="font-size: 0.8rem; color: var(--text-muted);">
                Underground is a third-party application. We are not affiliated with external websites or games. Use responsibly.
              </p>
            </div>
        `,
    };
    
    function checkForUpdatesManual() {
        console.log('Manual update check requested.');
        const statusEl = document.getElementById('update-status-message');
        if(statusEl) statusEl.textContent = "Status: Checking for updates...";
        // Add actual update check logic here if needed
        setTimeout(() => {
             if(statusEl) statusEl.textContent = "Status: No updates found (manual check).";
             console.log('Manual update check simulation complete.');
        }, 2000);
    }


    // --- Replace your existing switchPage function with this ---
    function switchPage(pageKey, callback) { // <--- Added callback parameter
        console.log('Switching to page:', pageKey);
    
        // Update page title visibility and content based on the target page
        if (pageKey === 'Games') {
            showingFavorites = false; // Reset view to 'All Games' when entering Games page
            pageTitle.textContent = 'Games'; // Set title
            pageTitle.style.display = 'block'; // Show title
            console.log('Switched to Games page. Resetting favorites view state.');
        } else if (pageKey === 'Home') {
            pageTitle.style.display = 'none'; // Hide title on Home page
            console.log('Switched to Home page. Hiding page title.');
            // Reset favorite view state if coming from Games page
            if (showingFavorites) {
                showingFavorites = false;
                console.log('Came from favorites view, resetting showingFavorites state.');
            }
        } else if (pageKey === 'Viewer') {
            pageTitle.style.display = 'none'; // Hide title on Viewer page
            console.log('Switched to Viewer page. Hiding page title.');
            if (showingFavorites) {
                showingFavorites = false;
                console.log('Came from favorites view on Viewer page, resetting showingFavorites state.');
            }
        }
        else { // For all other pages (Library, Music, Settings, About, etc.)
            pageTitle.textContent = pageKey; // Use the key as the title
            pageTitle.style.display = 'block'; // Show title
            console.log('Switched to page:', pageKey, 'Showing page title.');
            if (showingFavorites) {
                showingFavorites = false;
                console.log('Came from favorites view on another page, resetting showingFavorites state.');
            }
        }
    
        // Fade out current content
        pageContent.classList.add('fade-out');
        console.log('Adding fade-out class to content.');
    
        // Wait for fade-out transition, then update content and fade in
        setTimeout(() => {
            console.log('Timeout before content switch complete.');
            // Set new page content from the 'pages' object
            pageContent.innerHTML = pages[pageKey] || `<div class="panel"><p>Content for ${pageKey} not found.</p></div>`;
            console.log(`Content set for page: ${pageKey}. Content found: ${!!pages[pageKey]}`);
    
            // --- Page-Specific Initialization ---
            if (pageKey === 'Music') {
                console.log("MP: Initializing Music page content via switchPage.");
                mp_initializeMusicPlayerPage();
                if (mp_playbackControlsBar && (mp_currentSong || mp_musicLibrary.length > 0)) {
                    mp_playbackControlsBar.style.display = 'flex';
                }
            } else {
                if (mp_playbackControlsBar) {
                    mp_playbackControlsBar.style.display = 'none';
                }
            }
    
            if (pageKey === 'Games') {
                updateGamesPage();
            } else if (pageKey === 'Library') {
                updateLibraryPage();
            } else if (pageKey === 'Home') {
                checkVersion();
                fetchNews();
                console.log('Home page specific actions (checkVersion, fetchNews) triggered.');
            } else if (pageKey === 'Settings') {
                loadTabCloakSettings();
                setTheme(currentThemeName);
                const keyInput = document.getElementById('panicKeyInput');
                const urlInput = document.getElementById('panicUrlInput');
                if (keyInput && panicKey) keyInput.value = panicKey;
                if (urlInput && panicUrl) urlInput.value = panicUrl;
                const appTitleInput = document.getElementById('appTabTitleInput');
                const appIconInput = document.getElementById('appFaviconUrlInput');
                const currentAppSettings = JSON.parse(localStorage.getItem('appSettings') || '{}');
                if (appTitleInput) appTitleInput.value = currentAppSettings.tabTitle || 'Underground';
                if (appIconInput) appIconInput.value = currentAppSettings.faviconUrl || '';
                const aboutBlankToggle = document.getElementById('aboutBlankToggle');
                const aboutBlankPref = localStorage.getItem('aboutBlankOnStartup');
                if (aboutBlankToggle) aboutBlankToggle.checked = aboutBlankPref !== 'false';
                console.log('Settings page specific UI states loaded.');
            } else if (pageKey === 'About') {
                const aboutVersionEl = document.getElementById('about-version');
                if (aboutVersionEl) aboutVersionEl.textContent = "v1.0.0"; // Replace with your actual version
                console.log('About page loaded.');
            }
    
            // Fade in new content
            pageContent.classList.remove('fade-out');
            console.log('Removing fade-out class, content should fade in.');
    
            // Update active icon in the sidebar
            icons.forEach(i => {
                i.classList.remove('active');
                if (i.getAttribute('data-page') === pageKey && pageKey !== 'Viewer') {
                    i.classList.add('active');
                }
            });
            console.log('Active sidebar icon updated.');
    
            localStorage.setItem('lastActivePage', pageKey);
            localStorage.setItem('lastActivePageTitle', pageTitle.textContent);
    
            // *** CALL THE CALLBACK FUNCTION if it exists ***
            if (typeof callback === 'function') {
                console.log('Executing callback function after page switch and content update.');
                callback(); // Call the provided callback
            }
    
        }, 150); // Match this delay to your CSS transition duration for fade-out
    }
    
    function handleIconClick() {
      const page = this.getAttribute('data-page');
      console.log('Sidebar icon clicked for page:', page);

        if (page === 'Viewer') {
            // Clicking the Viewer icon now switches to the Viewer page
            switchPage('Viewer'); // <--- Changed to switchPage
            console.log('Viewer icon clicked, switching to Viewer page.');
            // The switchPage function will handle setting the content and active icon
        } else {
            // For all other icons, perform normal page switching
            switchPage(page);
             console.log('Non-Viewer icon clicked, calling switchPage.');
        }
    }

    function handleTooltipShow(e) {
       // Debounce or throttle tooltip updates if performance becomes an issue
       tooltip.style.left = `${e.clientX + 15}px`; // Use clientX for fixed sidebar
       tooltip.style.top = `${e.clientY}px`;   // Use clientY
       tooltip.textContent = this.getAttribute('title');
       tooltip.style.display = 'block';
    }


    function handleTooltipHide() {
      tooltip.style.display = 'none';
    }
    
    function addToLibraryFromHome() {
        console.log('addToLibraryFromHome() called.');
        const urlInput = document.getElementById('homeSearchInput'); // Get input from Home page
        const url = urlInput ? urlInput.value.trim() : ''; // Allow empty string

        if (url) {
            // If a URL is entered, switch to the Viewer page and load it
             switchPage('Viewer');
             // Add a small delay to allow the Viewer page HTML structure to be added to the DOM
             setTimeout(() => {
                  // Load the URL in the viewer, use URL as title, display URL, update recents
                  loadViewerUrl(url, url, url, true);
             }, 50); // 50ms delay - adjust if you experience issues

            // Clear the search input on the Home page after submitting to the viewer
            // Decide if you want to clear it or keep it. Clearing might be better UX.
            if (urlInput) {
                urlInput.value = '';
            }

        } else {
            // If no URL is entered, just show the Viewer page with the input box empty
            switchPage('Viewer');
             console.log("No URL entered, switching to empty Viewer page.");
             // No need to call loadViewerUrl with empty URL, the Viewer page HTML already loads about:blank
        }
    }

// This function is triggered by the "Add to Library" button on the Viewer page
    // This replaces the old addToLibraryFromViewer function.
    function addToLibraryFromViewerPage() {
         console.log('addToLibraryFromViewerPage() called.');
         // Get the iframe element from the Viewer page structure
         const iframe = document.getElementById('mainViewerIframe');
         // Get the current URL loaded in the iframe
         const url = iframe ? iframe.src : null;

         // Check if the URL is valid before attempting to add
         if (url && url !== 'about:blank') {
              // Call the shared addToLibrary function with the iframe's URL
              addToLibrary(url);
         } else {
              // If the URL is not valid, show a notification
              showindividualNotification('Error', 'Cannot add "about:blank" or empty URL to library.', 'error');
              console.warn("Attempted to add 'about:blank' or empty URL to library.");
         }
    }

    // Function to add a URL to the main library list (using localStorage)
    // This function is called by addToLibraryFromViewerPage, addToLibraryFromHome, etc.
    function addToLibrary(url) {
        // Basic validation
        if (!url || url === 'about:blank') {
            showIndividualNotification('Error', 'Cannot add empty or blank URL to library.', 'error');
            console.warn("Attempted to add empty or about:blank URL to library.");
            return;
        }
         // Optional: Prevent adding search result pages directly
         if (url.startsWith('https://www.google.com/search?q=')) {
             showIndividualNotification('Info', 'Cannot add search result pages directly to library.', 'info');
             console.warn("Attempted to add Google search results URL to library.");
             return;
         }


        console.log('Attempting to add to library:', url);

        // Get existing library items from localStorage. Initialize as empty array if not found.
        let libraryItems = JSON.parse(localStorage.getItem('libraryItems') || '[]');

        // Check if the URL already exists in the library using .some()
        const exists = libraryItems.some(item => item.url === url);

        if (exists) {
            // If the item already exists, show an info notification
            showIndividualNotification('Info', 'This item is already in your library.', 'info');
            console.log('Item already exists in library.');
        } else {
            // If the item does not exist, create a new item object
            const newItem = {
                url: url,
                title: url // Default title is the URL. You might add logic to fetch the title later.
            };
            // Add the new item to the library list
            libraryItems.push(newItem);

            // Save the updated library array back to localStorage as a JSON string
            localStorage.setItem('libraryItems', JSON.stringify(libraryItems));
            console.log('Added to library:', newItem);

            // Show a success notification
            showIndividualNotification('Success', 'Item added to library!', 'success');

            // (Optional code to refresh display on the Library page is omitted as requested)
        }
    }

    // Make sure you have the showNotification and escapeHtml functions defined as well.
    // Example placeholder implementations are included in the previous response if needed.


    function removeLibraryItem(event, index) {
      event.stopPropagation(); // Prevent triggering item click
      console.log('Attempting to remove library item at index:', index);
      if (index >= 0 && index < library.length) {
         const itemToRemove = library[index];
         if (confirm(`Remove "${itemToRemove}" from favorites?`)) {
            library.splice(index, 1);
            localStorage.setItem('library', JSON.stringify(library));
            updateLibraryPage(); // Refresh the library view
            console.log('Library item removed:', itemToRemove);
         }
      } else {
          console.error("Invalid index for removeLibraryItem:", index);
      }
    }
    
    function filterLibrary() {
       const query = document.getElementById('librarySearch').value.toLowerCase();
       const container = document.getElementById('favoritedWebsites'); // Target only favorites for filtering
       if (!container) {
         console.log('Favorited websites container not found for filtering.');
         return;
       }
        console.log('Filtering library favorites with query:', query);


       const allItems = container.querySelectorAll('.library-item');
       let foundMatch = false;

       allItems.forEach(item => {
          const url = item.getAttribute('data-url')?.toLowerCase(); // Use data-url
          const matches = url ? url.includes(query) : false;
          item.style.display = matches ? 'flex' : 'none'; // Use 'flex' as display type
          if (matches) foundMatch = true;
       });

        // Add/remove 'no results' message
        let noResultsMessage = container.querySelector('.no-results-message');
        const itemsToConsider = library; // Filtering the entire library list


        if (!foundMatch && itemsToConsider.length > 0 && !noResultsMessage && query) {
             // Filter active, no matches, but items exist
             noResultsMessage = document.createElement('p');
             noResultsMessage.className = 'no-results-message';
             noResultsMessage.style.color = 'var(--text-muted)';
             noResultsMessage.style.textAlign = 'center';
             noResultsMessage.style.width = '100%';
             container.appendChild(noResultsMessage);
             console.log('Created no-results message for filter.');
        } else if ((foundMatch || !query) && noResultsMessage) {
            // Filter not active or matches found, remove message
            noResultsMessage.remove();
            noResultsMessage = null; // Reset variable
             console.log('Removed no-results message.');
        }

        // Update message text based on state
        if (!foundMatch && noResultsMessage) {
             noResultsMessage.textContent = 'No favorites match your search.';
        } else if (!foundMatch && !query && !noResultsMessage && itemsToConsider.length === 0) {
             // No filter, no items, no message exists yet - create it
              noResultsMessage = document.createElement('p');
              noResultsMessage.className = 'no-results-message';
              noResultsMessage.style.color = 'var(--text-muted)';
              noResultsMessage.style.textAlign = 'center';
              noResultsMessage.style.width = '100%';
              container.appendChild(noResultsMessage);
             noResultsMessage.textContent = 'No favorites added yet.';
              console.log('Created initial no-favorites message.');
        }
        console.log('Library filtering complete. Found matches:', foundMatch);
    }


    // --- App Reset ---
async function resetApp() { // Make the function async to use await for DB deletion
        console.log('Reset App requested.');
        if (confirm("Reset App? This deletes all custom games, library favorites, viewed history, all settings, and music player data (library, recents, playlists, and stored folder reference). This action cannot be undone.")) {
            console.log('Reset confirmed.');

            // 1. Stop Music Playback (if any) and clear UI
            mp_stopPlaybackAndClearUI(); // This function is updated to handle both audio and youtube
            console.log('Music playback stopped and UI cleared.');

            // --- NEW: Stop YouTube Time Update Simulation ---
            if (youtubeTimeUpdateInterval) {
                 clearInterval(youtubeTimeUpdateInterval);
                 youtubeTimeUpdateInterval = null;
                 console.log('Stopped YouTube time update simulation interval.');
            }
             // --- NEW: Destroy YouTube Player instance ---
             if (mp_youtubePlayer && typeof mp_youtubePlayer.destroy === 'function') {
                  mp_youtubePlayer.destroy();
                  console.log('Destroyed YouTube player instance.');
             }
            // --- END NEW ---

            // 2. Clear localStorage
            localStorage.clear();
            console.log('localStorage cleared.');

            // 3. Reset in-memory state variables
            games = []; // Will be repopulated by loadData with defaults
            library = [];
            favoriteGames = [];
            currentThemeName = 'default'; // Reset theme name variable
            showingFavorites = false;
            panicKey = null;
            panicUrl = null;

            // Reset music player specific in-memory states
            mp_musicLibrary = [];
            mp_recentlyPlayed = [];
            mp_playlists = {};
            mp_currentSong = null;
            mp_currentSongIndex = -1;
            mp_currentQueue = [];
            mp_currentDirectoryHandle = null; // Clear the stored directory handle
            mp_isInitialized = false; // Reset music player initialization flag
            // Reset initialization flags for UI components
            mp_playbackBarInitialized = false;
            mp_hoverOverlayInitialized = false;
            // Reset player instance variable
            mp_youtubePlayer = null; // Clear the YouTube player instance variable
            // mp_audioPlayer doesn't need nulling as it's a fixed DOM element

            console.log('In-memory app state variables reset.');

            // 4. Delete IndexedDB Database
            console.log('Attempting to delete IndexedDB database:', MP_DB_NAME);
            let dbDeletedSuccessfully = false;
            try {
                if (mp_db) { // Close any open connection first
                    mp_db.close();
                    mp_db = null;
                    console.log('Closed existing IndexedDB connection before deletion.');
                }
                // Wrap IDB delete in a promise to use await
                await new Promise((resolve, reject) => {
                    const deleteRequest = indexedDB.deleteDatabase(MP_DB_NAME);

                    deleteRequest.onsuccess = () => {
                        console.log("IndexedDB database deleted successfully.");
                        dbDeletedSuccessfully = true;
                        resolve();
                    };

                    deleteRequest.onerror = (event) => {
                        console.error("Error deleting IndexedDB database:", event.target.error);
                        // Don't alert here, will alert after all operations
                        reject(event.target.error);
                    };

                    deleteRequest.onblocked = (event) => {
                        console.warn("IndexedDB database deletion blocked. Database may be in use.", event);
                        // Don't alert here
                        reject(new Error("Database deletion blocked. Please close other tabs of this app."));
                    };
                });
            } catch (err) {
                console.error("Error during IndexedDB database deletion process:", err);
                // The alert will be handled after attempting other resets
            }

            // 5. Re-load default data and re-initialize UI
            // This order ensures that defaults are set up before trying to switch pages or re-init components.

            loadData(); // This loads default games, sets theme from (now cleared) localStorage (so defaults to 'default')
            applyAppSettings({ tabTitle: 'Underground', faviconUrl: '' }); // Apply default appearance
            loadPanicKeySettings(); // This will load null/empty from cleared localStorage

            // Explicitly set default theme and re-initialize Vanta
            setTheme('default'); // Applies default CSS variables and updates currentThemeName
            if (typeof initializeVanta === 'function') {
                initializeVanta(); // Re-initialize Vanta with default theme
            }

            // Re-initialize music player components as their state was reset
            // These might need to be re-initialized because their `mp_isInitialized` flags were reset
             if (typeof mp_initializePlaybackBar === 'function') {
                 mp_initializePlaybackBar(); // Initialize playback bar (will find no songs initially)
             }
             if (typeof initializeMusicHoverOverlay === 'function') {
                 initializeMusicHoverOverlay();
             }
            // The Music page content itself will be rebuilt when switchPage('Music') is called.
            // The mp_fileInput listener needs re-attaching if it was cleared, but it's attached in DOMContentLoaded.
            // The YouTube API script load is in the HTML, so it will reload on page refresh if that happens.
            // The onYouTubeIframeAPIReady function is defined globally.


            // Hide playback controls bar explicitly as there's no music
            if (mp_playbackControlsBar) {
                mp_playbackControlsBar.style.display = 'none';
            }


            // 6. Switch to the home page to reflect reset state
            switchPage('Home'); // Go to home page, this will also re-render its content including news, etc.

            // 7. Final Notification to User
            if (dbDeletedSuccessfully) {
                alert("App has been reset to default settings. All data has been cleared.");
            } else {
                alert("App settings have been reset, but there was an issue clearing all music library data. You may need to clear site data manually via browser settings if music issues persist.");
            }
            console.log('App reset process complete.');

        } else {
            console.log('Reset cancelled by user.');
        }
    }
    
    let panicKey = null;
    let panicUrl = null;
    
    function savePanicKeySettings() {
        const keyInput = document.getElementById('panicKeyInput');
        const urlInput = document.getElementById('panicUrlInput');

        if (keyInput && urlInput) {
            const key = keyInput.value.trim();
            const url = urlInput.value.trim();

            if (!key || !url) {
                alert("Please enter both a key and a URL for the panic key.");
                return;
            }
             // Basic URL validation (add https:// if missing)
             let finalUrl = url;
             if (!finalUrl.startsWith('http://') && !finalUrl.startsWith('https://')) {
                 finalUrl = 'https://' + finalUrl;
             }

            // Save to localStorage and update global variables
            localStorage.setItem('panicKey', key);
            localStorage.setItem('panicUrl', finalUrl);
            panicKey = key;
            panicUrl = finalUrl;

            alert(`Panic key set to '${key}' redirecting to '${finalUrl}'.`);
            console.log('Panic key settings saved:', { key: panicKey, url: panicUrl });

        } else {
            console.error("Panic key input elements not found.");
            alert("Error: Could not find panic key input elements.");
        }
    }

    function loadPanicKeySettings() {
        panicKey = localStorage.getItem('panicKey');
        panicUrl = localStorage.getItem('panicUrl');
        console.log('Loaded panic key settings:', { key: panicKey, url: panicUrl });

        // Update input fields if on settings page
        if (pageTitle.textContent === 'Settings') { // Check if settings page is active
             const keyInput = document.getElementById('panicKeyInput');
             const urlInput = document.getElementById('panicUrlInput');
             if (keyInput && panicKey) keyInput.value = panicKey;
             if (urlInput && panicUrl) urlInput.value = panicUrl;
        }
    }

function checkPanicKey(event) {
        const targetElement = event.target;
        // Log the tag name of the element that received the keydown event
        console.log(`Keydown event target: ${targetElement ? targetElement.tagName : 'null'}, Type: ${targetElement ? targetElement.type : 'N/A'}`);

        // Check if the event originated from an input field or textarea
        if (targetElement && (targetElement.tagName.toLowerCase() === 'input' || targetElement.tagName.toLowerCase() === 'textarea')) {
            // Specifically log if we are skipping because it's an input/textarea
            console.log('Target is input/textarea. Panic key check skipped.');
            return; // Stop execution if typing in these fields
        } else {
             // Log if we are proceeding because it's *not* an input/textarea
            console.log('Target is NOT input/textarea. Proceeding with panic key check.');
        }

        // --- Original panic key check logic ---
        if (!panicKey || !panicUrl) {
             // Log if the key/URL isn't set up
             console.log('Panic key or URL not set in variables. Aborting check.');
             return;
        }

        // Construct the key identifier string from the event
        let pressedKey = '';
        if (event.altKey) pressedKey += 'Alt+';
        if (event.ctrlKey) pressedKey += 'Control+'; // Note: Might be intercepted by OS/browser shortcuts
        if (event.shiftKey) pressedKey += 'Shift+';
        // Use event.key for character keys and specific names like 'Escape', 'Enter'
        pressedKey += event.key;
        // Log the keys being compared
        console.log(`Constructed pressedKey: "${pressedKey}", Comparing (case-insensitive) against panicKey: "${panicKey}"`);


        // Case-insensitive comparison
        if (pressedKey.toLowerCase() === panicKey.toLowerCase()) {
            // Log the successful match before redirecting
            console.log(`Panic key MATCHED: "${pressedKey}". Redirecting to: ${panicUrl}`);
            event.preventDefault(); // Prevent default action just in case
            window.location.href = panicUrl;
        } else {
             // Log if the keys didn't match
             console.log('Panic key did NOT match.');
        }
    }
    
    // --- Modify setupEventListeners to add panic key listener ---
function setupEventListeners() {
      // Get sidebar element once
      const sidebar = document.querySelector('.sidebar'); // Ensure this exists

      // Sidebar Icon Click Listeners
      // Ensure 'icons' variable (NodeList of sidebar icons) is defined globally or accessible
      if (typeof icons !== 'undefined' && icons) {
           icons.forEach(icon => {
             icon.addEventListener('click', handleIconClick);
             // Tooltip Listeners
             icon.addEventListener('mousemove', handleTooltipShow);
             icon.addEventListener('mouseleave', handleTooltipHide);
           });
           console.log('Sidebar icon and tooltip event listeners set up.');
      } else {
           console.warn('Sidebar icons (variable "icons") not found. Sidebar listeners not fully set up.');
      }


      // Modal Click-outside-content Listeners
      const addGameModal = document.getElementById('addGameModal'); // Ensure this exists in your HTML
      if (addGameModal) {
           addGameModal.addEventListener('click', (e) => {
               // Assuming closeModal() is your function to hide addGameModal
             if (e.target === addGameModal) closeModal();
           });
           console.log('Add Game Modal click listener set up.');
      } else {
           console.warn('Add Game Modal element not found.');
      }

      // --- Include Changelog Modal Listener from Function 1 if you still use it ---
      // If you removed the changelogModal HTML, you can remove this block.
      const changelogModal = document.getElementById('changelogModal'); // Ensure this exists if used
      if (changelogModal) {
           changelogModal.addEventListener('click', (e) => {
               // Assuming closeChangelogModal() hides this modal
              if (e.target === changelogModal) closeChangelogModal(); // Make sure closeChangelogModal is defined
           });
           console.log('Changelog Modal click listener set up.');
      } else {
           console.log('Changelog Modal element not found or not used.'); // Log info if not present
      }

      // --- Add Music Player Modal Click-outside Listeners ---
      const removeSongsModal = document.getElementById('mp_removeSongsModal');
      const createPlaylistModal = document.getElementById('mp_createPlaylistModal');
      const viewPlaylistModal = document.getElementById('mp_viewPlaylistModal');
       const youtubeSearchModal = document.getElementById('mp_youtubeSearchModal'); // Get the new modal

      if (removeSongsModal) removeSongsModal.addEventListener('click', (e) => { if (e.target === removeSongsModal) mp_closeModal('mp_removeSongsModal'); });
      if (createPlaylistModal) createPlaylistModal.addEventListener('click', (e) => { if (e.target === createPlaylistModal) mp_closeModal('mp_createPlaylistModal'); });
      if (viewPlaylistModal) viewPlaylistModal.addEventListener('click', (e) => { if (e.target === viewPlaylistModal) mp_closeModal('mp_viewPlaylistModal'); });
      // --- Add listener for the new Youtube modal ---
       if (youtubeSearchModal) youtubeSearchModal.addEventListener('click', (e) => {
           if (e.target === youtubeSearchModal) mp_closeModal('mp_youtubeSearchModal');
       });
      console.log('Music Player modal click listeners set up.');


      // Global Keydown Listener (for Escape key and Panic Key)
      document.addEventListener('keydown', (e) => {
        // --- Handle Escape Key for Modals/Overlays/Notifications ---
        if (e.key === 'Escape') {
            // Close any open modal (check for specific music player modals first, then generic)
             const openMpModal = document.querySelector('.mp-modal[style*="display: flex"]');
             if (openMpModal) {
                  // Get the close button within that modal and click it
                  const closeButton = openMpModal.querySelector('.mp-modal-close');
                  if (closeButton) {
                       closeButton.click();
                       console.log(`Escape pressed: Closed music player modal with ID: ${openMpModal.id}`);
                       return; // Consume the event
                  } else {
                      console.warn(`Escape pressed: Open music player modal found (${openMpModal.id}) but no close button found.`);
                  }
             }

            // Check generic modal (Add Game, Changelog) if no MP modal was closed
             const openModal = document.querySelector('.modal[style*="display: flex"]');
             if (openModal) {
                  // Get the close button within that modal and click it
                  const closeButton = openModal.querySelector('.modal-close');
                  if (closeButton) {
                       closeButton.click();
                       console.log(`Escape pressed: Closed generic modal with ID: ${openModal.id}`);
                       return; // Consume the event
                  } else {
                      console.warn(`Escape pressed: Open generic modal found (${openModal.id}) but no close button found.`);
                  }
             }


            // Hide the sliding notification if it's visible
            const slidingNotification = document.getElementById('slidingNotification'); // Ensure this exists
             if (slidingNotification && slidingNotification.classList.contains('show')) {
                 hideSlidingNotification(); // Call the function to hide the sliding notification
                  console.log('Escape pressed: Hid Sliding Notification.');
                  return; // Consume the event
             }


            // Hide the update overlay if it's visible
             const updateOverlay = document.getElementById("updateOverlay"); // Ensure this exists
             if (updateOverlay && updateOverlay.style.display === 'flex') {
                hideUpdateOverlay(); // Assuming hideUpdateOverlay hides the update overlay
                 console.log('Escape pressed: Hid Update Overlay.');
                 return; // Consume the event
             }

            // Add checks for other full-screen elements you might want Escape to close

             console.log('Escape pressed: No modals/overlays were open.'); // Log if no relevant element was closed

        } // End of Escape key handling

        // Check for panic key on any keydown event (keep this if you have panic key logic)
         // Make sure checkPanicKey is defined elsewhere
         if (typeof checkPanicKey === 'function') {
            checkPanicKey(e);
         } else {
             // console.warn('checkPanicKey function not found.'); // Avoid excessive warnings
         }
      });
       console.log('Global keydown listener set up (Escape, Panic Key).');


       // Update Overlay Button Listeners
       // These buttons exist in the HTML from the start, so listeners can be added here.
       const reloadSiteButton = document.getElementById('reloadSiteButton'); // Ensure exists
       const downloadOfflineButton = document.getElementById('downloadOfflineButton'); // Ensure exists
       const updateCloseButton = document.getElementById('updateCloseButton'); // Ensure exists

       if (reloadSiteButton) {
           // handleReloadSiteClick() should be defined elsewhere
            if (typeof handleReloadSiteClick === 'function') {
               reloadSiteButton.addEventListener('click', handleReloadSiteClick);
               console.log('Reload Site button event listener added.');
            } else {
               console.warn('handleReloadSiteClick function not found.');
            }
       } else {
            console.warn('Reload Site button not found during setup.');
       }

       if (downloadOfflineButton) {
            // handleDownloadOfflineClick() should be defined elsewhere
             if (typeof handleDownloadOfflineClick === 'function') {
                downloadOfflineButton.addEventListener('click', handleDownloadOfflineClick);
                console.log('Download Offline button event listener added.');
             } else {
                 console.warn('handleDownloadOfflineClick function not found.');
             }
       } else {
            console.warn('Download Offline button not found during setup.');
       }

        if (updateCloseButton) {
             // hideUpdateOverlay() should be defined elsewhere
             if (typeof hideUpdateOverlay === 'function') {
                updateCloseButton.addEventListener('click', hideUpdateOverlay);
                console.log('Update Close button event listener added.');
             } else {
                 console.warn('hideUpdateOverlay function not found.');
             }
        } else {
             console.warn('Update Close button not found during setup.');
        }
         console.log('Update Overlay button listeners set up.');


        // --- Music Player Specific Listeners (Page Content & Modals) ---
         // Listeners for buttons/inputs outside the page content (like the "Search for Music" button) can be attached here.

        const mp_searchYoutubeButton = document.getElementById('mp_searchYoutubeButton');
        const mp_youtubeSearchInput = document.getElementById('mp_Youtube-input'); // Inside the modal
        const mp_youtubeSearchButton = document.getElementById('mp_Youtube-button'); // Inside the modal


        if (mp_searchYoutubeButton) {
            mp_searchYoutubeButton.addEventListener('click', mp_openYoutubeSearchModal); // Call the new function
            console.log('MP: "Search for Music" button listener attached.');
        } else { console.warn('MP: "Search for Music" button not found.'); }

        // Listeners for elements INSIDE the modal (they exist from start, but are hidden)
         if (mp_youtubeSearchInput) {
             mp_youtubeSearchInput.addEventListener('keypress', (event) => {
                 if (event.key === 'Enter') {
                     event.preventDefault(); // Prevent default form submission
                     performYouTubeSearch(); // Call the search function
                 }
             });
             console.log('MP: Youtube input keypress listener attached.');
         } else { console.warn('MP: Youtube input not found.'); }

         if (mp_youtubeSearchButton) {
             mp_youtubeSearchButton.addEventListener('click', performYouTubeSearch);
             console.log('MP: Youtube button listener attached.');
         } else { console.warn('MP: Youtube button not found.'); }


       // Sidebar Auto-open/close on mouse movement near left edge
       if (sidebar) { // Check if sidebar element was found at the beginning
            document.addEventListener('mousemove', (e) => {
                // Open sidebar if mouse is near the left edge and sidebar is closed
                if (e.clientX < 10 && !sidebar.classList.contains('open')) {
                    sidebar.classList.add('open');
                }
                // Close sidebar if mouse moves away from the left edge and sidebar is open
                else if (e.clientX > 70 && sidebar.classList.contains('open')) {
                    sidebar.classList.remove('open');
                }
            });
             // Close sidebar if mouse leaves the entire document area while sidebar is open
            document.documentElement.addEventListener('mouseleave', (e) => {
               if (sidebar.classList.contains('open')) {
                 sidebar.classList.remove('open');
               }
            });
            console.log('Sidebar auto-open/close listeners set up.');
       } else {
            console.warn('Sidebar element not found, auto-open/close listeners not set up.');
       }


      console.log('All event listeners setup function completed.');
    }

    // Function to open the Youtube modal (called by button click)
    function mp_openYoutubeSearchModal() {
         console.log("MP: Opening Youtube modal.");
         const searchInput = document.getElementById('mp_Youtube-input');
         const resultsList = document.getElementById('mp_youtube-results-list');

         if (searchInput) searchInput.value = ''; // Clear previous search
         // Reset results list content
         if (resultsList) resultsList.innerHTML = '<p class="placeholder-text">Search results will appear here.</p>';

         mp_openModal('mp_youtubeSearchModal'); // Use the generic modal open function
         if (searchInput) searchInput.focus(); // Focus the input field
    }
    
    function resetThemeSettings() {
        console.log("Resetting theme to default.");
        setTheme('default'); // This already updates localStorage and UI
        alert("Theme reset to Default.");
    }

    function resetAboutBlankSettings() {
        console.log("Resetting About:Blank settings.");
        const toggle = document.getElementById('aboutBlankToggle');
        if (toggle) {
            toggle.checked = true; // Set to default state (checked/enabled)
        }
        localStorage.removeItem('aboutBlankOnStartup'); // Remove saved preference
        console.log("Removed aboutBlankOnStartup from localStorage.");
        alert("About:Blank setting reset to default (Enabled on Startup).");
    }

    function resetPanicKeySettings() {
        console.log("Resetting Panic Key settings.");
        const keyInput = document.getElementById('panicKeyInput');
        const urlInput = document.getElementById('panicUrlInput');

        // Clear UI
        if (keyInput) keyInput.value = '';
        if (urlInput) urlInput.value = '';

        // Clear variables and localStorage
        panicKey = null;
        panicUrl = null;
        localStorage.removeItem('panicKey');
        localStorage.removeItem('panicUrl');
        console.log("Removed panicKey and panicUrl from localStorage.");
        alert("Panic Key settings cleared.");
    }

    // For Tab Cloaker, the existing resetCloak() function works, so we just call that
    // from the new button. No new JS function needed here unless you want different behavior.

    function resetAppAppearanceSettings() {
        console.log("Resetting App Appearance settings.");
        const titleInput = document.getElementById('appTabTitleInput');
        const iconInput = document.getElementById('appFaviconUrlInput');

        // Clear UI
        if (titleInput) titleInput.value = '';
        if (iconInput) iconInput.value = '';

        // Clear localStorage
        localStorage.removeItem('appSettings');
        console.log("Removed appSettings from localStorage.");

        // Apply default appearance
        applyAppSettings({
            tabTitle: 'Underground', // Your app's default name
            faviconUrl: ''
        });
        alert("App Appearance reset to default.");
    }
    
function fetchNews() {
       const newsBox = document.getElementById('news-content');
       const gameOfTheDayContainer = document.getElementById('game-of-day-container');

       if (!newsBox || !gameOfTheDayContainer) {
         console.log("News or Game of the Day elements not found.");
         return;
       }

       newsBox.textContent = "Loading news...";
       gameOfTheDayContainer.innerHTML = ''; // Clear previous content
       console.log("Fetching news...");

       fetch('https://hostfilez.glitch.me/news.txt')
         .then(response => {
              if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
              console.log("News fetched successfully.");
              return response.text();
          })
         .then(text => {
           let rawNewsText = text;
           let gameOfTheDayName = null;

           const gameOfTheDayRegex = /\{([^}]+)\}/; // Matches {Game name} and captures Game name
           const match = rawNewsText.match(gameOfTheDayRegex);

           if (match && match[1]) {
             gameOfTheDayName = match[1].trim();
             console.log("Found Game of the Day name:", gameOfTheDayName);

             // Remove the {Game name} marker from the news text
             rawNewsText = rawNewsText.replace(gameOfTheDayRegex, '').trim();

             // Find the game in the games array
             const gameOfTheDay = games.find(game => game.name.toLowerCase() === gameOfTheDayName.toLowerCase());

             if (gameOfTheDay) {
               console.log("Found Game of the Day data:", gameOfTheDay.name);

               // Find the index of the game in the main games array (needed for favorite/proxy toggling)
               const gameIndex = games.findIndex(game => game.name.toLowerCase() === gameOfTheDayName.toLowerCase());

               // Generate HTML for the Game of the Day container
               gameOfTheDayContainer.innerHTML = `
                  <h3>Game of the Day</h3>
                  <div class="game-card" style="width: 100%; margin: 0;">
                     <img src="${escapeHtml(gameOfTheDay.icon)}" alt="${escapeHtml(gameOfTheDay.name)}"
                           onerror="this.src='https://via.placeholder.com/150?text=No+Image'"
                           onclick="loadGame('${escapeHtml(gameOfTheDay.name)}', '${escapeHtml(gameOfTheDay.url)}')">
                      <p onclick="loadGame('${escapeHtml(gameOfTheDay.name)}', '${escapeHtml(gameOfTheDay.url)}')">${escapeHtml(gameOfTheDay.name)}</p>
                       <div style="display: flex; flex-direction: column; gap: 5px; align-items: center; margin-top: 5px;">
                           <button class="favorite-button" onclick="event.stopPropagation(); toggleFavoriteGame(${gameIndex})">
                                <i class="fas ${isFavoriteGame(gameOfTheDay) ? 'fa-solid' : 'fa-regular'} fa-star" style="${isFavoriteGame(gameOfTheDay) ? 'color: var(--accent);' : ''}"></i>
                                <span>${isFavoriteGame(gameOfTheDay) ? 'Favorited' : 'Favorite'}</span>
                           </button>
                           ${gameOfTheDay.proxiedUrl && gameOfTheDay.proxiedUrl !== 'none' ? // Only show proxy toggle if proxy URL exists
                            `<button class="favorite-button" onclick="event.stopPropagation(); toggleProxied(${gameIndex})">
                              <i class="fas fa-shield-alt"></i>
                              <span>Proxy: ${gameOfTheDay.proxied ? 'On' : 'Off'}</span>
                            </button>`
                            : ''
                          }
                      </div>
                   </div>
               `;
               console.log("Generated Game of the Day game-card HTML.");

               // Note: Clicking Favorite or Proxy toggle on the Home page
               // will update the state in games array and localStorage,
               // but the button display on the Home page won't auto-update
               // unless you manually re-render the game-of-day-container
               // or refetch the news after a toggle. The functionality still works.

             } else {
                 console.log("Game of the Day not found in games list:", gameOfTheDayName);
                  gameOfTheDayContainer.innerHTML = `
                     <h3>Game of the Day</h3>
                     <p style="color: var(--text-muted);">Game "${escapeHtml(gameOfTheDayName)}" not found.</p>
                  `;
             }
           } else {
             console.log("No {Game name} found in news text.");
               gameOfTheDayContainer.innerHTML = `
                  <h3>Game of the Day</h3>
                  <p style="color: var(--text-muted);">No Game of the Day selected.</p>
               `;
           }

           // Process and display the remaining news text
           const processedNewsText = processLinkedText(rawNewsText);
           newsBox.innerHTML = processedNewsText;

         })
         .catch(err => {
           console.error("Failed to load news:", err);
           newsBox.textContent = "Failed to load news.";
           gameOfTheDayContainer.innerHTML = `
               <h3>Game of the Day</h3>
               <p style="color: var(--text-muted);">Failed to load Game of the Day.</p>
           `;
         });
     }
    
    function openChangelogModal() {
      const modal = document.getElementById("changelogModal");
      const content = document.getElementById("changelogContent");
      if (!modal || !content) return;
      modal.style.display = "flex";
      content.textContent = "Loading...";
      fetch('https://hostfilez.glitch.me/changelog.txt')
        .then(response => response.text())
        .then(text => {
          const processedText = processLinkedText(text);
          content.innerHTML = processedText;
        })
        .catch(err => {
          console.error("Failed to load changelog:", err);
          content.textContent = "Failed to load changelog.";
        });
    }

    function closeChangelogModal() {
      console.log('Closing changelog modal.');
      const modal = document.getElementById("changelogModal");
      if (modal) {
        modal.style.display = "none";
      }
    }



// --- UPDATED DOMContentLoaded listener ---
// --- UPDATED DOMContentLoaded listener ---
window.addEventListener('DOMContentLoaded', async () => { // Make it async
      console.log('DOMContentLoaded fired. Starting application initialization...');

      // Load localStorage data first (themes, games, library, non-handle settings)
      loadData(); // Loads themes, games, library, favorites, app settings
      loadPanicKeySettings(); // Load panic key settings
      console.log('Non-handle data and settings loaded.');

      // NEW: Attempt to load the directory handle from IndexedDB and check permissions
      await mp_loadHandleAndCheckPermissions();
      console.log('Directory handle load and initial permission check completed.');
      // END NEW

      // Now load music metadata (library, playlists, recents) from IndexedDB and LocalStorage
      // This populates mp_musicLibrary from the LAST successful scan/save, even if permission is lost.
      await mp_loadMusicData(); // *** Use the new async function ***
      console.log('Music Player metadata loaded from IndexedDB/LocalStorage.');

      // --- ADD THE mp_fileInput LISTENER HERE ---
      mp_fileInput = document.getElementById('mp_fileInput'); // Get the element reference here
      if (mp_fileInput) {
           mp_fileInput.addEventListener('change', mp_handleFileSelect);
           console.log('MP: mp_fileInput change listener attached during DOMContentLoaded.');
      } else {
           console.warn('MP: mp_fileInput element not found during DOMContentLoaded. File fallback will not work.');
      }
      // --- END ADDITION ---

      // Initialize Vanta.js (can run in parallel or after data load)
      setTimeout(() => {
           console.log('Attempting to initialize Vanta.js...');
           initializeVanta();
           if (vantaEffect) setTheme(currentThemeName); // Apply theme colors to Vanta
           else console.warn('Vanta effect is null after initialization.');
      }, 50);

      // Initialize the Music Player Playback Bar (safe to call now as mp_musicLibrary is populated)
      mp_initializePlaybackBar();
      console.log('Music Player playback bar initialization called.');

      // *** NEW: Initialize the Music Hover Overlay ***
      initializeMusicHoverOverlay();
      console.log('Music Hover Overlay initialization called.');
      // *** END NEW ***


      // Set up general event listeners (sidebar, modals, keys, etc.)
      setupEventListeners();
      console.log('General event listeners set up.');

      // Switch to the initial page and render content based on loaded data (from IndexedDB/LocalStorage)
      // This happens *after* initial data load, and potentially after initial directory processing
      // Initial rendering uses the mp_musicLibrary populated by mp_loadMusicData or mp_processDirectoryHandle
      switchPage(localStorage.getItem('lastActivePage') || 'Home');
      console.log('Initial page switched to:', localStorage.getItem('lastActivePage') || 'Home');


      // --- NEW: If a directory handle was loaded and granted permission on load, process the directory ---
      // This ensures the library is updated if files changed since the last visit
      // This happens AFTER initial data load and initial UI render to show something quickly
      if (mp_currentDirectoryHandle) {
           console.log("MP: Directory handle available and permission granted on load. Starting background directory processing...");
           // Process the directory (this will update IndexedDB with new/changed files and re-load the in-memory library)
           // Wrap in a try...catch to prevent blocking if processing fails
           mp_processDirectoryHandle(mp_currentDirectoryHandle).then(() => {
               console.log("MP: Background directory processing on load completed.");
               // Lists are re-rendered at the end of mp_processDirectoryHandle
           }).catch(err => {
               console.error("MP: Error during background directory processing on load:", err);
               // The UI should show the permission prompt if needed by mp_processDirectoryHandle's permission checks
               // The lists are already rendered based on the initial load
           });
      } else {
           console.log("MP: No directory handle available or permission not granted on load. Skipping background directory processing.");
           // The UI is already rendered based on the initial load from IndexedDB/LocalStorage.
           // The permission UI will be updated if needed by mp_loadHandleAndCheckPermissions.
      }
      // --- END NEW ---


       // Periodic Checks (start after initial setup)
       setInterval(checkVersion, 60000);
       console.log("Periodic update check started.");
       setInterval(checkNotifications, 15000);
       console.log("Periodic notification check started.");
       checkNotifications(); // Initial check

      console.log('Application initialization completed.');
    });

  </script>
</body>
</html>
